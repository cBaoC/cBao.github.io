[{"id":"710e93f12251a070d08d271cb7816514","title":"C#语法","content":"三种注释方法\n双斜杠注释（//）：用于注释一行信息\n星号注释（/**/）：用于注释多行信息\n三斜杠注释（///）：用于注释类，命名空间等\n\n\n\n\n\n\n\n提示\n注释：Ctrl+K+C  取消注释：Ctrl+K+U\n\n控制台的输入和输出\n\n\nAPI\n功能描述\n\n\n\nConsole.Write();\n在控制台输出不会自动换行\n\n\nConsole.WriteLine();\n在控制台输出会自动换行\n\n\nConsole.ReadLine();\n等待用户输入一行，按回车键结束输入\n\n\nConsole.ReadKey();\n只要用户按下任意键就结束\n\n\n折叠代码块//用于整理代码，方便阅读，只在编辑时有效\n#region cBaoTest\nConsole.WriteLine(\"折叠代码块\\n\");\n#endregion\n\n变量类型\n\n\n类型\n描述\n范围\n默认值\n\n\n\nbool\n布尔值\nTrue 或 False\nFalse\n\n\nbyte\n8 位无符号整数\n0 到 255\n0\n\n\nchar\n16 位 Unicode 字符\nU +0000 到 U +ffff\n‘\\0’\n\n\ndecimal\n128 位精确的十进制值，28-29 有效位数\n(-7.9 x 1028 到 7.9 x 1028) / 100 到 28\n0.0M\n\n\ndouble\n64 位双精度浮点型\n(+/-)5.0 x 10-324 到 (+/-)1.7 x 10308\n0.0D\n\n\nfloat\n32 位单精度浮点型\n-3.4 x 1038 到 + 3.4 x 1038\n0.0F\n\n\nint\n32 位有符号整数类型\n-2,147,483,648 到 2,147,483,647\n0\n\n\nlong\n64 位有符号整数类型\n-9,223,372,036,854,775,808 到 9,223,372,036,854,775,807\n0L\n\n\nsbyte\n8 位有符号整数类型\n-128 到 127\n0\n\n\nshort\n16 位有符号整数类型\n-32,768 到 32,767\n0\n\n\nuint\n32 位无符号整数类型\n0 到 4,294,967,295\n0\n\n\nulong\n64 位无符号整数类型\n0 到 18,446,744,073,709,551,615\n0\n\n\nushort\n16 位无符号整数类型\n0 到 65,535\n0\n\n\n四种类型转换方式\n括号强转\n\n用于将大范围数转换成小范围数，不安全转换\nbool和string类型不支持该强转\n\nint i=10;\nsbyte s1=(sbyte)i;\nParse转换\n\n将字符串转换为对应类型，安全转换\n\nint TestInt = int.Parse(\"1234\");\nConvert转换\n\n各个类型之间的转换\n\nfloat f1 = 3.4f;\nint i = Convert.ToInt32(f1);\nConsole.WriteLine(i);\nToString转换\n\n其它类型转成string类型\n\nfloat f1 = 3.4f;\nstring s1 = f1.ToString();\n\n异常捕获string s1 = \"请输入语文成绩:\";\nwhile (true)\n&#123;\n    //try尝试捕获错误\n    try\n    &#123;\n        Console.Write(s1);\n        YuWen = int.Parse(Console.ReadLine());\n        break;\n    &#125;\n    //若try中有错误将执行catch中代码\n    catch\n    &#123;\n        s1 = \"输入不合法，请重新输入语文成绩:\";\n        continue;\n    &#125;\n&#125;\n\n字符串拼接方式\n使用+号\n//+号两边必须要有一个string类型\nstring s1=\"\";\ns1 +=1+2+3;//结果是6\ns1 +=\" \"+1+2+3;//结果是123，从第一个字符串类型之后都会自动调用ToString之后在进行拼接\n使用string.Format()\n//拼接的内容用占位符代替，数字0~n\n//内容不能少于占位符\nstring.Format(\"&#123;0&#125;,&#123;1&#125;\", \"cBao\", \"nice\")\n\n位运算\n二进制按位进行运算\n\n\n\n\n位运算符\n介绍\n\n\n\n按位与 &amp;\n有0则0\n\n\n按位或 |\n有1则1\n\n\n按位异或 ^\n相同为0，不同为1\n\n\n按位取反 ~\n0变1，1变0\n\n\n左移 &lt;&lt;\n左移几位，右边加几个0\n\n\n右移 &gt;&gt;\n右移几位，右侧去掉几个数\n\n\n控制台控制方法\n清空\nConsole.Clear();\n设置窗口大小，屏幕缓冲区大小\nConsole.SetWindowSize(100, 50);\nConsole.SetBufferSize(100, 50);\n\n\n\n\n\n\n\n提示\n\n先设置窗口大小，在设置屏幕缓冲区大小\n屏幕缓冲区大小不能小于窗口大小\n窗口大小不能大于控制台最大尺寸\n\n\n\n\n设置光标位置\nConsole.SetCursorPosition(10, 5);\n\n\n\n\n\n\n\n提示\nx和y的单位不同，1y=2x 视觉上\n\n\n\n控制台颜色\n//文字颜色\nConsole.ForegroundColor = ConsoleColor.Red;\n//背景颜色\n Console.BackgroundColor = ConsoleColor.Blue;\n Console.Clear();//设置背景颜色后必须用Clear一次\n光标显示隐藏\nConsole.CursorVisible = true;\nConsole.CursorVisible = false;\n关闭控制台\nEnvironment.Exit(0);//在调试状态下无效\n\n随机数\n固定写法\n //创建随机数对象\n Random r = new Random();\n //0~99的随机数\n int i = r.Next(100);\n Console.WriteLine(i);\n\n //生成一个大于0的随机数\n int i2 = r.Next();\n Console.WriteLine(i2);\n\n//生成一个大于等于8小于13的一个随机数\n int i3 = r.Next(8, 13);\n Console.WriteLine(i3);\n\n数组\n数组的声明方式\n//第一种\nint[] Arr;\n\n//第二种\nint[] Arr_2 = new int[5];\n\n//第三种\nint[] Arr_3 = new int[5] &#123; 1, 2, 3, 4, 5 &#125;;\n\n//第四种\nint[] Arr_4 = new int[] &#123; 1, 2, 3, 4, 5, 6 &#125;;\n\n//第五种\nint[] Arr_5 = &#123; 1, 2, 3, 4, 5 &#125;;\n二维数组\n//声明一个2行3列的二维数组\nint[,] Arr = new int[2, 3];\n//获得行数\nint x=Arr.GetLength(0);\n//获得列数\nint y=Arr.GetLength(1);\n\n值类型和引用类型值类型：基本变量类型，结构体，存储在栈空间，由计算机管理（它变我不变）\n引用类型：string（特殊，更像值类型）,数组，类，存储在堆空间，由程序员进行管理（它变我也变(用new可解除)）\n函数\n写在class或者struct中\n\nref和out\n用于函数重载时ref和out不能同时修饰同一变量\n\nref类似C++中的引用，传入的变量必须初始化，可以不在内部赋值\nstatic void Test(ref int A)\n&#123;\n    A = 30;\n&#125;\n\nint A = 10;//初始化\nTest(ref A);//A被改成30\nConsole.WriteLine(A);\nout与ref功能一样，但是传入的变量不必初始化，必须在内部赋值\nstatic void Test(out int A)\n&#123;\n    A = 30;\n&#125;\n\nint A;//不必初始化\nTest(out A);//A被改成30\nConsole.WriteLine(A);\n\n变长参数\n关键字：params\n\n一个函数中只能有一个变长参数，且必须在最后一个参数\n static int ParamSum(params int[] Arr)\n&#123;\n  int Sum = 0;\n  for (int i = 0; i &lt; Arr.Length; i++)\n  &#123;\n    Sum += Arr[i];\n  &#125;\n  return Sum;\n&#125;\n\n函数重载\n与C++函数重载类似\n\n递归函数\n自己调用自己的函数\n必须要有能结束函数调用的条件\n\n结构体\n一般写在namespace中\n\n结构体中声明的变量不能直接初始化\n\n在结构体中函数不需要添加static关键字\n\n结构体构造函数\n\n没有返回值\n必须有参数\n函数名与结构体名相同\n必须在其中对所有变量数据初始化\n\n\nC#中struct默认访问修饰符是private\nstruct cBao\n&#123;\n\n    public string Name;\n\n    public int Age;\n\n    public int Number;\n\n\n    public void PrintfName()\n    &#123;\n        Console.WriteLine(Name);\n    &#125;\n\n&#125;\n\n排序\n冒泡排序\n//升序\nstatic void BubbleSortUp(int[] Arr)\n&#123;\n    for (int x = 0; x &lt; Arr.Length; x++)\n    &#123;\n        for (int y = 0; y &lt; Arr.Length - 1-x; y++)\n        &#123;\n            if (Arr[y] >= Arr[y + 1])\n            &#123;\n                int Temp = Arr[y];\n                Arr[y] = Arr[y + 1];\n                Arr[y + 1] = Temp;\n            &#125;\n        &#125;\n    &#125;\n&#125;\n//降序\nstatic void BubbleSortDown(int[] Arr)\n&#123;\n    for (int x = 0; x &lt; Arr.Length; x++)\n    &#123;\n        for (int y = 0; y &lt; Arr.Length - 1-x; y++)\n        &#123;\n            if (Arr[y] &lt;= Arr[y + 1])\n            &#123;\n                int Temp = Arr[y];\n                Arr[y] = Arr[y + 1];\n                Arr[y + 1] = Temp;\n            &#125;\n\n        &#125;\n\n    &#125;\n\n&#125;\n\n//优化版\nstatic void BubbleSortUp(int[] Arr)\n        &#123;\n\n            bool isSort = false;\n\n            for (int x = 0; x &lt; Arr.Length; x++)\n            &#123;\n                for (int y = 0; y &lt; Arr.Length - 1-x; y++)\n                &#123;\n                    if (Arr[y] >= Arr[y + 1])\n                    &#123;\n                        isSort = true;\n                        int Temp = Arr[y];\n                        Arr[y] = Arr[y + 1];\n                        Arr[y + 1] = Temp;\n                    &#125;\n\n                &#125;\n                if (!isSort)\n                    break;\n            &#125;\n\n        &#125;\n\n类和对象\n一般声明在namespace中\n类是一个引用类型\n不能在类中实例化一个相同类型的变量\n访问修饰符与C++类似\n构造函数规则与C++类似\n析构函数（Unity中基本不会使用），C#中存在自动垃圾回收机制GC一般也不使用\n\n垃圾回收机制\nGC只负责堆（Heap）内存的垃圾回收\n\n引用类型都是存在于堆（Heap）中\n\n手动触发垃圾回收方法\nGC.Collect();\n\n成员属性\n用于保护成员变量\n\n为成员属性的获取和赋值添加逻辑处理\n\nget和set的访问权限不能高于或者等于外部访问权限\n\n用帕斯卡命名法\n\nget和set可以只有一个\nclass TestInfo\n&#123;\n    private string name;\n  \n    public string Name\n    &#123;\n        get\n        &#123;\n            return name;\n        &#125;\n  \n        set\n        &#123;\n            name = value;\n        &#125;\n  \n    &#125;\n&#125;\n自动属性（特殊需求）\n\n用于外部能得不能改的变量\nclass TestInfo\n   &#123;\n       private string name;\n    \n       public string Name\n       &#123;\n           get\n           &#123;\n               return name;             \n           &#125;\n    \n           set\n           &#123;\n               name = value;\n               //可以直接在类内当成员变量直接使用\n               Age = 20;\n           &#125;\n       &#125;\n    \n       public int Age\n       &#123;\n           get;\n           private set;\n       \n       &#125;\n   &#125;\n\n\n\n索引器\n一般成员中有数组参数时可以简化使用\nclass MyArr\n    &#123;\n        private int[] arr;\n        private int currentIndex;\n        //查\n        //改\n        public int this[int index]\n        &#123;\n            get\n            &#123;\n                if (index >= 0 &amp;&amp; index &lt;= currentIndex)\n                &#123;\n                    return arr[index];\n                &#125;\n                return -1;\n            &#125;\n            set \n            &#123;\n                if (index >= 0 &amp;&amp; index &lt;= currentIndex)\n                &#123;\n                    arr[index] = value;\n                &#125;\n                else\n                &#123;\n                    Console.WriteLine(\"索引超过数组范围\");\n                &#125;\n\n            &#125;\n        \n       &#125;\n\n静态成员\n用static修饰的成员变量，方法，属性等称为静态成员，具有唯一性\n可以直接用类名 **. ** 出来使用\n静态成员与程序同生共死（程序运行就会在静态存储区分配内存）\n静态成员不能直接使用非静态成员（因为此时普通成员还没有被实例化）\n静态变量：1.常用于唯一变量的声明，2.方便别人获取的对象申明\n静态方法：常用的唯一方法申明\nconst常量是一种特殊的static成员，也可以直接用类名 . 出来使用\n\nclass Test\n&#123;\n    //将构造函数声明成私有保证外部不能创建对象\n    private Test()\n    &#123;\n\n\n    &#125;\n\n    //静态成员变量保证唯一性\n    private static Test t = new Test();\n\n    //成员属性方法保证只能外部得不能改\n    public static Test T\n    &#123;\n        get \n        &#123;\n            return t;\n        &#125;      \n    &#125;\n\n    public void Print()\n    &#123;\n        Console.WriteLine(\"我是一个单例\");        \n    &#125;\n&#125;\n\nclass Program\n&#123;\n    static void Main()\n    &#123;\n        Test.T.Print();\n    &#125; \n&#125;\n\n静态类\n用static修饰的类\n静态类不能被实例化\n只能存在静态成员\n一般用于唯一工具类（将常用的静态成员写在静态类中，方便使用）\n\n静态构造函数\n用static修饰的构造函数\n静态类和普通类都可以存在静态构造函数\n不能有参数\n只会自动调用一次\n用于在静态构造函数中初始化静态变量 \n\n拓展方法\n为现有非静态的变量类型添加新方法\n\n一定写在静态类中\n\n一定是静态函数\n\n基本语法\n//访问修饰符 static 返回值 函数名(this 拓展类型 参数名,参数类型 参数名...)\n    static class Tool\n    &#123;\n        public static void SpeadValue(this int Value)\n        &#123;\n            Console.WriteLine(\"int拓展方法\");\n        \n        &#125;\n    \n    &#125;\n\n运算符重载\n让自定义类和结构体对象可以进行运算\n\n条件运算符需要成对实现\n\n一个符号可以多个重载\n\n不能使用ref和out\n\n基本语法\nclass Point\n&#123;\n    public int x;\n    public int y;\n\n    public Point(int x, int y)\n    &#123;\n        this.x = x;\n        this.y = y;\n    &#125;\n    \n    //访问修饰符 static 返回类型 operator 运算符(参数列表)\n    public static bool operator == (Point A, Point B)\n    &#123;\n        if (A.x == B.x &amp;&amp; A.y == B.y)\n        &#123;\n            return true;\n        &#125;\n        return false;\n    &#125;\n    \n    //访问修饰符 static 返回类型 operator 运算符(参数列表)\n    public static bool operator !=(Point A, Point B)\n    &#123;\n        if (A.x != B.x || A.y != B.y)\n        &#123;\n            return true;\n        &#125;\n        return false;\n\n    &#125;\n&#125;\n\n","slug":"CSharp语法","date":"2022-09-13T15:16:35.000Z","categories_index":"","tags_index":"","author_index":"cBao"},{"id":"321e20a64de3485e0958a3f7db00142f","title":"UE中的网络同步RPC","content":"UE网络中的服务器在哪！\n在UE中存在服务器和客户端重合，创建房间的客户端同时具备服务器特性\n\nUE中服务器和客户端中对象的关系\n在服务器端，所有的角色（Actor）都是Authority（权威的）\n在客户端眼，除了自己控制的角色外，其他的所有角色都是Simulated proxy（模拟代理）\n在UE网络框架中，Actor是促成网络同步的重要对象\n\nActor的更新方式\n属性更新（针对成员变量）具有及时性，随属性变换而进行通知。属性更新不变化不消耗带宽，但会消耗CPU进行监听\nRPC（针对函数），由用户进行调用\n\nUE网络框架对象归属分类\n\n\nServer Only（仅存在于服务器上）\nServer &amp; Clients（存在于服务器和所有客户端）\nServer &amp; Owning Client（仅存在于服务器和自身客户端）\nOwning Client Only（仅存在于自己客户端）\n\n\n\nAGameMode\nAGameState\nAPlayerController\nAHUD\n\n\n\nAPlayerState\n\nUMG Widget\n\n\n\nAPawn\n\n\n\n\n角色类型标记\n每个Actor中都存在两个属性用来裁定当前Actor在服务器/客户端上的身份类型，分为Role和RemoteRole\n在蓝图中为LocalRole和RemoteRole\nGet Local Role：判断当前角色在本地端身份类型\nGet Remote Role：判断当前角色在远端身份类型（当是客户端时，远端为服务端，当是服务端时，远端是客户端）\n\n网络角色三种类型\nSimulated：由服务器进行数据发送，当前终端进行操控模拟。操控来源于服务器，Simulate对象无法执行RPC函数\nAutonomous：由当前终端实例进行操控。操控来源于真人\nAuthority：服务器端存在标记，表明当前Actor存在于服务器\n\nRPC远端调用，在本机上调用函数，但在其他机器上远程执行的函数。\nRPC执行的三种形式\n服务端执行（Server） ：由客户端调用，在服务器端执行\n客户端执行（Client）： 由服务器端调用，在客户端执行\n所有终端执行（Multicast）  ：由服务器端调用，在所有终端执行\n\nRPC调用注意事项\n必须从 Actor 上调用\n\nActor 必须能被复制（Replicates=true）\n\n如果 RPC 是从服务器调用并在客户端上执行，则只有实际拥有这个 Actor 的客户端才会执行函数\n\n如果 RPC 是从客户端调用并在服务器上执行，客户端就必须拥有调用 RPC 的 Actor。\n\n从服务器上调用RPC\n\n\n\nActor所有权\n未复制\nNetMulticast\nServer\nClient\n\n\n\nClient-Owned Actor\n在服务器上运行\n在服务器和所有客户端上运行\n在服务器上运行\n在 actor  的所属客户端上运行\n\n\nServer-owned actor\n在服务器上运行\n在服务器和所有客户端上运行\n在服务器上运行\n在服务器上运行\n\n\nUnowned actor\n在服务器上运行\n在服务器和所有客户端上运行\n在服务器上运行\n在服务器上运行\n\n\n\n从客户端上调用RPC\n\n\n\nActor所有权\n未复制\nNetMulticast\nServer\nClient\n\n\n\nOwned by invoking client（当前终端所有权）\n在执行调用的客户端上运行\n在执行调用的客户端上运行\n在服务器上运行\n在执行调用的客户端上运行\n\n\nOwned by a different client  （其他终端所有权）\n在执行调用的客户端上运行\n在执行调用的客户端上运行\n丢弃\n在执行调用的客户端上运行\n\n\nServer-owned actor\n在执行调用的客户端上运行\n在执行调用的客户端上运行\n丢弃\n在执行调用的客户端上运行\n\n\nUnowned actor\n在执行调用的客户端上运行\n在执行调用的客户端上运行\n丢弃\n在执行调用的客户端上运行\n\n\n\n\n蓝图中判断服务器和客户端\n\nAuthority：服务器\nRemote：客户端\n\nRPC执行的三种形式\n服务端执行（Server）：在客户端调用，在服务端执行\n客户端执行（Client）:在服务端调用，在客户端执行\n所有终端执行（Multicast）：只能在服务端调用，在所有终端执行\n\n设置Actor所有权\n蓝图中使用Set Owner节点在服务器上获得Actor所有权\n\n\n\n数据同步\nActor必须满足在网络上被复制,设置的参数需要开启复制\n参数的修正必须在服务器端修改,才可以在网络上同步\n蓝图参数同步的两种方式：\nReplicated，同步数据，但没有通知，无法直接通过参数修改驱动逻辑\n•RepNotify，同步数据，并生成通知函数，进行更新通知（向所有终端通知，满足相关性）\n\n\n\n","slug":"UE中的网络同步RPC","date":"2022-08-15T07:32:03.000Z","categories_index":"UnrealEngine","tags_index":"网络同步RPC","author_index":"cBao"},{"id":"fa2dad943cb3925ed47cb72cd3308d02","title":"UE中的文件API","content":"检查文件夹是否存在//文件路径\nFString Dir=FPaths::ProjectDir()/TEXT(\"cBao\");\n//检查文件是否存在\nIFileManager::Get().DirectoryExists(*Dir)\n\n创建文件夹IFileManager::Get().MakeDirectory(*Dir);\n\n检查文件是否存在//注意是/=\nFString Dir=FPaths::ProjectDir()/TEXT(\"cBao\");\nDir /=TEXT(\"cBao.txt\");\n\n//检查文件是否存在\nIFileManager::Get().FileExists(*Dir);\n//创建文件\n\nFFileHelper::SaveStringToFile(TEXT(\"cBao\"),*Dir);\n\n删除文件FString Dir=FPaths::ProjectDir()/TEXT(\"cBao/cc/cc2/cBao.txt\");\n//一般用于删除单个特定文件\nIFileManager::Get().Delete(*Dir);\n\nFString Dir2=FPaths::ProjectDir()/TEXT(\"cBao\");\n//一般用于删除整个文件夹\nIFileManager::Get().DeleteDirectory(*Dir2,true,true);\n\n拷贝文件//不带拷贝进度的拷贝\nFString Src=FPaths::ProjectDir()/TEXT(\"cBao/cc.pdf\");\nFString Dest=FPaths::ProjectDir()/TEXT(\"cBao/cc2.pdf\");\nIFileManager::Get().Copy(*Dest,*Src);\n\n//带拷贝进度的拷贝\n//继承FCopyProgress抽象类,用来显示拷贝进度\nstruct MyProgress:public FCopyProgress\n&#123;\n    //Fraction为拷贝进度百分比\n\tFORCEINLINE virtual bool Poll( float Fraction ) override\n\t&#123;\n\t\tGEngine->AddOnScreenDebugMessage(-1,10.f,FColor::Blue,FString::SanitizeFloat(Fraction));\n\t\treturn true;\n\t&#125;\n&#125;;\nFString Src2=FPaths::ProjectDir()/TEXT(\"cBao/cc.pdf\");\nFString Dest2=FPaths::ProjectDir()/TEXT(\"cBao/cc2.pdf\");\n//创建进度结构\nMyProgress cBaoProgress;\nIFileManager::Get().Copy(*Dest2,*Src2,true,false,false,&amp;cBaoProgress);\n\n文件信息//文件信息(创建日期，访问日期，修改日期，文件大小，是否是文件夹，是否只读，是否有效)\nFFileStatData FileState=IFileManager::Get().GetStatData(*Src);\n\n查找文件//文件路径\nFString Dir=FPaths::ProjectDir()/TEXT(\"cBao\");\n//检查路径是否存在\nif (IFileManager::Get().DirectoryExists(*Dir))\n&#123;\n    //保存文件名称\n\tTArray&lt;FString> NameArray;\n    //查找文件操作 *代表通配符\n\tIFileManager::Get().FindFiles(NameArray,*Dir,TEXT(\"*\"));\n\tfor(auto &amp;Temp:NameArray)\n\t&#123;\n\t\tGEngine->AddOnScreenDebugMessage(-1,10.f,FColor::Blue,Temp);\n\t&#125;\n&#125;\n\n递归查找指定目录下的文件路径//文件路径\nFString Dir=FPaths::ProjectDir()/TEXT(\"cBao\");\n//检查路径是否存在\nif (IFileManager::Get().DirectoryExists(*Dir))\n&#123;\n    //保存文件路径\n\tTArray&lt;FString> PathNameArray;\n    //查找文件操作 *代表通配符 第一个true代表查找文件,第二个false代表忽略文件夹\n\tIFileManager::Get().FindFilesRecursive(PathNameArray,*Dir,TEXT(\"*\"),true,false);\n\tfor (auto&amp; Name:PathNameArray)\n\t&#123;\n\t\tGEngine->AddOnScreenDebugMessage(-1,10.f,FColor::Red,Name);\n\t&#125;\n\n&#125;\n\n","slug":"UE中的文件操作","date":"2022-08-05T05:58:47.000Z","categories_index":"UnrealEngine","tags_index":"文件操作","author_index":"cBao"},{"id":"62bbf97645975b25a08d1c093027a65e","title":"UE中内存操作","content":"分配内存// C\nuint8* Ptr_C=(uint8*)malloc(sizeof(uint8)*1024);\n\t\n// C++\nuint8* Ptr_CPlus=new uint8[1024];\n\n// UEC++\nuint8* Ptr_UnrealCPlus=(uint8*)FMemory::Malloc(sizeof(uint8)*1024);\n\n\n重新分配内存// C/C++\nPtr_C=(uint8*)realloc(Ptr_C,sizeof(uint8)*2048);\n\t\n// UEC++\nFMemory::Realloc(Ptr_UnrealCPlus,sizeof(uint8)*2048);\n\n获得分配的内存大小int32 i = FMemory::GetAllocSize(Ptr_UnrealCPlus);\n\n\n\n\n\n\n\n\n特别注意\n只能获得 FMemory::Malloc() 分配的内存大小，否则会产生崩溃\n\n拷贝char Date1[1024]=\"Hello,World\";\nchar Date2[1024];\n// C/C++\nmemcpy(Date2,Date1,strlen(Date1));\n\n// UEC++\nFMemory::Memcpy(Date2,Date1,strlen(Date1));\n\n移动内存char Date1[1024]=\"Hello,World\";\nchar Date2[1024];\n// C/C++\nmemmove(Date2,Date1,strlen(Date1));\n\n// UEC++\nFMemory::Memmove(Date2,Date1,strlen(Date1));\n\n比较// C/C++\nchar DateComp[1024]=\"cBao2\";\nchar DateComp_2[1024]=\"cBao\";\nint32 Size=memcmp(DateComp,DateComp_2,sizeof(uint8)*5);\n\n// UEC++\nint32 Size2 = FMemory::Memcmp(DateComp,DateComp_2,sizeof(uint8)*5);\n\n\n\n\n\n\n\n\n注意\n当 DateComp&lt;DateComp_2 时返回值&lt;0\n当 DateComp=DateComp_2 时返回值=0\n当 DateComp&gt;DateComp_2 时返回值&gt;0\n\n\n交换char DateComp[1024]=\"cBao2\";\nchar DateComp_2[1024]=\"cBao\";\nFMemory::Memswap(DateComp,DateComp_2,sizeof(uint8)*5)\n\n\n\n\n\n\n\n\n注意\n仅UEC++中存在该API\n\n\n初始化方式//原生C\nmemset(Ptr_C,0,sizeof(uint8)*1024);\nmemset(Ptr_CPlus,0,sizeof(uint8)*1024);\n\n//C++中\nuint8* Ptr_CPlus2=new uint8[]&#123;1,23,4,5,5&#125;;\n\t\n//UEC++\nZeroMemory(Ptr_C,sizeof(uint8)*1024);\nZeroMemory(Ptr_CPlus,sizeof(uint8)*1024);\nFMemory::Memset(Ptr_UnrealCPlus,0,sizeof(uint8)*1024);\nFMemory::Memzero(Ptr_UnrealCPlus,sizeof(uint8)*1024);\n//在申请时就进行初始化\nuint8* Ptr_UnrealC=(uint8*)FMemory::MallocZeroed(sizeof(uint8)*1024);\n\n清除//C\nfree(Ptr_C);\n\t\n//C++中\ndelete[](Ptr_CPlus);\ndelete[](Ptr_CPlus2);\n\n//UEC++中\nFMemory::Free(Ptr_UnrealCPlus);\n\n\n\n\n\n\n\n\n特别注意\nFMemory::Free() 容易造成引擎崩溃\n\n\n","slug":"UE内存操作","date":"2022-08-04T07:41:08.000Z","categories_index":"UnrealEngine","tags_index":"内存操作","author_index":"cBao"},{"id":"ae911ea8c615446cd5e6fd02771c3f77","title":"Json","content":"JSON 语法规则\n数据在键/值对中\n数据由逗号 , 分隔\n使用斜杆来转义 \\ 字符\n大括号 {} 保存对象\n中括号 [] 保存数组，数组可以包含多个对象\n\nJSON 键值对JSON 数据的书写格式是：\n\"name\" : \"cBao\"\n\nJSON 值可以是\n数字（整数或浮点数）\n\"age\":30\n字符串（在双引号中）\n\"name\":\"cBao\"\n逻辑值（true 或 false）\n\"IsDeath\":false\n数组（在中括号中）\n&#123;\n    \"Info\": [\n    &#123; \"age1\":30 , \"name1\":\"cBao\" &#125;, \n    &#123; \"age2\":30 , \"name2\":\"cBao\" &#125;, \n    &#123; \"age3\":30 , \"name3\":\"cBao\" &#125;,\n    ]\n&#125;\n对象（在大括号中）\n&#123;\n  \"Object\":&#123;\n      \"age\":30, \n    \"name\":\"cBao\" \n  &#125;  \n&#125;\nnull\n\"runoob\":null\n\nUE5中将结构体转换成Json示例\n.Build.cs文件需要加入\nPrivateDependencyModuleNames.Add(\"Json\");\n.h文件\n// Fill out your copyright notice in the Description page of Project Settings.\n\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"Kismet/BlueprintFunctionLibrary.h\"\n#include \"StructToJson.generated.h\"\n\nUSTRUCT(BlueprintType)\nstruct FMyInfo\n&#123;\n\tGENERATED_BODY()\n\n\tUPROPERTY(EditAnywhere,BlueprintReadWrite)\n\tFString Name;\n\tUPROPERTY(EditAnywhere,BlueprintReadWrite)\n\tint32 Age;\n&#125;;\n\n\nUSTRUCT(BlueprintType)\nstruct FMyStruct\n&#123;\n\tGENERATED_BODY()\n\t\n\tUPROPERTY(EditAnywhere,BlueprintReadWrite)\n\tFString Name;\n\t\n\tUPROPERTY(EditAnywhere,BlueprintReadWrite)\n\tint32 Age;\n\t\n\tUPROPERTY(EditAnywhere,BlueprintReadWrite)\n\tbool Gender;\n\t\n\tUPROPERTY(EditAnywhere,BlueprintReadWrite)\n\tfloat Weight;\n\n\tUPROPERTY(EditAnywhere,BlueprintReadWrite)\n\tFMyInfo Info;\n\t\n\tUPROPERTY(EditAnywhere,BlueprintReadWrite)\n\tTArray&lt;FMyInfo> Array;\n&#125;;\n\n/**\n * \n */\nUCLASS()\nclass UE_ADVANCE_API UStructToJson : public UBlueprintFunctionLibrary\n&#123;\n\tGENERATED_BODY()\n\n\tUFUNCTION(BlueprintCallable,Category=cBao)\n\tstatic FString StructToString(const FMyStruct&amp; s1);\n\n&#125;;\n\n.cpp文件\n// Fill out your copyright notice in the Description page of Project Settings.\n\n\n#include \"StructToJson.h\"\n\nFString UStructToJson::StructToString(const FMyStruct&amp; s1)\n&#123;\n\t\tFString JsonString;\n\t\t//UE中的Json工程模式\n\t\tTSharedPtr&lt;TJsonWriter&lt;TCHAR,TCondensedJsonPrintPolicy&lt;TCHAR>>> JsonWriter=TJsonWriterFactory&lt;TCHAR,TCondensedJsonPrintPolicy&lt;TCHAR>>::Create(&amp;JsonString);\n\t\tJsonWriter->WriteObjectStart();\n\t\t&#123;\n\t\t\tJsonWriter->WriteValue(TEXT(\"Name\"),s1.Name);\n\t\t\tJsonWriter->WriteValue(TEXT(\"Age\"),s1.Age);\n\t\t\tJsonWriter->WriteValue(TEXT(\"Gender\"),s1.Gender);\n\t\t\tJsonWriter->WriteValue(TEXT(\"Weight\"),s1.Weight);\n\t\t\tJsonWriter->WriteObjectStart(TEXT(\"Info\"));\n\t\t\t&#123;\n\t\t\t\tJsonWriter->WriteValue(TEXT(\"Name\"),s1.Info.Name);\n\t\t\t\tJsonWriter->WriteValue(TEXT(\"Age\"),s1.Info.Age);\n\t\t\t&#125;\n\t\t\tJsonWriter->WriteObjectEnd();\n\t\t\tJsonWriter->WriteArrayStart(TEXT(\"Array\"));\n\t\t\t&#123;\n\t\t\t\tfor (auto &amp; s:s1.Array)\n\t\t\t\t&#123;\n\t\t\t\t\tJsonWriter->WriteObjectStart();\n\t\t\t\t\t&#123;\n\t\t\t\t\t\tJsonWriter->WriteValue(TEXT(\"Name\"),s.Name);\n\t\t\t\t\t\tJsonWriter->WriteValue(TEXT(\"Age\"),s.Age);\n\t\t\t\t\t&#125;\n\t\t\t\t\tJsonWriter->WriteObjectEnd();\n\t\t\t\t&#125;\n\t\t\t&#125;\n\t\t\tJsonWriter->WriteArrayEnd();\n\t\t&#125;\n\t\tJsonWriter->WriteObjectEnd();\n\t\tJsonWriter->Close();\n\t\treturn JsonString;\n&#125;\n\n蓝图中配置输出\n&#123;\"Name\":\"cBao\",\"Age\":24,\"Gender\":true,\"Weight\":2222,\"Info\":&#123;\"Name\":\"ccc\",\"Age\":32324&#125;,\"Array\":[&#123;\"Name\":\"cdd\",\"Age\":22131&#125;,&#123;\"Name\":\"dsaf\",\"Age\":232&#125;]&#125;\n\nUE5中将Json转换成结构体示例\n.h文件\n//FString反序列化成结构体\nUFUNCTION(BlueprintCallable,Category=cBao)\nstatic bool StructFromFString(const FString&amp; s1,FMyStruct&amp; MyStruct);\n.cpp文件\nbool UStructToJson::StructFromFString(const FString&amp; s1, FMyStruct&amp; MyStruct)\n&#123;\n\tTSharedRef&lt;TJsonReader&lt;>> JsonReader=TJsonReaderFactory&lt;>::Create(s1);\n\tTSharedPtr&lt;FJsonObject> ReadRoot;\n\n\tif (FJsonSerializer::Deserialize(JsonReader,ReadRoot))\n\t&#123;\n\t\t//获得String数据\n\t\tMyStruct.Name=ReadRoot->GetStringField(TEXT(\"Name\"));\n\t\t\n\t\t//获得int数据\n\t\tMyStruct.Age=ReadRoot->GetIntegerField(TEXT(\"Age\"));\n\t\t\n\t\t//获得bool数据\n\t\tMyStruct.Gender=ReadRoot->GetBoolField(TEXT(\"Gender\"));\n\t\t\n\t\t//获得浮点数据\n\t\tMyStruct.Weight=ReadRoot->GetNumberField(TEXT(\"Weight\"));\n\t\t\n\t\t//获得对象数据\n\t\tTSharedPtr&lt;FJsonObject> TestRoot=ReadRoot->GetObjectField(TEXT(\"Info\"));\n\t\t&#123;\n\t\t\tMyStruct.Info.Name=TestRoot->GetStringField(TEXT(\"Name\"));\n\t\t\tMyStruct.Info.Age=TestRoot->GetIntegerField(TEXT(\"Age\"));\n\t\t&#125;\n\n\t\t//获得数组数据\n\t\tTArray&lt;TSharedPtr&lt;FJsonValue>>TempArray=ReadRoot->GetArrayField(TEXT(\"Array\"));\n\t\tfor (auto &amp;i:TempArray)\n\t\t&#123;\n\t\t\tTSharedPtr&lt;FJsonObject> JsonObj = i->AsObject();\n\t\t\tFMyInfo TempInfo;\n\t\t\tTempInfo.Name=JsonObj->GetStringField(TEXT(\"Name\"));\n\t\t\tTempInfo.Age=JsonObj->GetIntegerField(TEXT(\"Age\"));\n\t\t\tMyStruct.Array.Add(TempInfo);\n\t\t&#125;\n\t\treturn true;\n\t&#125;\n\t\n\treturn false;\n&#125;\n\n","slug":"Json","date":"2022-08-02T06:17:49.000Z","categories_index":"Json","tags_index":"Json","author_index":"cBao"},{"id":"32edd7bc4a69fac72c5e2e1809026b07","title":"UE串口通信","content":"sdasfsa\nUE串口通信\n.h文件\n#pragma once\n\n#define FC_DTRDSR       0x01\n#define FC_RTSCTS       0x02\n#define FC_XONXOFF      0x04\n#define ASCII_BEL       0x07\n#define ASCII_BS        0x08\n#define ASCII_LF        0x0A\n#define ASCII_CR        0x0D\n#define ASCII_XON       0x11\n#define ASCII_XOFF      0x13\n\n\n#include \"CoreMinimal.h\"\n#include \"UObject/NoExportTypes.h\"\n#include \"Serial.generated.h\"\n\n/**\n * \n */\n\n // Forward declaration\ntypedef struct _OVERLAPPED OVERLAPPED;\n\nUENUM(BlueprintType, Category = \"UE4Duino\")\nenum class ELineEnd : uint8\n&#123;\n\trn\tUMETA(DisplayName = \"\\r\\n\"),\n\tn\tUMETA(DisplayName = \"\\n\"),\n\tr\tUMETA(DisplayName = \"\\r\"),\n\tnr\tUMETA(DisplayName = \"\\n\\r\")\n&#125;;\n\nUCLASS(BlueprintType, Category = \"UE4Duino\", meta = (Keywords = \"com arduino serial\"))\nclass INKPROJECTION_API USerial : public UObject\n&#123;\n\tGENERATED_BODY()\npublic:\n\t/** Determines the line ending used when writing lines to serial port with PrintLine. */\n\tUPROPERTY(BlueprintReadWrite, Category = \"UE4Duino | String\")\n\t\tELineEnd WriteLineEnd;\n\npublic:\n\tUSerial();\n\t~USerial();\n\n\t/**\n\t * Open a serial port and return the created Serial instance.\n\t * Don't forget to close the port before exiting the game.\n\t *\n\t * @param bOpened If the serial port was successfully opened.\n\t * @param Port The serial port to open.\n\t * @param BaudRate BaudRate to open the serial port with.\n\t * @return A Serial instance to work with the opened port.\n\t */\n\tUFUNCTION(BlueprintCallable, meta = (DisplayName = \"Open Serial Port\"), Category = \"UE4Duino\", meta = (Keywords = \"com arduino serial start\"))\n\t\tstatic USerial* OpenComPort(bool&amp; bOpened, int32 Port = 1, int32 BaudRate = 9600);\n\n\t/**\n\t * Utility function to convert 4 bytes into an Integer. If the input array's length is not 4, returns 0.\n\t *\n\t * @param Bytes A byte array with 4 values representing the integer in little-endian format.\n\t * @return The final integer value or 0 for an invalid array.\n\t */\n\tUFUNCTION(BlueprintPure, meta = (DisplayName = \"Bytes to Int\"), Category = \"UE4Duino\", meta = (Keywords = \"cast concatenate group bit bitwise\"))\n\t\tstatic int32 BytesToInt(TArray&lt;uint8> Bytes);\n\n\t/**\n\t * Utility function to get the 4 bytes that make an integer.\n\t *\n\t * @param Int The integer value to be converted.\n\t * @return A byte array containing the 4 bytes that make the integer, starting from the least significant one (little endian).\n\t */\n\tUFUNCTION(BlueprintPure, meta = (DisplayName = \"Int to Bytes\"), Category = \"UE4Duino\", meta = (Keywords = \"cast separate bit bitwise\"))\n\t\tstatic TArray&lt;uint8> IntToBytes(const int32&amp; Int);\n\n\t/**\n\t * Utility function to convert 4 bytes into a float. If the input array's length is not 4, returns 0.0.\n\t *\n\t * @param Bytes A byte array with 4 values representing the float in IEEE 754 standard format.\n\t * @return The final float value or 0.0 for an invalid array.\n\t */\n\tUFUNCTION(BlueprintPure, meta = (DisplayName = \"Bytes to Float\"), Category = \"UE4Duino\", meta = (Keywords = \"cast concatenate group bit bitwise\"))\n\t\tstatic float BytesToFloat(TArray&lt;uint8> Bytes);\n\n\t/**\n\t * Utility function to get the 4 bytes that make a float.\n\t *\n\t * @param Float The float value to be converted.\n\t * @return A byte array containing the 4 bytes that make the float, in IEEE 754 standard format.\n\t */\n\tUFUNCTION(BlueprintPure, meta = (DisplayName = \"Float to Bytes\"), Category = \"UE4Duino\", meta = (Keywords = \"cast separate bit bitwise\"))\n\t\tstatic TArray&lt;uint8> FloatToBytes(const float&amp; Float);\n\n\t/**\n\t * Open a serial port. Don't forget to close the port before exiting the game.\n\t * If this Serial instance has already an opened port,\n\t * return false and doesn't change the opened port number.\n\t *\n\t * @param Port The serial port to open.\n\t * @param BaudRate BaudRate to open the serial port with.\n\t * @return If the serial port was successfully opened.\n\t */\n\tUFUNCTION(BlueprintCallable, meta = (DisplayName = \"Open Port\"), Category = \"UE4Duino\", meta = (Keywords = \"com start init\"))\n\t\tbool Open(int32 Port = 2, int32 BaudRate = 9600);\n\t/**\n\t * Close and end the communication with the serial port. If not open, do nothing.\n\t */\n\tUFUNCTION(BlueprintCallable, meta = (DisplayName = \"Close Port\"), Category = \"UE4Duino\", meta = (Keywords = \"com end finish release\"))\n\t\tvoid Close();\n\n\t/**\n\t * Will read characters from Serial port until \\0 (null char) is found or there are no\n\t * characters left to read.\n\t *\n\t * @param bSuccess If there was anything to read.\n\t * @return The read string\n\t */\n\tUFUNCTION(BlueprintCallable, meta = (DisplayName = \"Read String\", keywords = \"get read receive string words text characters\"), Category = \"UE4Duino\")\n\t\tFString ReadString(bool&amp; bSuccess);\n\t/**\n\t * Will read characters from Serial port until \\r\\n (Arduino println line end) is found.\n\t *\n\t * @param bSuccess If there was anything to read.\n\t * @return The read string\n\t */\n\tUFUNCTION(BlueprintCallable, meta = (DisplayName = \"Read Line\", keywords = \"get read receive string words text characters\"), Category = \"UE4Duino\")\n\t\tFString Readln(bool&amp; bSuccess);\n\t/**\n\t * Reads the string until a specific char is met.\n\t * The Terminator char won't be included in the result string.\n\t */\n\t //UFUNCTION(BlueprintCallable, meta = (DisplayName = \"Read String Until\", keywords = \"get read receive string words text characters\"), Category = \"UE4Duino\")\n\tFString ReadStringUntil(bool&amp; bSuccess, uint8 Terminator);\n\t/**\n\t * Reads a float from the serial port (sent as 4 bytes).\n\t * @param bSuccess True if there were 4 bytes to read.\n\t * @return The read value\n\t */\n\tUFUNCTION(BlueprintCallable, meta = (DisplayName = \"Read a Float\", keywords = \"get read receive\"), Category = \"UE4Duino\")\n\t\tfloat ReadFloat(bool&amp; bSuccess);\n\t/**\n\t * Reads an integer from the serial port (sent as 4 bytes).\n\t * @param bSuccess True if there were 4 bytes to read.\n\t * @return The read value\n\t */\n\tUFUNCTION(BlueprintCallable, meta = (DisplayName = \"Read an Int\", keywords = \"get read receive integer\"), Category = \"UE4Duino\")\n\t\tint32 ReadInt(bool&amp; bSuccess);\n\t/**\n\t * Reads a byte from the serial port.\n\t * @param bSuccess True if there were 4 bytes to read.\n\t * @return The read value\n\t */\n\tUFUNCTION(BlueprintCallable, meta = (DisplayName = \"Read a Byte\", keywords = \"get read receive\"), Category = \"UE4Duino\")\n\t\tuint8 ReadByte(bool&amp; bSuccess);\n\t/**\n\t * Reads up to Limit bytes from the serial port. If there are less than Limit,\n\t * reads all of them and return True.\n\t * @param bSuccess True if there was at least 1 byte to read.\n\t * @return An array containing the read bytes\n\t */\n\tUFUNCTION(BlueprintCallable, meta = (DisplayName = \"Read Bytes\", keywords = \"get read receive\"), Category = \"UE4Duino\")\n\t\tTArray&lt;uint8> ReadBytes(int32 Limit = 256);\n\n\t/**\n\t * Writes a string without newline to the serial port.\n\t * @param String The string to be sent to the serial port.\n\t * @return True if the string was sent.\n\t */\n\tUFUNCTION(BlueprintCallable, meta = (DisplayName = \"Print\", keywords = \"send write string words text characters\"), Category = \"UE4Duino\")\n\t\tbool Print(FString String);\n\t/**\n\t * Writes a string with newline (\\n) appended at the end to the serial port.\n\t * @param String The string to be sent to the serial port.\n\t * @return True if the string was sent.\n\t */\n\tUFUNCTION(BlueprintCallable, meta = (DisplayName = \"Print Line\", keywords = \"send write string words text characters\"), Category = \"UE4Duino\")\n\t\tbool Println(FString String);\n\t/**\n\t * Writes a float value to the serial port as 4 bytes.\n\t * @param Value The value to be sent to the serial port.\n\t * @return True if the bytes were sent.\n\t */\n\tUFUNCTION(BlueprintCallable, meta = (DisplayName = \"Write a Float\", keywords = \"send\"), Category = \"UE4Duino\")\n\t\tbool WriteFloat(float Value);\n\t/**\n\t * Writes an integer value to the serial port as 4 bytes.\n\t * @param Value The value to be sent to the serial port.\n\t * @return True if the bytes were sent.\n\t */\n\tUFUNCTION(BlueprintCallable, meta = (DisplayName = \"Write an Int\", keywords = \"integer send\"), Category = \"UE4Duino\")\n\t\tbool WriteInt(int32 Value);\n\t/**\n\t * Writes a byte value to the serial port.\n\t * @param Value The value to be sent to the serial port.\n\t * @return True if the byte was sent.\n\t */\n\tUFUNCTION(BlueprintCallable, meta = (DisplayName = \"Write a Byte\", keywords = \"send\"), Category = \"UE4Duino\")\n\t\tbool WriteByte(uint8 Value);\n\t/**\n\t * Writes a byte array as a sequence of bytes to the serial port.\n\t * @param Buffer The byte array to be sent to the serial port.\n\t * @return True if the bytes were sent.\n\t */\n\tUFUNCTION(BlueprintCallable, meta = (DisplayName = \"Write Bytes\", keywords = \"send\"), Category = \"UE4Duino\")\n\t\tbool WriteBytes(TArray&lt;uint8> Buffer);\n\n\t/** Clean the serial port by reading everything left to be read. */\n\tUFUNCTION(BlueprintCallable, meta = (DisplayName = \"Flush Port\"), Category = \"UE4Duino\")\n\t\tvoid Flush();\n\n\t/**\n\t * Check if the serial port is open.\n\t * @return True if the serial port is open.\n\t */\n\tUFUNCTION(BlueprintPure, meta = (DisplayName = \"Is Port Open\"), Category = \"UE4Duino\")\n\t\tbool IsOpened() &#123; return m_hIDComDev != NULL; &#125;\n\n\t/**\n\t * Read the number of the serial port selected for this Serial instance.\n\t * @return The number of the serial port.\n\t */\n\tUFUNCTION(BlueprintPure, meta = (DisplayName = \"Get Port Number\"), Category = \"UE4Duino\")\n\t\tint32 GetPort() &#123; return m_Port; &#125;\n\n\t/**\n\t * Read the selected BaudRate for this Serial instance.\n\t * @return The baud rate.\n\t */\n\tUFUNCTION(BlueprintPure, meta = (DisplayName = \"Get Baud Rate\"), Category = \"UE4Duino\")\n\t\tint32 GetBaud() &#123; return m_Baud; &#125;\n\n\t/**\n\t * Converts a LineEnd enum value to String.\n\t * @param LineEnd LineEnd enum value.\n\t * @return The LineEnd value in string format.\n\t */\n\tUFUNCTION(BlueprintCallable, meta = (DisplayName = \"Line End to String\", keywords = \"cast convert\"), Category = \"UE4Duino\")\n\t\tFString LineEndToStr(ELineEnd LineEnd);\n\nprotected:\n\tvoid* m_hIDComDev;\n\n\t// These are pointers to be able to use OVERLAPPED with forward declaration\n\tOVERLAPPED* m_OverlappedRead;\n\tOVERLAPPED* m_OverlappedWrite;\n\n\tint32 m_Port;\n\tint32 m_Baud;\n&#125;;\n\n.cpp文件\n// Fill out your copyright notice in the Description page of Project Settings.\n\n\n#include \"Serial.h\"\n\n#include \"Windows/AllowWindowsPlatformTypes.h\"\n#include \"Windows/MinWindows.h\"\n#include \"Windows/HideWindowsPlatformTypes.h\"\n#include&lt;iostream>\n#include&lt;cmath>\n#include&lt;cstring>\n\nusing namespace std;\n#define BOOL2bool(B) B == 0 ? false : true\n\nUSerial* USerial::OpenComPort(bool&amp; bOpened, int32 Port, int32 BaudRate)\n&#123;\n\tUSerial* Serial = NewObject&lt;USerial>();\n\tbOpened = Serial->Open(Port, BaudRate);\n\treturn Serial;\n&#125;\n\nint32 USerial::BytesToInt(TArray&lt;uint8> Bytes)\n&#123;\n\tif (Bytes.Num() != 4)\n\t&#123;\n\t\treturn 0;\n\t&#125;\n\n\treturn *reinterpret_cast&lt;int32*>(Bytes.GetData());\n&#125;\n\nTArray&lt;uint8> USerial::IntToBytes(const int32&amp; Int)\n&#123;\n\tTArray&lt;uint8> Bytes;\n\tBytes.Append(reinterpret_cast&lt;const uint8*>(&amp;Int), 4);\n\treturn Bytes;\n&#125;\n\nfloat USerial::BytesToFloat(TArray&lt;uint8> Bytes)\n&#123;\n\tif (Bytes.Num() != 4)\n\t&#123;\n\t\treturn 0;\n\t&#125;\n\n\treturn *reinterpret_cast&lt;float*>(Bytes.GetData());\n&#125;\n\nTArray&lt;uint8> USerial::FloatToBytes(const float&amp; Float)\n&#123;\n\tTArray&lt;uint8> Bytes;\n\tBytes.Append(reinterpret_cast&lt;const uint8*>(&amp;Float), 4);\n\treturn Bytes;\n&#125;\n\nUSerial::USerial()\n\t: WriteLineEnd(ELineEnd::n)\n\t, m_hIDComDev(nullptr)\n\t, m_OverlappedRead(nullptr)\n\t, m_OverlappedWrite(nullptr)\n\t, m_Port(-1)\n\t, m_Baud(-1)\n&#123;\n\t// Allocate the OVERLAPPED structs\n\tm_OverlappedRead = new OVERLAPPED();\n\tm_OverlappedWrite = new OVERLAPPED();\n\n\tFMemory::Memset(m_OverlappedRead, 0, sizeof(OVERLAPPED));\n\tFMemory::Memset(m_OverlappedWrite, 0, sizeof(OVERLAPPED));\n&#125;\n\nUSerial::~USerial()\n&#123;\n\tClose();\n\n\t// Delete allocated OVERLAPPED structs\n\tdelete m_OverlappedRead;\n\tdelete m_OverlappedWrite;\n&#125;\n\nbool USerial::Open(int32 nPort, int32 nBaud)\n&#123;\n\tif (nPort &lt; 0)\n\t&#123;\n\t\tUE_LOG(LogTemp, Error, TEXT(\"Invalid port number: %d\"), nPort);\n\t\treturn false;\n\t&#125;\n\tif (m_hIDComDev)\n\t&#123;\n\t\tUE_LOG(LogTemp, Warning, TEXT(\"Trying to use opened Serial instance to open a new one. \"\n\t\t\t\"Current open instance port: %d | Port tried: %d\"), m_Port, nPort);\n\t\treturn false;\n\t&#125;\n\n\tFString szPort;\n\tif (nPort &lt; 10)\n\t\tszPort = FString::Printf(TEXT(\"COM%d\"), nPort);\n\telse\n\t\tszPort = FString::Printf(TEXT(\"\\\\\\\\.\\\\COM%d\"), nPort);\n\tDCB dcb;\n\n\tm_hIDComDev = CreateFile(*szPort, GENERIC_READ | GENERIC_WRITE, 0, NULL, OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL | FILE_FLAG_OVERLAPPED, NULL);\n\tif (m_hIDComDev == NULL)\n\t&#123;\n\t\tunsigned long dwError = GetLastError();\n\t\tUE_LOG(LogTemp, Error, TEXT(\"Failed to open port COM%d (%s). Error: %08X\"), nPort, *szPort, dwError);\n\t\treturn false;\n\t&#125;\n\n\tFMemory::Memset(m_OverlappedRead, 0, sizeof(OVERLAPPED));\n\tFMemory::Memset(m_OverlappedWrite, 0, sizeof(OVERLAPPED));\n\n\tCOMMTIMEOUTS CommTimeOuts;\n\t//CommTimeOuts.ReadIntervalTimeout = 10;\n\tCommTimeOuts.ReadIntervalTimeout = 0xFFFFFFFF;\n\tCommTimeOuts.ReadTotalTimeoutMultiplier = 0;\n\tCommTimeOuts.ReadTotalTimeoutConstant = 0;\n\tCommTimeOuts.WriteTotalTimeoutMultiplier = 0;\n\tCommTimeOuts.WriteTotalTimeoutConstant = 10;\n\tSetCommTimeouts(m_hIDComDev, &amp;CommTimeOuts);\n\n\tm_OverlappedRead->hEvent = CreateEvent(NULL, true, false, NULL);\n\tm_OverlappedWrite->hEvent = CreateEvent(NULL, true, false, NULL);\n\n\tdcb.DCBlength = sizeof(DCB);\n\tGetCommState(m_hIDComDev, &amp;dcb);\n\tdcb.BaudRate = nBaud;\n\tdcb.ByteSize = 8;\n\n\tif (!SetCommState(m_hIDComDev, &amp;dcb) ||\n\t\t!SetupComm(m_hIDComDev, 10000, 10000) ||\n\t\tm_OverlappedRead->hEvent == NULL ||\n\t\tm_OverlappedWrite->hEvent == NULL)\n\t&#123;\n\t\tunsigned long dwError = GetLastError();\n\t\tif (m_OverlappedRead->hEvent != NULL) CloseHandle(m_OverlappedRead->hEvent);\n\t\tif (m_OverlappedWrite->hEvent != NULL) CloseHandle(m_OverlappedWrite->hEvent);\n\t\tCloseHandle(m_hIDComDev);\n\t\tm_hIDComDev = NULL;\n\t\tUE_LOG(LogTemp, Error, TEXT(\"Failed to setup port COM%d. Error: %08X\"), nPort, dwError);\n\t\treturn false;\n\t&#125;\n\n\t//FPlatformProcess::Sleep(0.05f);\n\tAddToRoot();\n\tm_Port = nPort;\n\tm_Baud = nBaud;\n\treturn true;\n&#125;\n\nvoid USerial::Close()\n&#123;\n\tif (!m_hIDComDev) return;\n\n\tif (m_OverlappedRead->hEvent != NULL) CloseHandle(m_OverlappedRead->hEvent);\n\tif (m_OverlappedWrite->hEvent != NULL) CloseHandle(m_OverlappedWrite->hEvent);\n\tCloseHandle(m_hIDComDev);\n\tm_hIDComDev = NULL;\n\n\tRemoveFromRoot();\n&#125;\n\nFString USerial::ReadString(bool&amp; bSuccess)\n&#123;\n\treturn ReadStringUntil(bSuccess, '\\0');\n&#125;\n\nFString USerial::Readln(bool&amp; bSuccess)\n&#123;\n\treturn ReadStringUntil(bSuccess, '\\n');\n&#125;\n\nFString USerial::ReadStringUntil(bool&amp; bSuccess, uint8 Terminator)\n&#123;\n\tbSuccess = false;\n\tif (!m_hIDComDev) return TEXT(\"\");\n\n\tTArray&lt;uint8> Chars;\n\tuint8 Byte = 0x0;\n\tbool bReadStatus;\n\tunsigned long dwBytesRead, dwErrorFlags;\n\tCOMSTAT ComStat;\n\n\tClearCommError(m_hIDComDev, &amp;dwErrorFlags, &amp;ComStat);\n\tif (!ComStat.cbInQue) return TEXT(\"\");\n\n\tdo &#123;\n\t\tbReadStatus = BOOL2bool(ReadFile(\n\t\t\tm_hIDComDev,\n\t\t\t&amp;Byte,\n\t\t\t1,\n\t\t\t&amp;dwBytesRead,\n\t\t\tm_OverlappedRead));\n\n\t\tif (!bReadStatus)\n\t\t&#123;\n\t\t\tif (GetLastError() == ERROR_IO_PENDING)\n\t\t\t&#123;\n\t\t\t\tWaitForSingleObject(m_OverlappedRead->hEvent, 2000);\n\t\t\t&#125;\n\t\t\telse\n\t\t\t&#123;\n\t\t\t\tChars.Add(0x0);\n\t\t\t\tbreak;\n\t\t\t&#125;\n\t\t&#125;\n\n\t\tif (Byte == Terminator || dwBytesRead == 0)\n\t\t&#123;\n\t\t\t// when Terminator is \\n, we know we're expecting lines from Arduino. But those\n\t\t\t// are ended in \\r\\n. That means that if we found the line Terminator (\\n), our previous\n\t\t\t// character could be \\r. If it is, we remove that from the array.\n\t\t\tif (Chars.Num() > 0 &amp;&amp; Terminator == '\\n' &amp;&amp; Chars.Top() == '\\r') Chars.Pop(false);\n\n\t\t\tChars.Add(0x0);\n\t\t\tbreak;\n\t\t&#125;\n\t\telse Chars.Add(Byte);\n\n\t&#125; while (Byte != 0x0 &amp;&amp; Byte != Terminator);\n\n\tbSuccess = true;\n\tauto Convert = FUTF8ToTCHAR((ANSICHAR*)Chars.GetData());\n\treturn FString(Convert.Get());\n&#125;\n\nfloat USerial::ReadFloat(bool&amp; bSuccess)\n&#123;\n\tbSuccess = false;\n\n\tTArray&lt;uint8> Bytes = ReadBytes(4);\n\tif (Bytes.Num() == 0) return 0;\n\n\tbSuccess = true;\n\treturn *(reinterpret_cast&lt;float*>(Bytes.GetData()));\n&#125;\n\nint32 USerial::ReadInt(bool&amp; bSuccess)\n&#123;\n\tbSuccess = false;\n\n\tTArray&lt;uint8> Bytes = ReadBytes(4);\n\tif (Bytes.Num() == 0) return 0;\n\n\tbSuccess = true;\n\treturn *(reinterpret_cast&lt;int32*>(Bytes.GetData()));\n&#125;\n\nuint8 USerial::ReadByte(bool&amp; bSuccess)\n&#123;\n\tbSuccess = false;\n\tif (!m_hIDComDev) return 0x0;\n\n\tuint8 Byte = 0x0;\n\tbool bReadStatus;\n\tunsigned long dwBytesRead, dwErrorFlags;\n\tCOMSTAT ComStat;\n\n\tClearCommError(m_hIDComDev, &amp;dwErrorFlags, &amp;ComStat);\n\tif (!ComStat.cbInQue) return 0x0;\n\n\tbReadStatus = BOOL2bool(ReadFile(\n\t\tm_hIDComDev,\n\t\t&amp;Byte,\n\t\t1,\n\t\t&amp;dwBytesRead,\n\t\tm_OverlappedRead));\n\n\tif (!bReadStatus)\n\t&#123;\n\t\tif (GetLastError() == ERROR_IO_PENDING)\n\t\t&#123;\n\t\t\tWaitForSingleObject(m_OverlappedRead->hEvent, 2000);\n\t\t&#125;\n\t\telse\n\t\t&#123;\n\t\t\treturn 0x0;\n\t\t&#125;\n\t&#125;\n\n\tbSuccess = dwBytesRead > 0;\n\treturn Byte;\n&#125;\n\nTArray&lt;uint8> USerial::ReadBytes(int32 Limit)\n&#123;\n\tTArray&lt;uint8> Data;\n\n\tif (!m_hIDComDev) return Data;\n\n\tData.Empty(Limit);\n\n\tuint8* Buffer = new uint8[Limit];\n\tbool bReadStatus;\n\tunsigned long dwBytesRead, dwErrorFlags;\n\tCOMSTAT ComStat;\n\n\tClearCommError(m_hIDComDev, &amp;dwErrorFlags, &amp;ComStat);\n\tif (!ComStat.cbInQue) return Data;\n\n\tbReadStatus = BOOL2bool(ReadFile(\n\t\tm_hIDComDev,\n\t\tBuffer,\n\t\tLimit,\n\t\t&amp;dwBytesRead,\n\t\tm_OverlappedRead));\n\n\tif (!bReadStatus)\n\t&#123;\n\t\tif (GetLastError() == ERROR_IO_PENDING)\n\t\t&#123;\n\t\t\tWaitForSingleObject(m_OverlappedRead->hEvent, 2000);\n\t\t&#125;\n\t\telse\n\t\t&#123;\n\t\t\treturn Data;\n\t\t&#125;\n\t&#125;\n\n\tData.Append(Buffer, dwBytesRead);\n\treturn Data;\n&#125;\n\nbool USerial::Print(FString String)\n&#123;\n\tauto Convert = FTCHARToUTF8(*String);\n\tTArray&lt;uint8> Data;\n\tData.Append((uint8*)Convert.Get(), Convert.Length());\n\n\treturn WriteBytes(Data);\n&#125;\n\nbool USerial::Println(FString String)\n&#123;\n\treturn Print(String + LineEndToStr(WriteLineEnd));\n&#125;\n\nbool USerial::WriteFloat(float Value)\n&#123;\n\tTArray&lt;uint8> Buffer;\n\tBuffer.Append(reinterpret_cast&lt;uint8*>(&amp;Value), 4);\n\treturn WriteBytes(Buffer);\n&#125;\n\nbool USerial::WriteInt(int32 Value)\n&#123;\n\tTArray&lt;uint8> Buffer;\n\tBuffer.Append(reinterpret_cast&lt;uint8*>(&amp;Value), 4);\n\treturn WriteBytes(Buffer);\n&#125;\n\nbool USerial::WriteByte(uint8 Value)\n&#123;\n\tTArray&lt;uint8> Buffer(&#123; Value &#125;);\n\treturn WriteBytes(Buffer);\n&#125;\n\nbool USerial::WriteBytes(TArray&lt;uint8> Buffer)\n&#123;\n\tif (!m_hIDComDev) false;\n\n\tbool bWriteStat;\n\tunsigned long dwBytesWritten;\n\n\tbWriteStat = BOOL2bool(WriteFile(m_hIDComDev, Buffer.GetData(), Buffer.Num(), &amp;dwBytesWritten, m_OverlappedWrite));\n\tif (!bWriteStat &amp;&amp; (GetLastError() == ERROR_IO_PENDING))\n\t&#123;\n\t\tif (WaitForSingleObject(m_OverlappedWrite->hEvent, 1000))\n\t\t&#123;\n\t\t\tdwBytesWritten = 0;\n\t\t\treturn false;\n\t\t&#125;\n\t\telse\n\t\t&#123;\n\t\t\tGetOverlappedResult(m_hIDComDev, m_OverlappedWrite, &amp;dwBytesWritten, false);\n\t\t\tm_OverlappedWrite->Offset += dwBytesWritten;\n\t\t\treturn true;\n\t\t&#125;\n\t&#125;\n\n\treturn true;\n&#125;\n\nvoid USerial::Flush()\n&#123;\n\tif (!m_hIDComDev) return;\n\n\tTArray&lt;uint8> Data;\n\n\tdo &#123;\n\t\tData = ReadBytes(8192);\n\t&#125; while (Data.Num() > 0);\n&#125;\n\nFString USerial::LineEndToStr(ELineEnd LineEnd)\n&#123;\n\tswitch (LineEnd)\n\t&#123;\n\tcase ELineEnd::rn:\n\t\treturn TEXT(\"\\r\\n\");\n\tcase ELineEnd::n:\n\t\treturn TEXT(\"\\n\");\n\tcase ELineEnd::r:\n\t\treturn TEXT(\"\\r\");\n\tcase ELineEnd::nr:\n\t\treturn TEXT(\"\\n\\r\");\n\tdefault:\n\t\treturn TEXT(\"null\");\n\t&#125;\n&#125;\n蓝图使用\n\n蓝图代码连接https://blueprintue.com/blueprint/ss-s-s83/\n\n\n","slug":"UE串口通信","date":"2022-07-22T08:14:36.000Z","categories_index":"UnrealEngine","tags_index":"串口通信","author_index":"cBao"},{"id":"650e8b54c427468049a9eded7ddf3373","title":"C++仿函数和代理","content":"仿函数\n\n\n\n\n\n提示\n需要头文件#include &lt; functional &gt;\n\n仿函数与普通函数#include &lt;iostream>\n#include &lt;functional>\n\nint Test(int A, int B)\n&#123;\n\tstd::cout&lt;&lt;A+B&lt;&lt;std::endl;\n\treturn A+B;\n&#125;\n\nint main()\n&#123;\n\tstd::function&lt;int(int,int)> Func_Test=Test;\n\tFunc_Test(2,3);\n&#125;\n\n\nint(int,int)：返回类型(形参列表)\n\n仿函数与Lambda#include &lt;iostream>\n#include &lt;functional>\n\nauto Lam=[&amp;](int A,int B)\n&#123;\n\tstd::cout&lt;&lt;A+B&lt;&lt;std::endl;\n\treturn A+B;\n&#125;;\n\nint main()\n&#123;\n\tstd::function&lt;int(int,int)> Fun_Test=Lam;\n\tFun_Test(3,4);\n&#125;\n\n","slug":"C++仿函数和代理","date":"2022-07-17T07:19:09.000Z","categories_index":"C++","tags_index":"仿函数和代理","author_index":"cBao"},{"id":"8655ec3b78f346469051ac63e86fd947","title":"C存储类","content":"C存储类\n\n\n\n\n\n\n注意\n存储类定义 C 程序中变量/函数的范围（可见性）和生命周期。这些说明符放置在它们所修饰的类型之前\nC中四种存储类：\n\nauto\nregister\nstatic\nextern\n\n\n\nauto 存储类auto 存储类是所有局部变量默认的存储类\n//注意是在花括号里的局部变量,Age1和Age2是相同存储类\n&#123;\n\tint Age1\n\tauto int Age2;\n&#125;\n\n\n\n\n\n\n\n\n注意\nauto只能修饰在函数内的局部变量\n\n\nregister 存储类register 存储类用于定义存储在寄存器中而不是 RAM 中的局部变量\n&#123;\n\tregister int Miles;\n&#125;\n\n\n\n\n\n\n\n\n注意\n寄存器只用于需要快速访问的变量，比如计数器\n不能对register修饰的变量使用取地址符”&amp;”，因为不在RAM中，所以没有内存地址\n定义 ‘register’ 并不意味着变量将被存储在寄存器中，它意味着变量可能存储在寄存器中，这取决于硬件和实现的限制\n\n\nstatic 存储类作用于局部变量：\n\nstatic 存储类指示编译器在程序的生命周期内保持局部变量的存在\n使用 static 修饰局部变量可以在函数调用之间保持局部变量的值\n\n作用于全局变量：\n\n当 static 修饰全局变量时，会使变量的作用域限制在声明它的文件内\n全局声明的一个 static 变量或方法可以被任何函数或方法调用，只要这些方法出现在跟 static 变量或方法同一个文件\n\nextern 存储类\nextern 存储类用于提供一个全局变量的引用，全局变量对所有的程序文件都是可见的\n对于无法初始化的变量，会把变量名指向一个之前定义过的存储位置\nextern 修饰符通常用于当有两个或多个文件共享相同的全局变量或函数的时候\n\n","slug":"C存储类","date":"2022-07-10T08:12:03.000Z","categories_index":"C","tags_index":"C","author_index":"cBao"},{"id":"91073ca00ced3eaf093ce066e8170e85","title":"C数据类型","content":"C数据类型\n","slug":"C数据类型","date":"2022-07-09T07:51:09.000Z","categories_index":"C","tags_index":"C","author_index":"cBao"},{"id":"8b894e11fa6b8b7cfc1195c4546ad7f2","title":"C基本语法","content":"C中两种注释方法\n双斜杠”//“：适合单行注释\n//本行是注释代码\n/**/“：适合多行注释\n/*\n多行注释\n多行注释\n*/\n\n\n\n\n\n\n\n提示\n在Visual Studio中可用\n快捷键Ctrl + K + C快速注释\nCtrl + K + U快速取消注释\n\n分号 ;在C程序中分号”;“（英文输入法下）代表一条语句的结束\n标识符C语言中用来命名变量和函数名称等统称为标识符，C语言是区分大小写的\n\n\n\n\n\n\n\n注意\nC中标识符必须以字母 A-Z 或 a-z 或下划线 _ 开始，不能以数字作为开头，不允许出现标点字符，且不能与下表中关键字同名\n\n关键字\n\n\n关键字\n说明\n\n\n\nauto\n声明自动变量\n\n\nbreak\n跳出当前循环\n\n\ncase\n开关语句分支\n\n\nchar\n声明字符型变量或函数返回值类型\n\n\nconst\n定义常量，如果一个变量被 const 修饰，那么它的值就不能再被改变\n\n\ncontinue\n结束当前循环，开始下一轮循环\n\n\ndefault\n开关语句中的”其它”分支\n\n\ndo\n循环语句的循环体\n\n\ndouble\n声明双精度浮点型变量或函数返回值类型\n\n\nelse\n条件语句否定分支（与 if 连用）\n\n\nenum\n声明枚举类型\n\n\nextern\n声明变量或函数是在其它文件或本文件的其他位置定义\n\n\nfloat\n声明浮点型变量或函数返回值类型\n\n\nfor\n一种循环语句\n\n\ngoto\n无条件跳转语句\n\n\nif\n条件语句\n\n\nint\n声明整型变量或函数\n\n\nlong\n声明长整型变量或函数返回值类型\n\n\nregister\n声明寄存器变量\n\n\nreturn\n子程序返回语句（可以带参数，也可不带参数）\n\n\nshort\n声明短整型变量或函数\n\n\nsigned\n声明有符号类型变量或函数\n\n\nsizeof\n计算数据类型或变量长度（即所占字节数）\n\n\nstatic\n声明静态变量\n\n\nstruct\n声明结构体类型\n\n\nswitch\n用于开关语句\n\n\ntypedef\n用以给数据类型取别名\n\n\nunsigned\n声明无符号类型变量或函数\n\n\nunion\n声明共用体类型\n\n\nvoid\n声明函数无返回值或无参数，声明无类型指针\n\n\nvolatile\n说明变量在程序执行中可被隐含地改变\n\n\nwhile\n循环语句的循环条件\n\n\n\n\n\n\n\n\n\n特别注意\n关键字不能作为常量名、变量名或其他标识符名称\n\n\n\n","slug":"C基本语法","date":"2022-07-08T15:10:17.000Z","categories_index":"C","tags_index":"C","author_index":"cBao"},{"id":"f58daaa95359f10d1d47b72330587f5d","title":"VisualStudio常用操作","content":"Visual Studio中常用的快捷键\n\n\n快捷键\n功能\n\n\n\nCtrl + K, O\n在头文件与源文件之间切换\n\n\nCtrl + K, C\n注释选择行\n\n\nCtrl + K, U\n取消选择行的注释\n\n\nCtrl + K, D\n对齐所有代码\n\n\nCtrl+Shift+U\n全部变为大写\n\n\nCtrl+U\n全部变为小写\n\n\nAlt+鼠标左按钮\n选择矩形文本\n\n\nCtrl+F\n在当前文件中查找\n\n\nCtrl+Shift+F\n在当前的解决方案中查找\n\n\n","slug":"Visual Studio常用操作","date":"2022-07-07T03:18:50.000Z","categories_index":"IDE","tags_index":"Visual Studio","author_index":"cBao"}]