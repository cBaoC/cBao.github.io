[{"id":"297e7259160304ea1919564f5d876933","title":"C语言字符输入/输出","content":"单字符I/Ogetchar()和putchar()\ngetchar()和putchar()每次只处理一个字符\n#include &lt;iostream>\n\nint main()\n&#123;\n\tchar c;\n\twhile((c=getchar())!='#')//当遇到'#'时结束打印\n\t&#123;\n\t\tputchar(c);\n\t&#125;\n\treturn 0;\n&#125;\n\n缓冲输入和无缓冲输入\n\n\n\n\n\n\n提示\n​    完全缓存I/O：当缓冲区被填满时才刷新缓冲区（内容发送至目的地），通常出现在文件输入中。（缓冲区的大小取决于系统，通常为512字节和4096字节）\n​    行缓冲I/O：当出现换行符时刷新缓冲区。（键盘输入通常是行缓冲输入，按下Enter键后才刷新缓冲区）\n\n\n无缓冲输入#include &lt;iostream>\n#include &lt;conio.h>//提供无缓冲输入的头文件\n\nint main()\n&#123;\n\tchar c;\n    //有回显的无缓冲输入的函数_getche()\n    //无回显的无缓冲输入函数_getch()\n\twhile((c=_getche())!='c')\n\t&#123;\n\t\tputchar(c);\n\t&#125;\n    \n\treturn 0;\n&#125;\n\n\n\n\n\n\n\n提示\n​    检查换行符的方法\nif(ch=='\\n')//用于检查换行符\n\n\n\n文件结尾\n操作系统可以使用内嵌的Ctrl+Z标记文件结尾\n记录文件大小用来读取文件内容\n\n\n\n\n\n\n\n提示\n​    在C语言中，用getchar()读取文件和scanf()函数检测到文件结尾时会返回一个特殊的值（EOF）。\n​    EOF定义在stdio.h文件中\n#define EOF(-1)\n\n#include &lt;iostream>\n\nint main()\n&#123;\n    //这里是int\n\tint ch;\n\twhile((ch=getchar())!=EOF)\n\t&#123;\n\t\tputchar(ch);\n\t&#125;\n\treturn 0;\n&#125;\n\n\n\n","slug":"C语言字符输入输出","date":"2023-03-04T08:23:17.000Z","categories_index":"C","tags_index":"C","author_index":"cBao"},{"id":"74d1a6628a5df30cefe103fae4a073dc","title":"UEC++基础","content":"五个最常见的基类UObjectUObject类提供的功能\nGarbage collection 垃圾回收(GC)\n原生C++中的内存管理由程序员完成\n虚幻引擎提供两种垃圾回收的解决方案\n继承自UObject类，同时指向UObject类实例对象的指针成员变量用 UPROPERTY宏进行标记 ，虚幻会自动地进行对象的生命周期管理\n采用智能指针：只有 非UObject类型 ，才能使用智能指针进行自动内存释放\n\n\n\n\nReference updating 引用自动更新\nReflection 反射\n反射是一套可以在 运行时获取 一个类的成员变量和成员函数的一种机制\n\n\nSerialization序列化\n将对象保存到磁盘，下次运行时完好无损的加载\n\n\nAutomatic updating of default property changes 自动检测默认变量的更改\nAutomatic property initialzation 自动变量初始化\nAutomatic editor integration 和虚幻引擎编辑器的自动交互\n将变量暴露到虚幻引擎的Edit面板进行编辑\n\n\nType information available at runtime 运行时类型识别\nNetwork replication 网络复制\n\n\n\n\n\n\n\n\n注意\n\n当需要上述这些功能时，类该继承自UObject类\nUObject类会在引擎加载阶段，创建一个Default Object默认对象\n构造函数并不是在游戏运行时候调用，即便只有一个UObject对象，构造函数也会被 调用两次\n构造函数调用时UWorld不一定存在。 GetWorld()返回值可能为空\n\n\n\n\n\nActorActor类的能力\nActor类能被 挂载组件\n\n\n\n\n\n\n\n\n注意\n\n当需要挂载组件时，才继承自Actor类\n\n\n\n灵魂与肉体: Pawn、Character和ControllerPawn\n一个可以被Controller操作的兵或卒\n\nCharacter\n继承自Pawn类，代表一个角色\n相比于Pawn类，Character类提供了一个特殊组件 Character Movement ，该组件提供了角色移动的功能\n\nController\nController操纵着Pawn和Character的行为（Pawn和Character是肉体，Controller是用来操控肉体的灵魂）\nController可以是 AI Controller  也可以是 Player Controller\n\n虚幻引擎类的命名规则\nF 纯C++类\nU 继承自UObject，但不继承自Actor\nA 继承自Actor\nS Slate控件相关类\nH HItResult相关类\n\n类对象类对象的产生\n如果类是一个纯C++类型(F开头)，通过new来产生对象\n\n如果类继承自UObject但不继承自Actor，通过NewObject函数来产生对象\nNewObject&lt;T&gt;();\n如果类继承自Actor，需要通过SpawnActor函数产生对象\nGetWorld()-&gt;SpawnActor&lt;AYourActorCLass&gt;();\n\n类对象的获取\n获取一个类对象的唯一方法，是通过某种方式传递到这个对象的指针或引用\n\n如果要获取场景中，某个Actor的实例，需要借助Actor迭代器:TActorIterator\nfor(TActorIterator&lt;AActor&gt; Iterator(GetWorld());Iterator;++Iterator)\n&#123;\n    \t&#x2F;&#x2F;*Iterator获取指向对象的指针\n&#125;\n\n类对象的销毁纯C++类\n当纯C++类实在函数体中创建，并且不是通过new来进行分配内存，不需要手动干涉释放，会随着函数调用结束后，随着函数栈空间一起被释放\n\n当纯C++类使用new来分配内存，除非手动删除(delete)，否则该内存永远不会被释放，产生内存泄漏\n\n当纯C++类使用new来分配内存，同时使用智能指针TSharedPtr/TSharedRef来进行管理，不应该手动干涉释放，智能指针会自动完成内存的释放\nTSharedPtr&lt;Test&gt; YourClassPtr&#x3D;MakeShareable(new YourClass());&#x2F;&#x2F;通过MakeShareable函数转化普通指针为智能指针\n\nUObject类\nUObject类采用自动垃圾回收机制（当一个类的成员变量包含指向UObject的对象，同时又带有UPROPERTY宏定义，该成员变量将会触发引用计数机制）\n\n\n\n\n\n\n\n提示\n        垃圾回收器会定期从根节点Root开始检查，当一个UObject没有被别的任何UObject引用，就会被垃圾回收\n​        可以通过AddToRoot函数来让一个UObject一直不被回收\n\n\nActor类\nActor类对象通过Destory函数请求销毁，使用该方式销毁是将Actor从所属世界中摧毁，但对象的内存回收依然由系统决定\n\n从C++到蓝图UPROPERTY宏\n可以将一个 UObject类的子类 成员变量注册到蓝图中\nUPROPERTY(BlueprintReadWrite,VisibleAnywhere,Category&#x3D;&quot;YourName&quot;)\n\nUFUNCTION宏\n可以将函数注册到蓝图中\nUFUNCTION(BlueprintCallable,Category&#x3D;&quot;YourName&quot;)\n\n\nBlueprintCallable：表示函数可以被蓝图调用\nBlueprintImplementableEvent：该成员函数由蓝图的子类实现，不应在C++中实现（编译错误）\nBlueprintNativeEvent：该成员函数提供一个C++的默认实现，同时也可以被蓝图重载，再C++中需要提供一个“函数名_Implement”为名字的函数实现\n\n\n\n引擎系统相关类FPaths类\n该类是用于处理路径相关的类\n具体路径类：如获取游戏根目录\n工具类：如判断一个文件是否存在\n路径转换类：如将相对路径转换为绝对路径\n\nConfig类的使用\n写配置\nGConfig.SetString((TEXT(&quot;MySection&quot;),TEXT(&quot;Name&quot;),TEXT(&quot;cBao&quot;),FPath::GameDir&#x2F;&quot;MyConfig.ini&quot;));\n\n\n第一个参数指定Section（区块）\n第二个参数配置Key\n第三个参数配置具体的值\n第四个参数是路径，没有会自动创建\n\n\n\n\n\n\n\n\n\n提示\n​        GConfig对各种类型的数据都有相应的函数，如SetInt，SetBool，SetFloiat等\n\n\n\n读配置\nFString Result;\nGConfig-&gt;GetString(TEXT(&quot;cBao&quot;),TEXT(&quot;Name&quot;),Result,FPaths::ProjectConfigDir()&#x2F;&quot;cBaoCsConfig.ini&quot;);\n\n","slug":"UEC++基础","date":"2023-02-02T06:19:47.000Z","categories_index":"UnrealEngine","tags_index":"UEC++","author_index":"cBao"},{"id":"2d7fcd3211374fac141da523879cb012","title":"Unity3D引擎","content":"场景中的对象\nGameObject类对象是Unity引擎提供作为场景中所有对象的根本\n\nUnity中脚本的基本规则\n创建规则\n不在VS中创建脚本\n可以放在Assets文件夹下的任意位置（建议同一文件夹下）\n类名和文件名必须一致，不然不能挂载（因为反射机制创建对象，会通过文件名去找Type） 重要\n不要使用中文命名\n没有特殊需求，不需要管命名空间\n创建的脚本默认继承MonoBehaviour\n\n\nMonoBehavior基类\n创建的脚本默认继承MonoBehaviour，继承该类才能挂载到GameObject上\n继承了MonoBehaviour的脚本不能new只能挂载！！！\n继承了MonoBehaviour的脚本不要写构造函数（也可以写，会自动调用），因为不能new，构造函数无意义\n继承了MonoBehaviour的脚本可以在一个对象上挂多个（没有添加DisallowMultipleComponent特性时）\n继承MonoBehaviour的类也可以再次被继承，遵循面向对象继承多态原则\n\n\n不继承MonoBehaviour的类\n不继承MonoBehaviour的类不能挂载到GameObject对象上\n不继承MonoBehaviour的类 想怎么写就怎么写 如果要使用 需要自己new实例化一个对象\n不继承MonoBehaviour的类 一般是单例模式的类（用于管理模块）或者数据结构类（用于存储数据）\n不继承MonoBehaviour的类 不用保留默认出现的几个函数\n\n\n\n在Unity中打印信息的两种方式\n没有继承MonoBehaviour类\n\n\n\nAPI\n\n\n\nDebug.Log(“…”);\n\n\nDebug.LogError(“出错”);\n\n\nDebug.LogWarning(“警告”);\n\n\n\n继承了MonoBehaviour类\n\n\n\nAPI\n\n\n\nprint(“…”);\n\n\n\n\n生命周期函数\n所有继承MonoBehaviour的脚本，最终都会挂载到GameObject游戏对象上\n\n生命周期函数就是该脚本对象依附的GameObject对象从出生到消亡的整个生命周期上\n\n会通过反射自动调用的一些特殊函数，是Unity自己调用的\n\n生命周期函数的访问修饰符一般为private和protected，因为不需要在外部自己调用生命周期函数\n\n生命周期函数并不是基类中的成员\n\n常用的生命周期函数（从上到下的执行先后）\n\n\n\nAPI\n描述\n\n\n\nAwake\n当脚本对象创建时，自动调用，类似构造函数，一个对象只会调用一次\n\n\nOnEnable\n依附的GameObject对象每次激活时调用\n\n\nStart\n当脚本对象创建后，第一次帧更新之前调用，一个对象只会调用一次（比Awake要晚）\n\n\nFixedUpdate\n物理帧更新，固定间隔时间执行，间隔时间可以设置（project Setting -&gt; Time）\n\n\nUpdate\n逻辑帧更新每帧执行\n\n\nLateUpdate\n每帧执行，于Update之后执行（一般用来处理摄像机位置更新（防止渲染出错））\n\n\nOnDisable\n依附的GameObject对象每次失活时调用\n\n\nOnDestroy\n对象销毁时调用，依附的GameObject对象被删除时\n\n\n\n\n生命周期函数支持继承多态\n\n\nInspector窗口可编辑的变量\nInspector显示的可编辑内容就是脚本的公共成员变量，默认情况下私有和保护的无法显示编辑\n加上强制序列化字段特性[SerializeField]，可以让私有的和保护的成员也可以被显示编辑\n在公共成员变量前加上[HideInInspector]，可以让公共成员变量在Inspector隐藏，默认是显示的\n大部分类型都能显示编辑\n自定义类型和Dictionary类型不能显示编辑\n\n\n加上序列化特性[System.Serializable]可以让自定义类型和结构体可以被显示编辑\n一些辅助特性\n分组：[Header(“分组说明”)]\n悬停注释：[Tooltip(“说明内容”)]\n间隔特性：[Space()]\n修饰数值的滑条范围Range：[Range(最小值,最大值)]\n多行显示字符串，默认不写参数显示3行：[Multiline()]\n滚动条显示字符串，默认不写参数超过3行显示滚动条：[TextArea(3,4)]最少显示3行，最多显示4行，超过4行显示滚动条\n为变量添加快捷方法：[ContextMenuItem(“显示按钮名”,”方法名”)]，方法名不能有参数\n为方法添加特性能够在Inspector中执行：[ContextMenu(“测试函数”)]\n\n\n注意\nInspector窗口中的变量关联的就是对象的成员变量，运行时改变它们就是在改变成员变量\n拖拽到GameObject对象后，再改变脚本中的变量默认值 界面上不会改变\n运行中修改的信息不会被保存\n\n\n\nMonoBehaviour中的重要内容\n重要成员\n\n获取依附的GameObject\nthis.gameObject;\n//gameObject与上面一样\n获取依附的GameObject位置信息\nthis.transform.position;//获得位置信息\nthis.transform.eulerAngles;//获得欧拉角\nthis.transform.lossyScale;//获得缩放大小\nthis.gameObject.transform;//该方法与以上相同\n设置脚本是否激活\nthis.enable=false;//失活\nthis.enable=true;//激活\n\n\n重要方法\n\n得到依附对象上挂载的其它脚本\n\n根据脚本名获取，获取失败返回null\nthis.GetComponent(\"脚本名\");//使用时用as进行转换使用\n根据Type获取\nthis.GetComponent(typeof(脚本类型));\n根据泛型获取 建议使用泛型获取，不用二次转换  建议使用\nthis.GetComponent&lt;脚本类型>();\n\n\n得到自己挂载的多个脚本\nthis.GetComponents&lt;脚本类型>(也可以直接用List);\n得到子对象挂载的脚本（默认也会找自身是否挂载该脚本）\nthis.GetComponentInChildren&lt;脚本类型>(true/false);//得单个\n//true子对象失活时也会查找，false子对象失活时不会查找\n\nthis.GetComponentsInChildren&lt;脚本类型>(true/false);//得多个\n得到父对象挂载得脚本（默认也会查找自身是否挂载该脚本）\nthis.GetComponentInParent&lt;脚本类型>();//得单个\n//true子对象失活时也会查找，false子对象失活时不会查找\n\nthis.GetComponentsInParent&lt;脚本类型>();//得多个\n尝试获取脚本\nthis.TryGetComponent&lt;脚本类型&gt;(out type);\n\n\n\nGameObject常用成员变量\n\n\nAPI\n描述\n\n\n\nthis.gameObject.name\n名字\n\n\nthis.gameObject.activeSelf\n是否激活\n\n\nthis.gameObject.isStatic\n是否是静态\n\n\nthis.gameObject.layer\n层级\n\n\nthis.gameObject.tag\n标签\n\n\nthis.gameObject.transform / this.transform\ntransform\n\n\nGameObject常用静态方法\n\n\nAPI\n描述\n\n\n\nGameObject.CreatePrimitive()\n创建自带几何体，会返回一个GameObject对象\n\n\nGameObject.Find()\n通过名字查找对象，效率较低，找不到失活对象，有相同名字的对象时，随机查找其中一个\n\n\nGameObject.FindWithTag()\n通过标签查找对象，找不到失活对象，有相同标签的对象时，随机查找其中一个\n\n\nGameObject.FindGameObjectWithTag()\n通过标签查找对象,与上一个API功能相同\n\n\nGameObject.FindGameObjectsWithTag()\n查找多个对象只能tag去找，无法通过名字 ，找不到失活对象\n\n\nGameObject.FindObjectOfType&lt;脚本类型&gt;()\n找到场景中挂载的某一个脚本对象，基本不使用，效率低下\n\n\nGameObject.instantiate()\n实例化对象，动态创建对象（名字后会增加clone）\n\n\nGameObject.Destroy()\n删除对象或者脚本，一般情况下会在下一帧移除对象并从内存中移除，第二个参数代表延迟删除的时间\n\n\nGameObject.DestroyImmediate()\n立即删除，不会等到下一帧，没有特殊需求不使用，可能存在卡顿\n\n\nGameObject.DontDestroyOnLoad()\n对象过场景不被移除（Unity默认过场景时场景中的对象都会自动删除掉）\n\n\nGameObject常用的成员方法\n\n\nAPI\n描述\n\n\n\nnew GameObject()\n创建一个空物体，存在重载，可以创建的同时添加脚本\n\n\nObj.AddComponent&lt;脚本类型&gt;()\n为对象添加脚本\n\n\nObj.SetActive()\n设置对象的激活和失活\n\n\nthis.CompareTag()\n标签比较\n\n\nthis.gameObject.SendMessage(“函数名”)\n执行挂载自身所有同名函数的行为 效率低下，不建议使用\n\n\nthis.gameObject.BroadcastMessage(“函数名”)\n广播行为，让自己和自己子对象执行相同函数名的函数\n\n\nthis.gameObject.SendMessageUpwards(“函数名”)\n向父对象和自己发送消息并执行相同函数名的函数\n\n\nUnity中的Object不是指的万物之父的objectTime\n主要用于游戏中参与位移，计时，时间暂停等\n\n时间缩放比例\n//时间停止\nTime.timeScale=0;\n\n//恢复正常\nTime.timeScale=1;\n\n//2倍速\nTime.timeScale=2;\n帧间隔时间：最近的一帧用了多长时间，主要用来计算位移\n//受Scale影响\nTime.deltaTime;\n\n//不受Scale影响的帧间隔时间\nTime.unscaledDeltaTime;\n游戏开始到现在的时间\n//受Scale影响\nTime.time;\n\n//受Scale影响\nTime.unscaledTime;\n物理帧间隔时间 FixedUpdate\n//受Scale影响\nTime.fixedDeltaTime;\n\n//不受Scale影响\nTime.fixedUnscaledDeltaTime;\n帧数\n//从开始到现在游戏跑了多少帧\nTime.frameCount;\n\nTransform\nVector3\n\n主要用来表示三维坐标系中的一个点或者向量\n\n常用\n\n\n\nAPI\n描述\n\n\n\nVector3.zero\n(0,0,0)\n\n\nVector3.right\n(1,0,0) X轴正方向\n\n\nVector3.left\n(-1,0,0)\n\n\nVector3.forward\n(0,0,1) Z轴正方向为面朝向\n\n\nVector3.back\n(0,0,-1)\n\n\nVector3.up\n（0,1,0）Y轴正方向\n\n\nVector3.down\n（0,-1,0）\n\n\nVector3.Distance\n计算两个点之间的距离\n\n\n\n\n\n位置和位移\n\n相对世界坐标系\nthis.transform.position;\n相对父对象\nthis.transform.localPosition;\n世界坐标和相对坐标相同时的两种情况\n\n父对象的坐标是世界坐标原点(0,0,0)\n对象没有父对象\n\n\n位置的赋值不能单独改变x,y,z的值，只能整体改变\n\n对象当前的各朝向\n\n\n\nAPI\n描述\n\n\n\nthis.transform.forward\n当前对象正方向\n\n\nthis.transform.back\n当前对象后方向\n\n\nthis.transform.up\n当前对象上方向\n\n\nthis.transform.down\n当前对象下方向\n\n\nthis.transform.right\n当前对象右方向\n\n\nthis.transform.left\n当前对象右左方向\n\n\n\n位移\n\n公式：路程 = 方向 * 速度 * 时间 \n//朝自身前方向移动\nthis.transform.position += this.transform.forward * Time.deltaTime * 10;\nAPI 一般使用该方式位移\n//参数一：表示位移多少  路程=方向*速度*时间\n//参数二：表示相对坐标系 默认是localPosition\nthis.transform.Translate();\n\n//朝自己的正方向移动\nthis.transform.Translate(this.transform.forward * 1*Time.deltaTime, Space.World);\n\n//朝世界的正方向移动\nthis.transform.Translate(Vector3.forward * 1 * Time.deltaTime, Space.World);\n\n//朝自己的正方向移动\nthis.transform.Translate(Vector3.forward * 1 * Time.deltaTime, Space.Self);\n\n\n\n\n角度和旋转\n\n自转 API\n//第一个参数：每一帧旋转的角度\n//第二个参数：相对坐标系 默认是自己的坐标系\nthis.transform.Rotate(new Vector3(0, 5, 0) * Time.deltaTime);\n\n//重载方式\n//第一个参数：相对于哪个轴进行运动\n//第二个参数：转动的角度是多少\n//第三个参数：相对坐标系 默认是自己的坐标系\nthis.transform.Rotate(Vector3.up, Time.deltaTime * 10,Space.Self);\n相对于某个点进行旋转\n//第一个参数：相对于哪个点\n//第二个参数：相对于点的轴\n//第三个参数：转的度数 旋转速度*时间\nthis.transform.RotateAround(Vector3.zero, Vector3.up, 10 * Time.deltaTime);\n\n\n\n\n\n\n\n\n特别注意\n通过欧拉角(Obj.transform.eulerAngles)获得的角度，在代码上始终只能在0~360范围内\n\n\n\n缩放和看向\n\n相对于世界坐标系，只能get不能set\nthis.transform.lossyScale;\n相对于本地坐标系（父对象）\nthis.transform.localScale;\n看向：让一个对象面朝向某一个点或者对象\nthis.transform.LookAt();\n\n\n父子关系\n\n获取和设置父对象\n//获取父对象\nthis.transform.parent;\n\n//设置父对象\nthis.transform.parent=null;//将父对象设置成空\nthis.transform.SetParent();//与上方效果相同，该方法重载中可以保留世界坐标位置\n\n//抛妻弃子\nthis.transform.DetachChildren();\n获得子对象\n//通过查找获得子对象\nthis.transform.Find(\"Cube (5)\");//该方法找不到孙子，失活对象也能找到\n\n//通过索引获得子对象\nthis.transform.GetChild(0)\n儿子的操作\n//一个对象判断自己是不是另一个对象的儿子\nIsChildOf();\n\n//得到自己作为儿子的编号\nGetSiblingIndex();\n\n//把自己设置为第一个儿子\nSetAsFirstSibling();\n\n//把自己设置为最后一个儿子\nSetAsLastSibling();\n\n//设置自己为指定为第几个儿子 超出范围会直接设置成最后一个子对象\nSetSiblingIndex(Index);\n\n\n\n坐标转换\n世界坐标系的点 转换 为相对本地坐标系的点（受缩放影响）\nthis.transform.InverseTransformPoint(Vector3.forward);\n世界坐标系的方向 转换 为相对本地坐标系的方向（不受缩放影响）\nthis.transform.InverseTransformDirection(Vector3.forward);\n世界坐标系的方向 转换 为相对本地坐标系的方向（受缩放影响）\nthis.transform.InverseTransformVector(Vector3.forward);\n\n\n\n\n\n\n\n提示\n世界坐标系 转 本地坐标系 可以帮助我们大概判断一个相对位置\n\n\n\n本地坐标系的点 转换 为相对世界坐标系的点（受缩放影响）\nthis.transform.TransformPoint(Vector3.forward);\n本地坐标系的方向 转换 为相对世界坐标系的方向（不受缩放影响）\nthis.transform.TransformDirection(Vector3.forward);\n本地坐标系的方向 转换 为相对世界坐标系的方向（受缩放影响）\nthis.transform.TransformVector(Vector3.forward);\n\n输入Input\n输入相关内容肯定是写在Update中\n\n鼠标在屏幕位置\nInput.mousePosition\n\n\n屏幕坐标的原点在屏幕左下角，往右是x轴正方向，往上是Y轴正方向\n返回值是Vector3 只有x和y有效 z一直是0\n\n\n检测鼠标输入\n\n鼠标按下\nif (Input.GetMouseButtonDown(0))\n&#123;\n    print(\"鼠标左键按下\");\n&#125;\nelse if (Input.GetMouseButtonDown(1))\n&#123;\n    print(\"鼠标右键按下\");\n&#125;\nelse if (Input.GetMouseButtonDown(2))\n&#123;\n    print(\"鼠标中键按下\");\n&#125;\n鼠标抬起\nif (Input.GetMouseButtonUp(0))\n&#123;\n    print(\"鼠标左键抬起\");\n&#125;\nelse if (Input.GetMouseButtonUp(1))\n&#123;\n    print(\"鼠标右键抬起\");\n&#125;\nelse if (Input.GetMouseButtonUp(2))\n&#123;\n    print(\"鼠标中键抬起\");\n&#125;\n鼠标长按\nif (Input.GetMouseButton(0))\n&#123;\n    print(\"鼠标左键长按下\");\n&#125;\nelse if (Input.GetMouseButton(1))\n&#123;\n    print(\"鼠标右键长按下\");\n&#125;\nelse if (Input.GetMouseButton(2))\n&#123;\n    print(\"鼠标中键长按下\");\n&#125;\n鼠标中键滚动\nInput.mouseScrollDelta;\n//-1往下滚动\n//0没有滚动\n//1往上滚动\n\n\n检测键盘输入\n\n键盘按下\nif (Input.GetKeyDown(KeyCode.W))\n&#123;\n    print(\"W按下\");\n&#125;\n\n//必须是小写\nif (Input.GetKeyDown(\"q\"))\n&#123;\n    print(\"Q按下\");\n&#125;\n键盘抬起\nif (Input.GetKeyUp(KeyCode.W))\n&#123;\n    print(\"W抬起\");\n&#125;\n\n//必须是小写\nif (Input.GetKeyUp(\"q\"))\n&#123;\n    print(\"Q抬起\");\n&#125;\n键盘长按\nif (Input.GetKey(KeyCode.Space))\n&#123;\n    print(\"空格长按\");\n&#125;\n\n//是否有任意键或鼠标长按\nif (Input.anyKey)\n&#123;\n    print(\"有键长按\");\n&#125;\n\n//是否有任意键或鼠标按下\nif (Input.anyKeyDown)\n&#123;\n    print(\"有键按下\");\n&#125;\n\n//这一帧的键盘输入\nprint(Input.inputString);\n\n\n\n检测默认轴输入\nInput.GetAxis(\"Horizontal\");//返回float\n\n\n在以下可以配置对应轴输入\n\n\n\n屏幕相关\n当前屏幕分辨率\nScreen.currentResolution;\n屏幕窗口当前宽高\nScreen.width;\nScreen.height;\n屏幕休眠模式\nScreen.sleepTimeout = SleepTimeout.NeverSleep;//永不熄屏\nScreen.sleepTimeout = SleepTimeout.SystemSetting;//系统设置\n运行时是否全屏模式\nScreen.fullScreen = true;\n窗口模式\n//独占全屏\n Screen.fullScreenMode = FullScreenMode.ExclusiveFullScreen;\n//全屏窗口\nScreen.fullScreenMode = FullScreenMode.FullScreenWindow;\n//最大化窗口\nScreen.fullScreenMode = FullScreenMode.MaximizedWindow;\n//窗口模式\nScreen.fullScreenMode = FullScreenMode.Windowed;\n移动设备屏幕转向相关\n//允许自动旋转为左横向 Home键在左\nScreen.autorotateToLandscapeLeft = true;\n//允许自动旋转为右横向 Home键在右\nScreen.autorotateToLandscapeRight = true;\n//允许自动旋转为纵向 Home键在下\nScreen.autorotateToPortrait = true;\n//允许自动旋转到纵向倒着看 Home键在上\nScreen.autorotateToPortraitUpsideDown = true;\n//指定屏幕显示方向\nScreen.orientation = ScreenOrientation.LandscapeLeft;//等等\n\n\n\n设置分辨率（移动设备上一般不使用）\nScreen.SetResolution(1920, 1080, true);\n\n摄像机组件\nClear Flags（如何清除背景）\n\n\n\n类型\n描述\n\n\n\nSkybox\n天空盒\n\n\nSolid Color\n颜色填充\n\n\nDepth only\n只画该层，背景透明\n\n\nDon’t Clear\n不移除，覆盖渲染\n\n\n\nCulling Mask（选择性渲染部分层级）\n\nProjection（透视模式）\n\nClipping Planes（裁剪平面距离 ）\n\nViewport Rect（视口范围，屏幕上将绘制该摄像机视图的位置，主要用于双摄像机游戏）\n\nDepth（渲染顺序上的深度）\n\nTarget Texture（渲染纹理）\n\n把摄像机画面渲染到一张图上，主要用于制作小地图\n在Project右键创建Render Texture\n\n\nOcclusion Culling（是否启用剔除遮挡）\n\n\n获取摄像机\n获取主摄像机\n//场景上必须有一个tag为MainCamera的摄像机\nCamera.main;\n获得摄像机的数量\nCamera.allCamerasCount;\n获得所有摄像机\nCamera[] cameras = Camera.allCameras;\n渲染委托相关函数\n//摄像机剔除前处理的委托函数\nCamera.onPreCull += (c) =>\n&#123;\n\n&#125;;\n\n//摄像机渲染前处理的委托\nCamera.onPreRender += (c) =>\n&#123;\n\n&#125;;\n\n//摄像机渲染后处理的委托\nCamera.onPostRender += (c) =>\n&#123;\n\n&#125;;\n界面上的参数 都可以在Camera中获取到\n\n世界坐标转到屏幕坐标（x和y对应屏幕坐标，z对应摄像机与该点的距离）\nCamera.main.WorldToScreenPoint(this.transform.position);\n屏幕坐标转世界坐标\n//z轴很重要\nVector3 v = Input.mousePosition;\nv.z = 10;\nprint(Camera.main.ScreenToWorldPoint(v));\n\n光源组件\nType：光源类型\n\n\n\n类型\n描述\n\n\n\nSpot\n聚光灯\n\n\nDirectional\n平行光\n\n\nPoint\n点光源\n\n\nArea\n面光源（烘焙状态下有效）\n\n\n\nColor：颜色\n\nMode：光源模式\n\n\n\n模式\n描述\n\n\n\nRealtime\n实时光源，每帧实时计算，效果好，性能消耗大\n\n\nBaked\n红背光源，预先计算好，无法动态改变\n\n\nMixed\n混合光源，预先计算+实时运算\n\n\n\nIntensity：光源强度\n\nIndirect Multiplier：间接光  改变间接光的强度，低于1每次反弹会使光更暗，大于1每次反弹会使光更亮\n\nShadow Type：阴影类型\n\n\n\n类型\n描述\n\n\n\nNoShadows\n关闭阴影\n\n\nHardShadows\n硬阴影\n\n\nSoftShadows\n柔阴影\n\n\n\nRealtimeShadows\n\n\n\n类型\n描述\n\n\n\nStrength\n阴影暗度0~1之间，越大越黑\n\n\nResolution\n阴影贴图渲染分辨率，越大越逼真，消耗也越高\n\n\nBias\n阴影推离光源的距离\n\n\nNormal Bias\n阴影投射面沿法线收缩距离\n\n\nNear Panel\n渲染阴影的近裁截面\n\n\n\nCookie：投影遮罩\n\nCookie Size：投影遮罩大小\n\nDraw Halo：光晕开关\n\nFlare：耀斑（摄像机上需要加上Flare Layer脚本才能在Game窗口显示耀斑）\n\nRenderMode：渲染模式\n\n\n\n模式\n描述\n\n\n\nAuto\n运行时确定\n\n\nImportant\n以像素质量单位进行渲染，效果好，消耗大\n\n\nNot Important\n以快速模式进行渲染\n\n\n\nCulling Mask：剔除遮罩层，决定哪些层的对象受到该光源影响\n\n\n光面板\n打开方式：Windows-&gt;Rendering-&gt;Lighting\n\n物理系统之碰撞检测\n刚体组件：RigidBody\n产生碰撞的必要条件：两个物体必须要有 碰撞器 ，其中至少有一个带有刚体\n\n\n\n\n\n\n碰撞函数\n//开始碰撞时执行的函数\nprivate void OnCollisionEnter(Collision collision)\n&#123;\n    \n&#125;\n  \n//碰撞结束时执行的函数\nprivate void OnCollisionExit(Collision collision)\n&#123;\n    \n&#125;\n  \n//两个物体互相接触时，会一直调用\nprivate void OnCollisionStay(Collision collision)\n&#123;\n    \n&#125;\n触发函数\n//触发开始时执行的函数\nprivate void OnTriggerEnter(Collider other)\n&#123;\n    \n&#125;\n  \n//触发结束时执行的函数\nprivate void OnTriggerExit(Collider other)\n&#123;\n    \n&#125;\n  \n//重叠时，会一直调用\nprivate void OnTriggerStay(Collider other)\n&#123;\n    \n&#125;\n\n","slug":"Unity3D引擎","date":"2022-09-22T15:48:50.000Z","categories_index":"Unity3D引擎","tags_index":"Unity3D引擎","author_index":"cBao"},{"id":"321e20a64de3485e0958a3f7db00142f","title":"UE中的网络同步RPC","content":"UE网络中的服务器在哪！\n在UE中存在服务器和客户端重合，创建房间的客户端同时具备服务器特性\n\nUE中服务器和客户端中对象的关系\n在服务器端，所有的角色（Actor）都是Authority（权威的）\n在客户端眼，除了自己控制的角色外，其他的所有角色都是Simulated proxy（模拟代理）\n在UE网络框架中，Actor是促成网络同步的重要对象\n\nActor的更新方式\n属性更新（针对成员变量）具有及时性，随属性变换而进行通知。属性更新不变化不消耗带宽，但会消耗CPU进行监听\nRPC（针对函数），由用户进行调用\n\nUE网络框架对象归属分类\n\n\nServer Only（仅存在于服务器上）\nServer &amp; Clients（存在于服务器和所有客户端）\nServer &amp; Owning Client（仅存在于服务器和自身客户端）\nOwning Client Only（仅存在于自己客户端）\n\n\n\nAGameMode\nAGameState\nAPlayerController\nAHUD\n\n\n\nAPlayerState\n\nUMG Widget\n\n\n\nAPawn\n\n\n\n\n角色类型标记\n每个Actor中都存在两个属性用来裁定当前Actor在服务器/客户端上的身份类型，分为Role和RemoteRole\n在蓝图中为LocalRole和RemoteRole\nGet Local Role：判断当前角色在本地端身份类型\nGet Remote Role：判断当前角色在远端身份类型（当是客户端时，远端为服务端，当是服务端时，远端是客户端）\n\n网络角色三种类型\nSimulated：由服务器进行数据发送，当前终端进行操控模拟。操控来源于服务器，Simulate对象无法执行RPC函数\nAutonomous：由当前终端实例进行操控。操控来源于真人\nAuthority：服务器端存在标记，表明当前Actor存在于服务器\n\nRPC远端调用，在本机上调用函数，但在其他机器上远程执行的函数。\nRPC执行的三种形式\n服务端执行（Server） ：由客户端调用，在服务器端执行\n客户端执行（Client）： 由服务器端调用，在客户端执行\n所有终端执行（Multicast）  ：由服务器端调用，在所有终端执行\n\nRPC调用注意事项\n必须从 Actor 上调用\n\nActor 必须能被复制（Replicates=true）\n\n如果 RPC 是从服务器调用并在客户端上执行，则只有实际拥有这个 Actor 的客户端才会执行函数\n\n如果 RPC 是从客户端调用并在服务器上执行，客户端就必须拥有调用 RPC 的 Actor。\n\n从服务器上调用RPC\n\n\n\nActor所有权\n未复制\nNetMulticast\nServer\nClient\n\n\n\nClient-Owned Actor\n在服务器上运行\n在服务器和所有客户端上运行\n在服务器上运行\n在 actor  的所属客户端上运行\n\n\nServer-owned actor\n在服务器上运行\n在服务器和所有客户端上运行\n在服务器上运行\n在服务器上运行\n\n\nUnowned actor\n在服务器上运行\n在服务器和所有客户端上运行\n在服务器上运行\n在服务器上运行\n\n\n\n从客户端上调用RPC\n\n\n\nActor所有权\n未复制\nNetMulticast\nServer\nClient\n\n\n\nOwned by invoking client（当前终端所有权）\n在执行调用的客户端上运行\n在执行调用的客户端上运行\n在服务器上运行\n在执行调用的客户端上运行\n\n\nOwned by a different client  （其他终端所有权）\n在执行调用的客户端上运行\n在执行调用的客户端上运行\n丢弃\n在执行调用的客户端上运行\n\n\nServer-owned actor\n在执行调用的客户端上运行\n在执行调用的客户端上运行\n丢弃\n在执行调用的客户端上运行\n\n\nUnowned actor\n在执行调用的客户端上运行\n在执行调用的客户端上运行\n丢弃\n在执行调用的客户端上运行\n\n\n\n\n蓝图中判断服务器和客户端\n\nAuthority：服务器\nRemote：客户端\n\nRPC执行的三种形式\n服务端执行（Server）：在客户端调用，在服务端执行\n客户端执行（Client）:在服务端调用，在客户端执行\n所有终端执行（Multicast）：只能在服务端调用，在所有终端执行\n\n设置Actor所有权\n蓝图中使用Set Owner节点在服务器上获得Actor所有权\n\n\n\n数据同步\nActor必须满足在网络上被复制,设置的参数需要开启复制\n参数的修正必须在服务器端修改,才可以在网络上同步\n蓝图参数同步的两种方式：\nReplicated，同步数据，但没有通知，无法直接通过参数修改驱动逻辑\n•RepNotify，同步数据，并生成通知函数，进行更新通知（向所有终端通知，满足相关性）\n\n\n\n","slug":"UE中的网络同步RPC","date":"2022-08-15T07:32:03.000Z","categories_index":"UnrealEngine","tags_index":"网络同步RPC","author_index":"cBao"},{"id":"fa2dad943cb3925ed47cb72cd3308d02","title":"UE中的文件API","content":"检查文件夹是否存在//文件路径\nFString Dir=FPaths::ProjectDir()/TEXT(\"cBao\");\n//检查文件是否存在\nIFileManager::Get().DirectoryExists(*Dir)\n\n创建文件夹IFileManager::Get().MakeDirectory(*Dir);\n\n检查文件是否存在//注意是/=\nFString Dir=FPaths::ProjectDir()/TEXT(\"cBao\");\nDir /=TEXT(\"cBao.txt\");\n\n//检查文件是否存在\nIFileManager::Get().FileExists(*Dir);\n//创建文件\n\nFFileHelper::SaveStringToFile(TEXT(\"cBao\"),*Dir);\n\n删除文件FString Dir=FPaths::ProjectDir()/TEXT(\"cBao/cc/cc2/cBao.txt\");\n//一般用于删除单个特定文件\nIFileManager::Get().Delete(*Dir);\n\nFString Dir2=FPaths::ProjectDir()/TEXT(\"cBao\");\n//一般用于删除整个文件夹\nIFileManager::Get().DeleteDirectory(*Dir2,true,true);\n\n拷贝文件//不带拷贝进度的拷贝\nFString Src=FPaths::ProjectDir()/TEXT(\"cBao/cc.pdf\");\nFString Dest=FPaths::ProjectDir()/TEXT(\"cBao/cc2.pdf\");\nIFileManager::Get().Copy(*Dest,*Src);\n\n//带拷贝进度的拷贝\n//继承FCopyProgress抽象类,用来显示拷贝进度\nstruct MyProgress:public FCopyProgress\n&#123;\n    //Fraction为拷贝进度百分比\n\tFORCEINLINE virtual bool Poll( float Fraction ) override\n\t&#123;\n\t\tGEngine->AddOnScreenDebugMessage(-1,10.f,FColor::Blue,FString::SanitizeFloat(Fraction));\n\t\treturn true;\n\t&#125;\n&#125;;\nFString Src2=FPaths::ProjectDir()/TEXT(\"cBao/cc.pdf\");\nFString Dest2=FPaths::ProjectDir()/TEXT(\"cBao/cc2.pdf\");\n//创建进度结构\nMyProgress cBaoProgress;\nIFileManager::Get().Copy(*Dest2,*Src2,true,false,false,&amp;cBaoProgress);\n\n文件信息//文件信息(创建日期，访问日期，修改日期，文件大小，是否是文件夹，是否只读，是否有效)\nFFileStatData FileState=IFileManager::Get().GetStatData(*Src);\n\n查找文件//文件路径\nFString Dir=FPaths::ProjectDir()/TEXT(\"cBao\");\n//检查路径是否存在\nif (IFileManager::Get().DirectoryExists(*Dir))\n&#123;\n    //保存文件名称\n\tTArray&lt;FString> NameArray;\n    //查找文件操作 *代表通配符\n\tIFileManager::Get().FindFiles(NameArray,*Dir,TEXT(\"*\"));\n\tfor(auto &amp;Temp:NameArray)\n\t&#123;\n\t\tGEngine->AddOnScreenDebugMessage(-1,10.f,FColor::Blue,Temp);\n\t&#125;\n&#125;\n\n递归查找指定目录下的文件路径//文件路径\nFString Dir=FPaths::ProjectDir()/TEXT(\"cBao\");\n//检查路径是否存在\nif (IFileManager::Get().DirectoryExists(*Dir))\n&#123;\n    //保存文件路径\n\tTArray&lt;FString> PathNameArray;\n    //查找文件操作 *代表通配符 第一个true代表查找文件,第二个false代表忽略文件夹\n\tIFileManager::Get().FindFilesRecursive(PathNameArray,*Dir,TEXT(\"*\"),true,false);\n\tfor (auto&amp; Name:PathNameArray)\n\t&#123;\n\t\tGEngine->AddOnScreenDebugMessage(-1,10.f,FColor::Red,Name);\n\t&#125;\n\n&#125;\n\n","slug":"UE中的文件操作","date":"2022-08-05T05:58:47.000Z","categories_index":"UnrealEngine","tags_index":"文件操作","author_index":"cBao"},{"id":"62bbf97645975b25a08d1c093027a65e","title":"UE中内存操作","content":"分配内存// C\nuint8* Ptr_C=(uint8*)malloc(sizeof(uint8)*1024);\n\t\n// C++\nuint8* Ptr_CPlus=new uint8[1024];\n\n// UEC++\nuint8* Ptr_UnrealCPlus=(uint8*)FMemory::Malloc(sizeof(uint8)*1024);\n\n\n重新分配内存// C/C++\nPtr_C=(uint8*)realloc(Ptr_C,sizeof(uint8)*2048);\n\t\n// UEC++\nFMemory::Realloc(Ptr_UnrealCPlus,sizeof(uint8)*2048);\n\n获得分配的内存大小int32 i = FMemory::GetAllocSize(Ptr_UnrealCPlus);\n\n\n\n\n\n\n\n\n特别注意\n只能获得 FMemory::Malloc() 分配的内存大小，否则会产生崩溃\n\n拷贝char Date1[1024]=\"Hello,World\";\nchar Date2[1024];\n// C/C++\nmemcpy(Date2,Date1,strlen(Date1));\n\n// UEC++\nFMemory::Memcpy(Date2,Date1,strlen(Date1));\n\n移动内存char Date1[1024]=\"Hello,World\";\nchar Date2[1024];\n// C/C++\nmemmove(Date2,Date1,strlen(Date1));\n\n// UEC++\nFMemory::Memmove(Date2,Date1,strlen(Date1));\n\n比较// C/C++\nchar DateComp[1024]=\"cBao2\";\nchar DateComp_2[1024]=\"cBao\";\nint32 Size=memcmp(DateComp,DateComp_2,sizeof(uint8)*5);\n\n// UEC++\nint32 Size2 = FMemory::Memcmp(DateComp,DateComp_2,sizeof(uint8)*5);\n\n\n\n\n\n\n\n\n注意\n当 DateComp&lt;DateComp_2 时返回值&lt;0\n当 DateComp=DateComp_2 时返回值=0\n当 DateComp&gt;DateComp_2 时返回值&gt;0\n\n\n交换char DateComp[1024]=\"cBao2\";\nchar DateComp_2[1024]=\"cBao\";\nFMemory::Memswap(DateComp,DateComp_2,sizeof(uint8)*5)\n\n\n\n\n\n\n\n\n注意\n仅UEC++中存在该API\n\n\n初始化方式//原生C\nmemset(Ptr_C,0,sizeof(uint8)*1024);\nmemset(Ptr_CPlus,0,sizeof(uint8)*1024);\n\n//C++中\nuint8* Ptr_CPlus2=new uint8[]&#123;1,23,4,5,5&#125;;\n\t\n//UEC++\nZeroMemory(Ptr_C,sizeof(uint8)*1024);\nZeroMemory(Ptr_CPlus,sizeof(uint8)*1024);\nFMemory::Memset(Ptr_UnrealCPlus,0,sizeof(uint8)*1024);\nFMemory::Memzero(Ptr_UnrealCPlus,sizeof(uint8)*1024);\n//在申请时就进行初始化\nuint8* Ptr_UnrealC=(uint8*)FMemory::MallocZeroed(sizeof(uint8)*1024);\n\n清除//C\nfree(Ptr_C);\n\t\n//C++中\ndelete[](Ptr_CPlus);\ndelete[](Ptr_CPlus2);\n\n//UEC++中\nFMemory::Free(Ptr_UnrealCPlus);\n\n\n\n\n\n\n\n\n特别注意\nFMemory::Free() 容易造成引擎崩溃\n\n\n","slug":"UE内存操作","date":"2022-08-04T07:41:08.000Z","categories_index":"UnrealEngine","tags_index":"内存操作","author_index":"cBao"},{"id":"ae911ea8c615446cd5e6fd02771c3f77","title":"Json","content":"JSON 语法规则\n数据在键/值对中\n数据由逗号 , 分隔\n使用斜杆来转义 \\ 字符\n大括号 {} 保存对象\n中括号 [] 保存数组，数组可以包含多个对象\n\nJSON 键值对JSON 数据的书写格式是：\n\"name\" : \"cBao\"\n\nJSON 值可以是\n数字（整数或浮点数）\n\"age\":30\n字符串（在双引号中）\n\"name\":\"cBao\"\n逻辑值（true 或 false）\n\"IsDeath\":false\n数组（在中括号中）\n&#123;\n    \"Info\": [\n    &#123; \"age1\":30 , \"name1\":\"cBao\" &#125;, \n    &#123; \"age2\":30 , \"name2\":\"cBao\" &#125;, \n    &#123; \"age3\":30 , \"name3\":\"cBao\" &#125;,\n    ]\n&#125;\n对象（在大括号中）\n&#123;\n  \"Object\":&#123;\n      \"age\":30, \n    \"name\":\"cBao\" \n  &#125;  \n&#125;\nnull\n\"runoob\":null\n\nUE5中将结构体转换成Json示例\n.Build.cs文件需要加入\nPrivateDependencyModuleNames.Add(\"Json\");\n.h文件\n// Fill out your copyright notice in the Description page of Project Settings.\n\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"Kismet/BlueprintFunctionLibrary.h\"\n#include \"StructToJson.generated.h\"\n\nUSTRUCT(BlueprintType)\nstruct FMyInfo\n&#123;\n\tGENERATED_BODY()\n\n\tUPROPERTY(EditAnywhere,BlueprintReadWrite)\n\tFString Name;\n\tUPROPERTY(EditAnywhere,BlueprintReadWrite)\n\tint32 Age;\n&#125;;\n\n\nUSTRUCT(BlueprintType)\nstruct FMyStruct\n&#123;\n\tGENERATED_BODY()\n\t\n\tUPROPERTY(EditAnywhere,BlueprintReadWrite)\n\tFString Name;\n\t\n\tUPROPERTY(EditAnywhere,BlueprintReadWrite)\n\tint32 Age;\n\t\n\tUPROPERTY(EditAnywhere,BlueprintReadWrite)\n\tbool Gender;\n\t\n\tUPROPERTY(EditAnywhere,BlueprintReadWrite)\n\tfloat Weight;\n\n\tUPROPERTY(EditAnywhere,BlueprintReadWrite)\n\tFMyInfo Info;\n\t\n\tUPROPERTY(EditAnywhere,BlueprintReadWrite)\n\tTArray&lt;FMyInfo> Array;\n&#125;;\n\n/**\n * \n */\nUCLASS()\nclass UE_ADVANCE_API UStructToJson : public UBlueprintFunctionLibrary\n&#123;\n\tGENERATED_BODY()\n\n\tUFUNCTION(BlueprintCallable,Category=cBao)\n\tstatic FString StructToString(const FMyStruct&amp; s1);\n\n&#125;;\n\n.cpp文件\n// Fill out your copyright notice in the Description page of Project Settings.\n\n\n#include \"StructToJson.h\"\n\nFString UStructToJson::StructToString(const FMyStruct&amp; s1)\n&#123;\n\t\tFString JsonString;\n\t\t//UE中的Json工程模式\n\t\tTSharedPtr&lt;TJsonWriter&lt;TCHAR,TCondensedJsonPrintPolicy&lt;TCHAR>>> JsonWriter=TJsonWriterFactory&lt;TCHAR,TCondensedJsonPrintPolicy&lt;TCHAR>>::Create(&amp;JsonString);\n\t\tJsonWriter->WriteObjectStart();\n\t\t&#123;\n\t\t\tJsonWriter->WriteValue(TEXT(\"Name\"),s1.Name);\n\t\t\tJsonWriter->WriteValue(TEXT(\"Age\"),s1.Age);\n\t\t\tJsonWriter->WriteValue(TEXT(\"Gender\"),s1.Gender);\n\t\t\tJsonWriter->WriteValue(TEXT(\"Weight\"),s1.Weight);\n\t\t\tJsonWriter->WriteObjectStart(TEXT(\"Info\"));\n\t\t\t&#123;\n\t\t\t\tJsonWriter->WriteValue(TEXT(\"Name\"),s1.Info.Name);\n\t\t\t\tJsonWriter->WriteValue(TEXT(\"Age\"),s1.Info.Age);\n\t\t\t&#125;\n\t\t\tJsonWriter->WriteObjectEnd();\n\t\t\tJsonWriter->WriteArrayStart(TEXT(\"Array\"));\n\t\t\t&#123;\n\t\t\t\tfor (auto &amp; s:s1.Array)\n\t\t\t\t&#123;\n\t\t\t\t\tJsonWriter->WriteObjectStart();\n\t\t\t\t\t&#123;\n\t\t\t\t\t\tJsonWriter->WriteValue(TEXT(\"Name\"),s.Name);\n\t\t\t\t\t\tJsonWriter->WriteValue(TEXT(\"Age\"),s.Age);\n\t\t\t\t\t&#125;\n\t\t\t\t\tJsonWriter->WriteObjectEnd();\n\t\t\t\t&#125;\n\t\t\t&#125;\n\t\t\tJsonWriter->WriteArrayEnd();\n\t\t&#125;\n\t\tJsonWriter->WriteObjectEnd();\n\t\tJsonWriter->Close();\n\t\treturn JsonString;\n&#125;\n\n蓝图中配置输出\n&#123;\"Name\":\"cBao\",\"Age\":24,\"Gender\":true,\"Weight\":2222,\"Info\":&#123;\"Name\":\"ccc\",\"Age\":32324&#125;,\"Array\":[&#123;\"Name\":\"cdd\",\"Age\":22131&#125;,&#123;\"Name\":\"dsaf\",\"Age\":232&#125;]&#125;\n\nUE5中将Json转换成结构体示例\n.h文件\n//FString反序列化成结构体\nUFUNCTION(BlueprintCallable,Category=cBao)\nstatic bool StructFromFString(const FString&amp; s1,FMyStruct&amp; MyStruct);\n.cpp文件\nbool UStructToJson::StructFromFString(const FString&amp; s1, FMyStruct&amp; MyStruct)\n&#123;\n\tTSharedRef&lt;TJsonReader&lt;>> JsonReader=TJsonReaderFactory&lt;>::Create(s1);\n\tTSharedPtr&lt;FJsonObject> ReadRoot;\n\n\tif (FJsonSerializer::Deserialize(JsonReader,ReadRoot))\n\t&#123;\n\t\t//获得String数据\n\t\tMyStruct.Name=ReadRoot->GetStringField(TEXT(\"Name\"));\n\t\t\n\t\t//获得int数据\n\t\tMyStruct.Age=ReadRoot->GetIntegerField(TEXT(\"Age\"));\n\t\t\n\t\t//获得bool数据\n\t\tMyStruct.Gender=ReadRoot->GetBoolField(TEXT(\"Gender\"));\n\t\t\n\t\t//获得浮点数据\n\t\tMyStruct.Weight=ReadRoot->GetNumberField(TEXT(\"Weight\"));\n\t\t\n\t\t//获得对象数据\n\t\tTSharedPtr&lt;FJsonObject> TestRoot=ReadRoot->GetObjectField(TEXT(\"Info\"));\n\t\t&#123;\n\t\t\tMyStruct.Info.Name=TestRoot->GetStringField(TEXT(\"Name\"));\n\t\t\tMyStruct.Info.Age=TestRoot->GetIntegerField(TEXT(\"Age\"));\n\t\t&#125;\n\n\t\t//获得数组数据\n\t\tTArray&lt;TSharedPtr&lt;FJsonValue>>TempArray=ReadRoot->GetArrayField(TEXT(\"Array\"));\n\t\tfor (auto &amp;i:TempArray)\n\t\t&#123;\n\t\t\tTSharedPtr&lt;FJsonObject> JsonObj = i->AsObject();\n\t\t\tFMyInfo TempInfo;\n\t\t\tTempInfo.Name=JsonObj->GetStringField(TEXT(\"Name\"));\n\t\t\tTempInfo.Age=JsonObj->GetIntegerField(TEXT(\"Age\"));\n\t\t\tMyStruct.Array.Add(TempInfo);\n\t\t&#125;\n\t\treturn true;\n\t&#125;\n\t\n\treturn false;\n&#125;\n\n","slug":"Json","date":"2022-08-02T06:17:49.000Z","categories_index":"Json","tags_index":"Json","author_index":"cBao"},{"id":"32edd7bc4a69fac72c5e2e1809026b07","title":"UE串口通信","content":"sdasfsa\nUE串口通信\n.h文件\n#pragma once\n\n#define FC_DTRDSR       0x01\n#define FC_RTSCTS       0x02\n#define FC_XONXOFF      0x04\n#define ASCII_BEL       0x07\n#define ASCII_BS        0x08\n#define ASCII_LF        0x0A\n#define ASCII_CR        0x0D\n#define ASCII_XON       0x11\n#define ASCII_XOFF      0x13\n\n\n#include \"CoreMinimal.h\"\n#include \"UObject/NoExportTypes.h\"\n#include \"Serial.generated.h\"\n\n/**\n * \n */\n\n // Forward declaration\ntypedef struct _OVERLAPPED OVERLAPPED;\n\nUENUM(BlueprintType, Category = \"UE4Duino\")\nenum class ELineEnd : uint8\n&#123;\n\trn\tUMETA(DisplayName = \"\\r\\n\"),\n\tn\tUMETA(DisplayName = \"\\n\"),\n\tr\tUMETA(DisplayName = \"\\r\"),\n\tnr\tUMETA(DisplayName = \"\\n\\r\")\n&#125;;\n\nUCLASS(BlueprintType, Category = \"UE4Duino\", meta = (Keywords = \"com arduino serial\"))\nclass INKPROJECTION_API USerial : public UObject\n&#123;\n\tGENERATED_BODY()\npublic:\n\t/** Determines the line ending used when writing lines to serial port with PrintLine. */\n\tUPROPERTY(BlueprintReadWrite, Category = \"UE4Duino | String\")\n\t\tELineEnd WriteLineEnd;\n\npublic:\n\tUSerial();\n\t~USerial();\n\n\t/**\n\t * Open a serial port and return the created Serial instance.\n\t * Don't forget to close the port before exiting the game.\n\t *\n\t * @param bOpened If the serial port was successfully opened.\n\t * @param Port The serial port to open.\n\t * @param BaudRate BaudRate to open the serial port with.\n\t * @return A Serial instance to work with the opened port.\n\t */\n\tUFUNCTION(BlueprintCallable, meta = (DisplayName = \"Open Serial Port\"), Category = \"UE4Duino\", meta = (Keywords = \"com arduino serial start\"))\n\t\tstatic USerial* OpenComPort(bool&amp; bOpened, int32 Port = 1, int32 BaudRate = 9600);\n\n\t/**\n\t * Utility function to convert 4 bytes into an Integer. If the input array's length is not 4, returns 0.\n\t *\n\t * @param Bytes A byte array with 4 values representing the integer in little-endian format.\n\t * @return The final integer value or 0 for an invalid array.\n\t */\n\tUFUNCTION(BlueprintPure, meta = (DisplayName = \"Bytes to Int\"), Category = \"UE4Duino\", meta = (Keywords = \"cast concatenate group bit bitwise\"))\n\t\tstatic int32 BytesToInt(TArray&lt;uint8> Bytes);\n\n\t/**\n\t * Utility function to get the 4 bytes that make an integer.\n\t *\n\t * @param Int The integer value to be converted.\n\t * @return A byte array containing the 4 bytes that make the integer, starting from the least significant one (little endian).\n\t */\n\tUFUNCTION(BlueprintPure, meta = (DisplayName = \"Int to Bytes\"), Category = \"UE4Duino\", meta = (Keywords = \"cast separate bit bitwise\"))\n\t\tstatic TArray&lt;uint8> IntToBytes(const int32&amp; Int);\n\n\t/**\n\t * Utility function to convert 4 bytes into a float. If the input array's length is not 4, returns 0.0.\n\t *\n\t * @param Bytes A byte array with 4 values representing the float in IEEE 754 standard format.\n\t * @return The final float value or 0.0 for an invalid array.\n\t */\n\tUFUNCTION(BlueprintPure, meta = (DisplayName = \"Bytes to Float\"), Category = \"UE4Duino\", meta = (Keywords = \"cast concatenate group bit bitwise\"))\n\t\tstatic float BytesToFloat(TArray&lt;uint8> Bytes);\n\n\t/**\n\t * Utility function to get the 4 bytes that make a float.\n\t *\n\t * @param Float The float value to be converted.\n\t * @return A byte array containing the 4 bytes that make the float, in IEEE 754 standard format.\n\t */\n\tUFUNCTION(BlueprintPure, meta = (DisplayName = \"Float to Bytes\"), Category = \"UE4Duino\", meta = (Keywords = \"cast separate bit bitwise\"))\n\t\tstatic TArray&lt;uint8> FloatToBytes(const float&amp; Float);\n\n\t/**\n\t * Open a serial port. Don't forget to close the port before exiting the game.\n\t * If this Serial instance has already an opened port,\n\t * return false and doesn't change the opened port number.\n\t *\n\t * @param Port The serial port to open.\n\t * @param BaudRate BaudRate to open the serial port with.\n\t * @return If the serial port was successfully opened.\n\t */\n\tUFUNCTION(BlueprintCallable, meta = (DisplayName = \"Open Port\"), Category = \"UE4Duino\", meta = (Keywords = \"com start init\"))\n\t\tbool Open(int32 Port = 2, int32 BaudRate = 9600);\n\t/**\n\t * Close and end the communication with the serial port. If not open, do nothing.\n\t */\n\tUFUNCTION(BlueprintCallable, meta = (DisplayName = \"Close Port\"), Category = \"UE4Duino\", meta = (Keywords = \"com end finish release\"))\n\t\tvoid Close();\n\n\t/**\n\t * Will read characters from Serial port until \\0 (null char) is found or there are no\n\t * characters left to read.\n\t *\n\t * @param bSuccess If there was anything to read.\n\t * @return The read string\n\t */\n\tUFUNCTION(BlueprintCallable, meta = (DisplayName = \"Read String\", keywords = \"get read receive string words text characters\"), Category = \"UE4Duino\")\n\t\tFString ReadString(bool&amp; bSuccess);\n\t/**\n\t * Will read characters from Serial port until \\r\\n (Arduino println line end) is found.\n\t *\n\t * @param bSuccess If there was anything to read.\n\t * @return The read string\n\t */\n\tUFUNCTION(BlueprintCallable, meta = (DisplayName = \"Read Line\", keywords = \"get read receive string words text characters\"), Category = \"UE4Duino\")\n\t\tFString Readln(bool&amp; bSuccess);\n\t/**\n\t * Reads the string until a specific char is met.\n\t * The Terminator char won't be included in the result string.\n\t */\n\t //UFUNCTION(BlueprintCallable, meta = (DisplayName = \"Read String Until\", keywords = \"get read receive string words text characters\"), Category = \"UE4Duino\")\n\tFString ReadStringUntil(bool&amp; bSuccess, uint8 Terminator);\n\t/**\n\t * Reads a float from the serial port (sent as 4 bytes).\n\t * @param bSuccess True if there were 4 bytes to read.\n\t * @return The read value\n\t */\n\tUFUNCTION(BlueprintCallable, meta = (DisplayName = \"Read a Float\", keywords = \"get read receive\"), Category = \"UE4Duino\")\n\t\tfloat ReadFloat(bool&amp; bSuccess);\n\t/**\n\t * Reads an integer from the serial port (sent as 4 bytes).\n\t * @param bSuccess True if there were 4 bytes to read.\n\t * @return The read value\n\t */\n\tUFUNCTION(BlueprintCallable, meta = (DisplayName = \"Read an Int\", keywords = \"get read receive integer\"), Category = \"UE4Duino\")\n\t\tint32 ReadInt(bool&amp; bSuccess);\n\t/**\n\t * Reads a byte from the serial port.\n\t * @param bSuccess True if there were 4 bytes to read.\n\t * @return The read value\n\t */\n\tUFUNCTION(BlueprintCallable, meta = (DisplayName = \"Read a Byte\", keywords = \"get read receive\"), Category = \"UE4Duino\")\n\t\tuint8 ReadByte(bool&amp; bSuccess);\n\t/**\n\t * Reads up to Limit bytes from the serial port. If there are less than Limit,\n\t * reads all of them and return True.\n\t * @param bSuccess True if there was at least 1 byte to read.\n\t * @return An array containing the read bytes\n\t */\n\tUFUNCTION(BlueprintCallable, meta = (DisplayName = \"Read Bytes\", keywords = \"get read receive\"), Category = \"UE4Duino\")\n\t\tTArray&lt;uint8> ReadBytes(int32 Limit = 256);\n\n\t/**\n\t * Writes a string without newline to the serial port.\n\t * @param String The string to be sent to the serial port.\n\t * @return True if the string was sent.\n\t */\n\tUFUNCTION(BlueprintCallable, meta = (DisplayName = \"Print\", keywords = \"send write string words text characters\"), Category = \"UE4Duino\")\n\t\tbool Print(FString String);\n\t/**\n\t * Writes a string with newline (\\n) appended at the end to the serial port.\n\t * @param String The string to be sent to the serial port.\n\t * @return True if the string was sent.\n\t */\n\tUFUNCTION(BlueprintCallable, meta = (DisplayName = \"Print Line\", keywords = \"send write string words text characters\"), Category = \"UE4Duino\")\n\t\tbool Println(FString String);\n\t/**\n\t * Writes a float value to the serial port as 4 bytes.\n\t * @param Value The value to be sent to the serial port.\n\t * @return True if the bytes were sent.\n\t */\n\tUFUNCTION(BlueprintCallable, meta = (DisplayName = \"Write a Float\", keywords = \"send\"), Category = \"UE4Duino\")\n\t\tbool WriteFloat(float Value);\n\t/**\n\t * Writes an integer value to the serial port as 4 bytes.\n\t * @param Value The value to be sent to the serial port.\n\t * @return True if the bytes were sent.\n\t */\n\tUFUNCTION(BlueprintCallable, meta = (DisplayName = \"Write an Int\", keywords = \"integer send\"), Category = \"UE4Duino\")\n\t\tbool WriteInt(int32 Value);\n\t/**\n\t * Writes a byte value to the serial port.\n\t * @param Value The value to be sent to the serial port.\n\t * @return True if the byte was sent.\n\t */\n\tUFUNCTION(BlueprintCallable, meta = (DisplayName = \"Write a Byte\", keywords = \"send\"), Category = \"UE4Duino\")\n\t\tbool WriteByte(uint8 Value);\n\t/**\n\t * Writes a byte array as a sequence of bytes to the serial port.\n\t * @param Buffer The byte array to be sent to the serial port.\n\t * @return True if the bytes were sent.\n\t */\n\tUFUNCTION(BlueprintCallable, meta = (DisplayName = \"Write Bytes\", keywords = \"send\"), Category = \"UE4Duino\")\n\t\tbool WriteBytes(TArray&lt;uint8> Buffer);\n\n\t/** Clean the serial port by reading everything left to be read. */\n\tUFUNCTION(BlueprintCallable, meta = (DisplayName = \"Flush Port\"), Category = \"UE4Duino\")\n\t\tvoid Flush();\n\n\t/**\n\t * Check if the serial port is open.\n\t * @return True if the serial port is open.\n\t */\n\tUFUNCTION(BlueprintPure, meta = (DisplayName = \"Is Port Open\"), Category = \"UE4Duino\")\n\t\tbool IsOpened() &#123; return m_hIDComDev != NULL; &#125;\n\n\t/**\n\t * Read the number of the serial port selected for this Serial instance.\n\t * @return The number of the serial port.\n\t */\n\tUFUNCTION(BlueprintPure, meta = (DisplayName = \"Get Port Number\"), Category = \"UE4Duino\")\n\t\tint32 GetPort() &#123; return m_Port; &#125;\n\n\t/**\n\t * Read the selected BaudRate for this Serial instance.\n\t * @return The baud rate.\n\t */\n\tUFUNCTION(BlueprintPure, meta = (DisplayName = \"Get Baud Rate\"), Category = \"UE4Duino\")\n\t\tint32 GetBaud() &#123; return m_Baud; &#125;\n\n\t/**\n\t * Converts a LineEnd enum value to String.\n\t * @param LineEnd LineEnd enum value.\n\t * @return The LineEnd value in string format.\n\t */\n\tUFUNCTION(BlueprintCallable, meta = (DisplayName = \"Line End to String\", keywords = \"cast convert\"), Category = \"UE4Duino\")\n\t\tFString LineEndToStr(ELineEnd LineEnd);\n\nprotected:\n\tvoid* m_hIDComDev;\n\n\t// These are pointers to be able to use OVERLAPPED with forward declaration\n\tOVERLAPPED* m_OverlappedRead;\n\tOVERLAPPED* m_OverlappedWrite;\n\n\tint32 m_Port;\n\tint32 m_Baud;\n&#125;;\n\n.cpp文件\n// Fill out your copyright notice in the Description page of Project Settings.\n\n\n#include \"Serial.h\"\n\n#include \"Windows/AllowWindowsPlatformTypes.h\"\n#include \"Windows/MinWindows.h\"\n#include \"Windows/HideWindowsPlatformTypes.h\"\n#include&lt;iostream>\n#include&lt;cmath>\n#include&lt;cstring>\n\nusing namespace std;\n#define BOOL2bool(B) B == 0 ? false : true\n\nUSerial* USerial::OpenComPort(bool&amp; bOpened, int32 Port, int32 BaudRate)\n&#123;\n\tUSerial* Serial = NewObject&lt;USerial>();\n\tbOpened = Serial->Open(Port, BaudRate);\n\treturn Serial;\n&#125;\n\nint32 USerial::BytesToInt(TArray&lt;uint8> Bytes)\n&#123;\n\tif (Bytes.Num() != 4)\n\t&#123;\n\t\treturn 0;\n\t&#125;\n\n\treturn *reinterpret_cast&lt;int32*>(Bytes.GetData());\n&#125;\n\nTArray&lt;uint8> USerial::IntToBytes(const int32&amp; Int)\n&#123;\n\tTArray&lt;uint8> Bytes;\n\tBytes.Append(reinterpret_cast&lt;const uint8*>(&amp;Int), 4);\n\treturn Bytes;\n&#125;\n\nfloat USerial::BytesToFloat(TArray&lt;uint8> Bytes)\n&#123;\n\tif (Bytes.Num() != 4)\n\t&#123;\n\t\treturn 0;\n\t&#125;\n\n\treturn *reinterpret_cast&lt;float*>(Bytes.GetData());\n&#125;\n\nTArray&lt;uint8> USerial::FloatToBytes(const float&amp; Float)\n&#123;\n\tTArray&lt;uint8> Bytes;\n\tBytes.Append(reinterpret_cast&lt;const uint8*>(&amp;Float), 4);\n\treturn Bytes;\n&#125;\n\nUSerial::USerial()\n\t: WriteLineEnd(ELineEnd::n)\n\t, m_hIDComDev(nullptr)\n\t, m_OverlappedRead(nullptr)\n\t, m_OverlappedWrite(nullptr)\n\t, m_Port(-1)\n\t, m_Baud(-1)\n&#123;\n\t// Allocate the OVERLAPPED structs\n\tm_OverlappedRead = new OVERLAPPED();\n\tm_OverlappedWrite = new OVERLAPPED();\n\n\tFMemory::Memset(m_OverlappedRead, 0, sizeof(OVERLAPPED));\n\tFMemory::Memset(m_OverlappedWrite, 0, sizeof(OVERLAPPED));\n&#125;\n\nUSerial::~USerial()\n&#123;\n\tClose();\n\n\t// Delete allocated OVERLAPPED structs\n\tdelete m_OverlappedRead;\n\tdelete m_OverlappedWrite;\n&#125;\n\nbool USerial::Open(int32 nPort, int32 nBaud)\n&#123;\n\tif (nPort &lt; 0)\n\t&#123;\n\t\tUE_LOG(LogTemp, Error, TEXT(\"Invalid port number: %d\"), nPort);\n\t\treturn false;\n\t&#125;\n\tif (m_hIDComDev)\n\t&#123;\n\t\tUE_LOG(LogTemp, Warning, TEXT(\"Trying to use opened Serial instance to open a new one. \"\n\t\t\t\"Current open instance port: %d | Port tried: %d\"), m_Port, nPort);\n\t\treturn false;\n\t&#125;\n\n\tFString szPort;\n\tif (nPort &lt; 10)\n\t\tszPort = FString::Printf(TEXT(\"COM%d\"), nPort);\n\telse\n\t\tszPort = FString::Printf(TEXT(\"\\\\\\\\.\\\\COM%d\"), nPort);\n\tDCB dcb;\n\n\tm_hIDComDev = CreateFile(*szPort, GENERIC_READ | GENERIC_WRITE, 0, NULL, OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL | FILE_FLAG_OVERLAPPED, NULL);\n\tif (m_hIDComDev == NULL)\n\t&#123;\n\t\tunsigned long dwError = GetLastError();\n\t\tUE_LOG(LogTemp, Error, TEXT(\"Failed to open port COM%d (%s). Error: %08X\"), nPort, *szPort, dwError);\n\t\treturn false;\n\t&#125;\n\n\tFMemory::Memset(m_OverlappedRead, 0, sizeof(OVERLAPPED));\n\tFMemory::Memset(m_OverlappedWrite, 0, sizeof(OVERLAPPED));\n\n\tCOMMTIMEOUTS CommTimeOuts;\n\t//CommTimeOuts.ReadIntervalTimeout = 10;\n\tCommTimeOuts.ReadIntervalTimeout = 0xFFFFFFFF;\n\tCommTimeOuts.ReadTotalTimeoutMultiplier = 0;\n\tCommTimeOuts.ReadTotalTimeoutConstant = 0;\n\tCommTimeOuts.WriteTotalTimeoutMultiplier = 0;\n\tCommTimeOuts.WriteTotalTimeoutConstant = 10;\n\tSetCommTimeouts(m_hIDComDev, &amp;CommTimeOuts);\n\n\tm_OverlappedRead->hEvent = CreateEvent(NULL, true, false, NULL);\n\tm_OverlappedWrite->hEvent = CreateEvent(NULL, true, false, NULL);\n\n\tdcb.DCBlength = sizeof(DCB);\n\tGetCommState(m_hIDComDev, &amp;dcb);\n\tdcb.BaudRate = nBaud;\n\tdcb.ByteSize = 8;\n\n\tif (!SetCommState(m_hIDComDev, &amp;dcb) ||\n\t\t!SetupComm(m_hIDComDev, 10000, 10000) ||\n\t\tm_OverlappedRead->hEvent == NULL ||\n\t\tm_OverlappedWrite->hEvent == NULL)\n\t&#123;\n\t\tunsigned long dwError = GetLastError();\n\t\tif (m_OverlappedRead->hEvent != NULL) CloseHandle(m_OverlappedRead->hEvent);\n\t\tif (m_OverlappedWrite->hEvent != NULL) CloseHandle(m_OverlappedWrite->hEvent);\n\t\tCloseHandle(m_hIDComDev);\n\t\tm_hIDComDev = NULL;\n\t\tUE_LOG(LogTemp, Error, TEXT(\"Failed to setup port COM%d. Error: %08X\"), nPort, dwError);\n\t\treturn false;\n\t&#125;\n\n\t//FPlatformProcess::Sleep(0.05f);\n\tAddToRoot();\n\tm_Port = nPort;\n\tm_Baud = nBaud;\n\treturn true;\n&#125;\n\nvoid USerial::Close()\n&#123;\n\tif (!m_hIDComDev) return;\n\n\tif (m_OverlappedRead->hEvent != NULL) CloseHandle(m_OverlappedRead->hEvent);\n\tif (m_OverlappedWrite->hEvent != NULL) CloseHandle(m_OverlappedWrite->hEvent);\n\tCloseHandle(m_hIDComDev);\n\tm_hIDComDev = NULL;\n\n\tRemoveFromRoot();\n&#125;\n\nFString USerial::ReadString(bool&amp; bSuccess)\n&#123;\n\treturn ReadStringUntil(bSuccess, '\\0');\n&#125;\n\nFString USerial::Readln(bool&amp; bSuccess)\n&#123;\n\treturn ReadStringUntil(bSuccess, '\\n');\n&#125;\n\nFString USerial::ReadStringUntil(bool&amp; bSuccess, uint8 Terminator)\n&#123;\n\tbSuccess = false;\n\tif (!m_hIDComDev) return TEXT(\"\");\n\n\tTArray&lt;uint8> Chars;\n\tuint8 Byte = 0x0;\n\tbool bReadStatus;\n\tunsigned long dwBytesRead, dwErrorFlags;\n\tCOMSTAT ComStat;\n\n\tClearCommError(m_hIDComDev, &amp;dwErrorFlags, &amp;ComStat);\n\tif (!ComStat.cbInQue) return TEXT(\"\");\n\n\tdo &#123;\n\t\tbReadStatus = BOOL2bool(ReadFile(\n\t\t\tm_hIDComDev,\n\t\t\t&amp;Byte,\n\t\t\t1,\n\t\t\t&amp;dwBytesRead,\n\t\t\tm_OverlappedRead));\n\n\t\tif (!bReadStatus)\n\t\t&#123;\n\t\t\tif (GetLastError() == ERROR_IO_PENDING)\n\t\t\t&#123;\n\t\t\t\tWaitForSingleObject(m_OverlappedRead->hEvent, 2000);\n\t\t\t&#125;\n\t\t\telse\n\t\t\t&#123;\n\t\t\t\tChars.Add(0x0);\n\t\t\t\tbreak;\n\t\t\t&#125;\n\t\t&#125;\n\n\t\tif (Byte == Terminator || dwBytesRead == 0)\n\t\t&#123;\n\t\t\t// when Terminator is \\n, we know we're expecting lines from Arduino. But those\n\t\t\t// are ended in \\r\\n. That means that if we found the line Terminator (\\n), our previous\n\t\t\t// character could be \\r. If it is, we remove that from the array.\n\t\t\tif (Chars.Num() > 0 &amp;&amp; Terminator == '\\n' &amp;&amp; Chars.Top() == '\\r') Chars.Pop(false);\n\n\t\t\tChars.Add(0x0);\n\t\t\tbreak;\n\t\t&#125;\n\t\telse Chars.Add(Byte);\n\n\t&#125; while (Byte != 0x0 &amp;&amp; Byte != Terminator);\n\n\tbSuccess = true;\n\tauto Convert = FUTF8ToTCHAR((ANSICHAR*)Chars.GetData());\n\treturn FString(Convert.Get());\n&#125;\n\nfloat USerial::ReadFloat(bool&amp; bSuccess)\n&#123;\n\tbSuccess = false;\n\n\tTArray&lt;uint8> Bytes = ReadBytes(4);\n\tif (Bytes.Num() == 0) return 0;\n\n\tbSuccess = true;\n\treturn *(reinterpret_cast&lt;float*>(Bytes.GetData()));\n&#125;\n\nint32 USerial::ReadInt(bool&amp; bSuccess)\n&#123;\n\tbSuccess = false;\n\n\tTArray&lt;uint8> Bytes = ReadBytes(4);\n\tif (Bytes.Num() == 0) return 0;\n\n\tbSuccess = true;\n\treturn *(reinterpret_cast&lt;int32*>(Bytes.GetData()));\n&#125;\n\nuint8 USerial::ReadByte(bool&amp; bSuccess)\n&#123;\n\tbSuccess = false;\n\tif (!m_hIDComDev) return 0x0;\n\n\tuint8 Byte = 0x0;\n\tbool bReadStatus;\n\tunsigned long dwBytesRead, dwErrorFlags;\n\tCOMSTAT ComStat;\n\n\tClearCommError(m_hIDComDev, &amp;dwErrorFlags, &amp;ComStat);\n\tif (!ComStat.cbInQue) return 0x0;\n\n\tbReadStatus = BOOL2bool(ReadFile(\n\t\tm_hIDComDev,\n\t\t&amp;Byte,\n\t\t1,\n\t\t&amp;dwBytesRead,\n\t\tm_OverlappedRead));\n\n\tif (!bReadStatus)\n\t&#123;\n\t\tif (GetLastError() == ERROR_IO_PENDING)\n\t\t&#123;\n\t\t\tWaitForSingleObject(m_OverlappedRead->hEvent, 2000);\n\t\t&#125;\n\t\telse\n\t\t&#123;\n\t\t\treturn 0x0;\n\t\t&#125;\n\t&#125;\n\n\tbSuccess = dwBytesRead > 0;\n\treturn Byte;\n&#125;\n\nTArray&lt;uint8> USerial::ReadBytes(int32 Limit)\n&#123;\n\tTArray&lt;uint8> Data;\n\n\tif (!m_hIDComDev) return Data;\n\n\tData.Empty(Limit);\n\n\tuint8* Buffer = new uint8[Limit];\n\tbool bReadStatus;\n\tunsigned long dwBytesRead, dwErrorFlags;\n\tCOMSTAT ComStat;\n\n\tClearCommError(m_hIDComDev, &amp;dwErrorFlags, &amp;ComStat);\n\tif (!ComStat.cbInQue) return Data;\n\n\tbReadStatus = BOOL2bool(ReadFile(\n\t\tm_hIDComDev,\n\t\tBuffer,\n\t\tLimit,\n\t\t&amp;dwBytesRead,\n\t\tm_OverlappedRead));\n\n\tif (!bReadStatus)\n\t&#123;\n\t\tif (GetLastError() == ERROR_IO_PENDING)\n\t\t&#123;\n\t\t\tWaitForSingleObject(m_OverlappedRead->hEvent, 2000);\n\t\t&#125;\n\t\telse\n\t\t&#123;\n\t\t\treturn Data;\n\t\t&#125;\n\t&#125;\n\n\tData.Append(Buffer, dwBytesRead);\n\treturn Data;\n&#125;\n\nbool USerial::Print(FString String)\n&#123;\n\tauto Convert = FTCHARToUTF8(*String);\n\tTArray&lt;uint8> Data;\n\tData.Append((uint8*)Convert.Get(), Convert.Length());\n\n\treturn WriteBytes(Data);\n&#125;\n\nbool USerial::Println(FString String)\n&#123;\n\treturn Print(String + LineEndToStr(WriteLineEnd));\n&#125;\n\nbool USerial::WriteFloat(float Value)\n&#123;\n\tTArray&lt;uint8> Buffer;\n\tBuffer.Append(reinterpret_cast&lt;uint8*>(&amp;Value), 4);\n\treturn WriteBytes(Buffer);\n&#125;\n\nbool USerial::WriteInt(int32 Value)\n&#123;\n\tTArray&lt;uint8> Buffer;\n\tBuffer.Append(reinterpret_cast&lt;uint8*>(&amp;Value), 4);\n\treturn WriteBytes(Buffer);\n&#125;\n\nbool USerial::WriteByte(uint8 Value)\n&#123;\n\tTArray&lt;uint8> Buffer(&#123; Value &#125;);\n\treturn WriteBytes(Buffer);\n&#125;\n\nbool USerial::WriteBytes(TArray&lt;uint8> Buffer)\n&#123;\n\tif (!m_hIDComDev) false;\n\n\tbool bWriteStat;\n\tunsigned long dwBytesWritten;\n\n\tbWriteStat = BOOL2bool(WriteFile(m_hIDComDev, Buffer.GetData(), Buffer.Num(), &amp;dwBytesWritten, m_OverlappedWrite));\n\tif (!bWriteStat &amp;&amp; (GetLastError() == ERROR_IO_PENDING))\n\t&#123;\n\t\tif (WaitForSingleObject(m_OverlappedWrite->hEvent, 1000))\n\t\t&#123;\n\t\t\tdwBytesWritten = 0;\n\t\t\treturn false;\n\t\t&#125;\n\t\telse\n\t\t&#123;\n\t\t\tGetOverlappedResult(m_hIDComDev, m_OverlappedWrite, &amp;dwBytesWritten, false);\n\t\t\tm_OverlappedWrite->Offset += dwBytesWritten;\n\t\t\treturn true;\n\t\t&#125;\n\t&#125;\n\n\treturn true;\n&#125;\n\nvoid USerial::Flush()\n&#123;\n\tif (!m_hIDComDev) return;\n\n\tTArray&lt;uint8> Data;\n\n\tdo &#123;\n\t\tData = ReadBytes(8192);\n\t&#125; while (Data.Num() > 0);\n&#125;\n\nFString USerial::LineEndToStr(ELineEnd LineEnd)\n&#123;\n\tswitch (LineEnd)\n\t&#123;\n\tcase ELineEnd::rn:\n\t\treturn TEXT(\"\\r\\n\");\n\tcase ELineEnd::n:\n\t\treturn TEXT(\"\\n\");\n\tcase ELineEnd::r:\n\t\treturn TEXT(\"\\r\");\n\tcase ELineEnd::nr:\n\t\treturn TEXT(\"\\n\\r\");\n\tdefault:\n\t\treturn TEXT(\"null\");\n\t&#125;\n&#125;\n蓝图使用\n\n蓝图代码连接https://blueprintue.com/blueprint/ss-s-s83/\n\n\n","slug":"UE串口通信","date":"2022-07-22T08:14:36.000Z","categories_index":"UnrealEngine","tags_index":"串口通信","author_index":"cBao"},{"id":"650e8b54c427468049a9eded7ddf3373","title":"C++仿函数和代理","content":"仿函数\n\n\n\n\n\n提示\n需要头文件#include &lt; functional &gt;\n\n仿函数与普通函数#include &lt;iostream>\n#include &lt;functional>\n\nint Test(int A, int B)\n&#123;\n\tstd::cout&lt;&lt;A+B&lt;&lt;std::endl;\n\treturn A+B;\n&#125;\n\nint main()\n&#123;\n\tstd::function&lt;int(int,int)> Func_Test=Test;\n\tFunc_Test(2,3);\n&#125;\n\n\nint(int,int)：返回类型(形参列表)\n\n仿函数与Lambda#include &lt;iostream>\n#include &lt;functional>\n\nauto Lam=[&amp;](int A,int B)\n&#123;\n\tstd::cout&lt;&lt;A+B&lt;&lt;std::endl;\n\treturn A+B;\n&#125;;\n\nint main()\n&#123;\n\tstd::function&lt;int(int,int)> Fun_Test=Lam;\n\tFun_Test(3,4);\n&#125;\n\n","slug":"C++仿函数和代理","date":"2022-07-17T07:19:09.000Z","categories_index":"C++","tags_index":"仿函数和代理","author_index":"cBao"},{"id":"f58daaa95359f10d1d47b72330587f5d","title":"VisualStudio常用操作","content":"Visual Studio中常用的快捷键\n\n\n快捷键\n功能\n\n\n\nCtrl + K, O\n在头文件与源文件之间切换\n\n\nCtrl + K, C\n注释选择行\n\n\nCtrl + K, U\n取消选择行的注释\n\n\nCtrl + K, D\n对齐所有代码\n\n\nCtrl+Shift+U\n全部变为大写\n\n\nCtrl+U\n全部变为小写\n\n\nAlt+鼠标左按钮\n选择矩形文本\n\n\nCtrl+F\n在当前文件中查找\n\n\nCtrl+Shift+F\n在当前的解决方案中查找\n\n\n","slug":"Visual Studio常用操作","date":"2022-07-07T03:18:50.000Z","categories_index":"IDE","tags_index":"Visual Studio","author_index":"cBao"}]