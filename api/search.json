[{"id":"666eeba740dffa28e952c25ed8f5ff46","title":"C#图解教程第5版","content":"C#中的命名约定\n\n\n风格名称\n描述\n推荐使用\n示例\n\n\n\nPascal大小写\n标识符每个单词首字母大写\n用于类型名称和类中对外可见成员的名称（类，方法，命名空间，属性和公有字段）\nCardDeck\n\n\nCamel大小写\n标识符每个单词首字母大写，第一个单词除外\n用于局部变量的名称和方法声明的形参名称\ncardDeck\n\n\n下划线和Camel大小写\n以下划线开头的Camel大小写的标识符\n用于私有和受保护的字段\n_cardDeck\n\n\n\n\n\n\n\n\n\n注意\n\n标识符命名可以使用字母，数字，下划线\n\n标识符只能以字母和下划线开头，不能以数字开头\n\n@字符只能放在标识符首位，不推荐使用\n\n不能将关键字用于标识符\n\nC#区分大小写\n\n\n\n\n\nC#程序的起点：Main\n每个C#程序必须有一个类带有Main方法\n\n每个C#程序的可执行点在Main的第一条指令\n\nMain首字母必须大写\n\nMain的最简单形式\nstatic void Main()\n&#123;\n   &#x2F;&#x2F;更多语句\n&#125;\n\n空白符\n空格（Space）\n制表符（Tab）\n换行符\n回车符\n\n块\n语法上只需要一条语句，而你需要执行的动作无法用一条简单的语句表达的情况下，考虑使用块\n有些特定的程序结构只能使用块。在这些结构，不能用简单语句替代快\n块后面不跟分号\n\n从程序中输出文本Write\nWrite是Console类的成员，将文本字符串发送到程序控制台窗口\nWrite不会自动添加换行符\n\nConsole.Write(&quot;Hello&quot;);\n\nWriteLine\nWriteLine是Console类的成员，将文本字符串发送到程序控制台窗口\nWriteLine会自动在结尾添加一个换行符\n\nConsole.WriteLine(&quot;Hello,World&quot;);\n\n格式字符串\nWrite和WriteLine语句的常规形式中可以有一个以上的参数，参数间用逗号分隔\n\n第一个参数必须是字符串，称为格式字符串，包含替代标记\n\n语法：Console.WriteLine(格式字符串(含替代标记),替换值0,替换值1,替换值2,……);\nConsole.WriteLine(&quot;Hell&#123;0&#125;,Wor&#123;1&#125;d&quot;, &#39;o&#39;, &#39;l&#39;);\n\n\n\n\n\n\n\n提示\n​        C#6.0引入字符串插值，通过直接在替代标记内插入变量名实现，前提需要加上$符号    \nint var1 &#x3D; 3;\nint var2 &#x3D; 4;\nConsole.WriteLine($&quot;&#123;var1&#125;+&#123;var2&#125;&#x3D;?&quot;);\n\n\n\n多重标记和值\n在C#中可以使用任意数量的替代标记和任意数量的值，值可以以任何顺序使用\n值可以在格式字符串中替换任意次\n标记不能试图引用超出替换值列表长度以外位置的值，若引用超过长度以外的值，不会产生编译错误，但会产生运行时错误（异常）\n\nConsole.WriteLine(&quot;He&#123;0&#125;&#123;0&#125;o,Worl&#123;1&#125;&quot;,&#39;l&#39;,&#39;d&#39;);&#x2F;&#x2F;正确用法\n\n\n格式化数字字符串\n把值作为货币或者某个小数位数的定点值来显示\n\nConsole.WriteLine(&quot;The value:&#123;0:C&#125;&quot;, 500);\n\n\n\n注释\n\n\n类型\n开始\n结束\n描述\n\n\n\n单行注释\n//\n\n从开始标记到该行行尾的文本被编译器忽略\n\n\n带分隔符的注释\n/*\n*/\n从开始标记到结束标记之间的文本被编译器忽略\n\n\n文档注释\n///\n\n这种类型的注释包含XML文本，可以使用工具生成程序文档\n\n\n预定义类型\nC#提供16种预定义类型\n\n\n\n\n用户定义类型6种类型可以由用户自己创建\n类类型（class）\n结构类型（struct）\n数组类型（array）\n枚举类型（enum）\n委托类型（delegate）\n接口类型（interface）\n\n栈和堆栈\n栈是一个内存数组，是一个LIFO(后进先出的数据结构)\n\n栈存储几种类型的数据\n\n某些类型变量的值\n程序当前的执行环境\n传递给方法的参数\n\n\n栈的特征\n\n数据只能从栈的顶端插入和删除\n将数据放到栈顶称为入栈（push）\n从栈顶删除数据称为出栈（pop）\n\n\n\n\n\n\n\n\n\n\n提示\n​        系统管理所有栈操作\n\n\n堆\n堆是一块内存区域，在堆里可以分配大块的内存用于存储某种类型的数据对象\n与栈不同，堆里的内存能够以任意顺序存入和移除\n在C#中GC会自动清除无主的堆对象（C++需要程序员自己释放内存）\nGC垃圾收集的过程\n\n\n值类型和引用类型\n\n\n类声明类class Player\n&#123;\n    &#x2F;&#x2F;...\n&#125;\n\n类成员\n字段和方法是最重要的类成员类型。字段是数据成员，方法是函数成员\n\n字段：隶属于类的变量\n\n\n\n\n\n\n\n注意\n​        与C/C++不同，C#在类型外部不能声明全局变量（变量或字段）。所有字段都属于类型，必须在类型内部声明。\n\n\n\n方法：相当于C++中的成员函数\n\n\n\n\n\n\n\n注意\n​        与C/C++不同，C#中没有全局函数​        C#中的所有方法必须包含返回类型或void\n\n\n\n\n\n\n为数据分配内存\n使用new运算符为实际数据分配内存\n\nnew运算符为任意指定类型的实例分配并初始化内存。依据类型的不同从栈或堆里分配\nPlayer p1&#x3D;new Player();\n\n访问修饰符\n语法\n字段：访问修饰符 类型 标识符;\n方法：访问修饰符 返回类型 方法名() {…}\n\n\n五种修饰符\n私有的（private）\nC#默认的访问级别是私有访问\n私有成员只能从声明它的类的内部访问，其它的类看不见且无法访问它们\n\n\n公有的（public）\n受保护的（protected）\n内部的（internal）\n受保护内部的（protected internal）\n\n\n\n方法方法的结构方法头\n指示方法是否返回数据，如果返回，返回什么类型\n方法的名称\n接受的数据类型\n\n方法体\n包含可执行代码的语句序列，执行过程从方法体的第一条语句开始，一直到整个方法结束\n\n\n方法体内部的代码执行\n局部变量\n控制流结构\n方法调用\n内嵌的块\n其它方法（局部函数，C#7.0开始）\n\n局部变量\n局部变量的生命周期仅限于创建它的块及其内嵌的块\n声明时开始存在\n在块完成时结束存在\n\n\n可以在方法体内任意位置声明局部变量，但必须在使用它们前声明\n不会隐式初始化，使用之前未赋值，编译器会产生错误消息\n类型推断和var关键字\nvar关键字只能用于局部变量，不能用于字段（属于类的变量为字段）\n只能在局部变量声明中包含初始化时使用\n一旦编译器推断出变量的类型，它就是固定且不能更改的\nvar关键字不改变C#的强类型性质\n\n\n在C#中不管嵌套级别如何，都不能在第一个名称的有效范围内声明另一个同名的局部变量\n\n控制流选择语句\nif\nif…else\nswitch\n\n迭代语句\nfor循环\nwhile循环\ndo循环\nforeach（为一组中每个成员执行一次）\n\n跳转语句\nbreak：跳出当前循环\ncontinue：到当前循环的底部\ngoto：到一个标签\nreturn：返回到调用方法继续执行\n\n返回值\n如果要返回值，方法必须在方法名前面声明一个返回类型\n如果方法不返回值，必须声明为void返回类型\n\n参数形参\n形参是局部变量，声明在方法的参数列表中\n\n实参\n用于初始化形参的表达式或变量称作实参\n\n值参数\n在栈中为形参分配空间\n将实参的值复制给形参\n改变形参不会影响实参\n\n引用参数\n使用引用参数时，必须在方法的声明和调用中都是用ref修饰符\n实参必须是变量，且必须被赋值\n形参会改变实参\n\n引用类型作为值参数和引用参数\n将引用类型对象作为值参数传递：如果在方法内创建一个新对象并赋值给形参，将切断形参与实参之间的关联，并且再调用方法后，新对象也不复存在。\n将引用类型对象作为引用参数传递：如果在方法内创建一个新对象并赋值给形参，在方法结束后该对象依然存在，并且是实参所引用的值。\n\n输出参数\n必须在声明和调用中都使用修饰符。输出参数的修饰符是out不是ref\n\n和引用参数相似，实参必须是变量，不能是其它类型的表达式\n\nout修饰的形参，不用再外部初始化，但必须要在内部赋值，再使用\n\n在C#7.0之后，\nusing System;\n\nnamespace Simple\n&#123;\n\n    class Program\n    &#123;\n        int Sum(out int val1, out int val2)\n        &#123;\n            val1 &#x3D; 20;\n            val2 &#x3D; 30;\n            return val1 + val2;\n        &#125;\n        static void Main()\n        &#123;\n            Program p1 &#x3D; new Program();\n            int sum &#x3D; p1.Sum(out int val1, out int val2);&#x2F;&#x2F;不在需要预先声明一个变量用作out参数\n            Console.WriteLine(&quot;val1:&#123;0&#125;,val2:&#123;1&#125;&quot;, val1, val2);\n        &#125;\n    &#125;\n&#125;\n\n参数数组\n在一个参数列表中只能有一个参数数组\n\n如果有，必须是列表中的最后一个\n\n由参数数组表示的所有参数必须是同一类型\n\n在数据类型前使用params修饰符\n\n在数据类型后放置一组空的方括号\nvoid Test(params int[] vals);\n如果数组参数是值类型，那么值被复制，实参在方法内部不受影响\n\n如果数组参数是引用类型，那么引用被赋值，实参引用的对象在方法内部会受到影响\n\n\n参数类型总结\nref局部变量和ref返回ref局部变量\n创建一个对象的别名，即使引用的对象是值类型\n\n对任意一个变量的赋值都会反映到另一个变量上（类似C++中的引用），即使是值类型\n\n语法\nref int y &#x3D; ref x;&#x2F;&#x2F;y是x的别名\n\nref返回\n使方法返回变量的引用而不是变量值\n\n语法\npublic ref int RefToVal()\n&#123;\n    return ref Score;\n&#125;\n\n方法重载一个类中可以有多个同名方法，叫做方法重载，使用相同名称的每个方法必须有一个和其它方法不同的签名\n\n方法签名组成\n方法名称\n参数的数目\n参数的类型和顺序\n参数修饰符\n\n\n返回类型不是签名的一部分\n形参的名称也不是签名的一部分\n\n递归方法调用自身，叫做递归\n深入理解类成员修饰符的顺序\n修饰符\n如果有修饰符，必须放在核心声明之前\n如果有多个修饰符，可以任意顺序排列\n\n\n特性\n如果有特性，必须放在核心声明之前\n如果有多个特性，可以任意顺序排列\n\n\n\n\n静态字段\n静态字段被类的所有实例共享，所有实例都访问同一内存位置\n\n用static修饰符将字段声明成静态\nstatic int test &#x3D; 100;\n使用类名和’.’运算符访问静态字段\n\n即使不存在类实例，静态成员也存在\n\n\n静态函数成员\n静态函数成员独立于任何类实例，即使没有类实例，仍然可以调用静态方法\n静态函数成员不能访问实例成员，但能访问静态成员\n\n成员常量\n类似于静态字段，没有实例也可以使用\n与真正的静态量不同，常量没有自己的存储位置，类似于C/C++中的#define值\n不能声明成static\n\n属性属性是代表类实例或类中数据项的成员\n\n属性的特征\n\n是命名的类成员\n有类型\n可以被赋值和读取\n属性是一个函数成员\n不一定为数据存储分配内存\n执行代码\n\n\n属性是一组被称为访问器的方法\n\nset访问器为属性赋值\n拥有一个单独的，隐式的值参，名称为value，与属性的类型相同\n拥有一个返回类型void\n\n\nget访问器从属性获取值\n没有参数\n拥有一个与属性类型相同的返回类型\nget访问器的所有执行路径必须包含一条return语句，返回一个属性类型的值\n\n\n访问器set和get可以以任何顺序声明，且除了这两个访问器外，属性上不允许有其它方法\n\n\n不能显示的调用访问器，会产生编译错误\n\n属性和关联字段\n\n将字段声明成private，声明一个public属性来控制从类的外部对该字段的访问\nclass Test\n&#123;\n    private int val;\n    public int Value\n    &#123;\n        set &#123; val &#x3D; value; &#125;\n        get &#123; return val; &#125;\n        \n    &#125;  \n&#125;\n属性和它们对应的后备字段的命名约定\n\n字段使用Camel大小写，属性使用Pascal大小写\nclass Test\n&#123;\n    private int val;&#x2F;&#x2F;字段使用Camel大小写\n    public int Value&#x2F;&#x2F;属性使用Pascal大小写\n    &#123;\n        set &#123; val &#x3D; value; &#125;\n        get &#123; return val; &#125;\n        \n    &#125;  \n&#125;\n字段使用Camel大小写，并以下划线_开头，属性使用Pascal大小写（按照C#命名约定，推荐使用这种方式）\nclass Test\n&#123;\n    private int _val;&#x2F;&#x2F;字段使用Camel大小写，并以下划线_开头\n    public int Value&#x2F;&#x2F;属性使用Pascal大小写\n    &#123;\n        set &#123; val &#x3D; value; &#125;\n        get &#123; return val; &#125;\n        \n    &#125;  \n&#125;\n\n\n\n\n属性和lambda表达式\n\nC#7.0引入的新语法\n\n只能在访问函数体由一个表达式组成时才能使用\nprivate int val;\npublic int Value\n&#123;\n    set&#x3D;&gt; val &#x3D; value &gt; 100 ? 100 : value;\n    get &#x3D;&gt; val;\n&#125;\n\n\n\n只读和只写属性属性的访问器可以单独声明\n\n只有get访问器的属性称为只读属性。只读属性能够安全的将一个数据项从类或类的实例中传出\n只有set访问器的属性称为只写属性\n两个访问器中至少有一个必须定义，否则编译器会报错\n\n属性与公有字段按照推荐的编码实践，属性比公有字段更好\n\n属性是函数成员而不是数据成员，允许处理输入和输出，而公有字段不行\n属性可以只读或只写，而字段不行\n编译后的变量和编译后的属性语义不同\n\n自动实现属性因为属性经常被关联到后备字段，所以C#提供了自动实现属性（自动属性）\n\n允许只声明属性而不声明后备字段，编译器会创建后备字段，自动挂接到get和set访问器上\n\n自动实现属性的要点如下\n\n不声明后备字段，编译器根据属性的类型分配存储\n不能提供访问器的方法体，必须被简单的声明为分号\n\nclass Test\n&#123;\n    public int Value&#123; get; set; &#125;\n&#125;\n\n静态属性属性也可以声明为static。静态属性的访问器和所有静态成员一样，具有以下特点：\n\n不能访问类的实例成员，但能被实例成员访问\n不管类是否有实例，都存在\n在类的内部，可以仅使用名称来引用静态属性\n在类的外部，可以使用类名或者使用using static结构来引用静态属性\n\n实例构造函数实例构造函数是一个特殊的方法，它在创建每个新实例时执行\n\n构造函数用于初始化类实例的状态\n如果希望能从类的外部创建类的实例，需要将构造函数声明为public\n构造函数的名称和类名相同\n构造函数不能有返回值\n构造函数可以带参数\n构造函数可以被重载\n如果在类的声明中没有显示的提供实例构造函数，编译器会提供一个隐式的默认构造函数（没有参数，构造体为空）\n如果为类显示定义了构造函数，编译器不会为该类定义默认构造函数\n将构造函数的访问修饰符设置成private，这样在类外部就不能实例该类型对象\n\n静态构造函数构造函数可以声明为static，实例构造函数初始化每个新实例，static构造函数初始化类级别的项，通常静态构造函数初始化类的静态字段\n\n在引用任何静态成员之前\n在创建类的任何实例之前\n静态构造函数的名称必须和类名相同\n构造函数不能有返回值\n静态构造函数声明中使用static关键字\n类只能有一个静态构造函数，且不能带参数\n静态构造函数不能有访问修饰符\n\n\n\n\n\n\n\n\n注意\n\n类既可以有静态构造函数也可以有实例构造函数\n如同静态方法，静态构造函数不能访问所在类的实例成员，因此不能使用this访问器\n不能从程序中显示的调用静态构造函数，系统自动调用\n\n\n\n对象初始化语句\n创建对象的代码必须能够访问要初始化的字段和属性（公有的）\n\n初始化语句发生在构造方法执行之后\n\n语法示例\nTest t2 &#x3D; new Test &#123; X &#x3D; 10, Y &#x3D; 20&#125;;&#x2F;&#x2F;使用了初始化语句\n\n析构函数析构函数执行在类的实例被销毁之前需要的清理或释放非托管资源的行为\nreadonly修饰符字段可以用readonly修饰符声明，作用类似于const，一旦值被设定就不能改变\n\nconst字段只能在字段的声明语句中初始化，而readonly字段可以在下列任意位置设置它的值\n\n字段声明语句，类似const\n类的任何构造函数，如果是static字段，初始化必须在静态构造函数中完成\n\n\nconst字段的值必须在编译时决定，而readonly字段的值可以在运行时决定\n\n语法示例\nclass Test\n&#123;\n    public Test()\n    &#123;\n        val &#x3D; 20;&#x2F;&#x2F;在构造函数中为只读字段赋值\n    &#125;\n    public readonly int val;&#x2F;&#x2F;只读字段\n&#125;\n\nthis关键字this关键字在类中使用，是对当前实例的引用，它只能被用在下列类成员的代码块中\n\n实例构造函数\n实例方法\n属性和索引器的实例访问器\n用于区分类的成员和局部变量或参数\n作为调用方法的实参\n\n\n\n\n\n\n\n\n注意\n​    因为静态成员不是实例的一部分，所以不能在任何静态函数成员的代码中使用this关键字\n\n\n索引器索引器是一组get和set的访问器，与属性类似\n\n和属性一样，索引器不用分配内存来存储\n索引器和属性都主要被用来访问其它数据成员，它们与这些成员关联，并为它们提供获取和设置访问\n属性通常表示单个数据成员\n索引器通常表示多个数据成员\n\n\n和属性一样，索引器可以只有一个访问器，也可以两个都有\n索引器总是实例成员，所以不能被声明成static\n和属性一样，实现get和set的访问器的代码不一定要关联到某个字段或属性\n不能显示调用get和set访问器\n\n声明索引器\n索引器没有名称。在名称的位置是关键字this\n参数列表在方括号中间\n参数列表中必须至少声明一个参数\n\nstring this[int index]\n&#123;\n    get &#123; return this[index]; &#125;\n    set &#123; this[index] &#x3D; value; &#125;\n&#125;\n\n索引器的set访问器当索引器被用于赋值时，set访问器被调用，并接受两项数据\n\n一个名为value的隐式参数，其中持有要保存的数据\n一个或更多索引参数，表示数据应该保存到哪里\n\n索引器示例class Test\n&#123;\n    private int val1;\n    private int val2;\n    private int val3;\n\n    public int this[int index]\n    &#123;\n        get\n        &#123;\n            switch (index)\n            &#123;\n                case 0: return val1;\n                case 1: return val2;\n                case 2: return val3;\n                default:  throw new IndexOutOfRangeException();\n            &#125;\n        &#125;\n        set\n        &#123;\n            switch (index)\n            &#123;\n                case 0:val1&#x3D; value; break;\n                case 1:val2&#x3D; value; break;\n                case 2:val3&#x3D; value; break;\n                default:throw new IndexOutOfRangeException();\n            &#125;\n        &#125;\n    &#125;\n&#125;\n\n索引器重载只要索引器的参数列表不同，类就可以有任意多个索引器。索引器类型不同是不够的\n\n\n\n\n\n\n\n注意\n​        类中重载的索引器必须有不同的参数列表\n\n\n访问器的访问修饰符\n仅当成员（属性或索引器）既有get访问器也有set访问器时，其访问器才能有访问修饰符\n虽然两个访问器都必须出现，但其中只能有一个访问修饰符\n访问器的访问修饰符的限制必须比成员的访问级别更严格\n\n\n分部类和分部类型类的声明可以分割成几个分部类的声明\n\n每个分部类的声明都含有一些类成员的声明\n\n类的分部类声明可以在同一个文件中也可以在不同文件中\n\n每个分部类声明必须标注为partial class，而不是单独的关键字class\n\n分部类声明和普通类声明相同，只是增加了类型修饰符partial\n\n分部类示例\npartial class Test\n&#123;\n    public int val1;\n&#125;\n\npartial class Test\n&#123;\n    public Test()\n    &#123;\n        val1 &#x3D; 1;\n    &#125;\n    public int val2;\n&#125;\n\n分部方法分部方法是声明在分部类中不同部分的方法，分部方法的不同部分可以声明在分部类的不同部分中，也可以声明在同一个部分中\n分部方法的两个部分\n定义分部方法声明\n给出签名和返回类型\n声明的实现部分只是一个分号\n\n\n实现分部方法声明\n给出签名和返回类型\n以普通的语句块形式实现\n\n\n\n类和继承类继承通过继承可以定义一个新类，新类为一个已经声明的类进行拓展\n\n可以使用一个已经存在的类作为新类的基础。已经存在的类称为基类，新类称为派生类\n\n派生类组成如下\n\n本身声明中的成员\n基类的成员\n\n\n要声明一个派生类，需要在类名后加入基类规格说明\nclass Base\n&#123;\n    \n&#125;\n\n&#x2F;&#x2F;使用基类规格说明,Base是Sub的基类\nclass Sub : Base\n&#123;\n    \n&#125;\n派生类拓展它的基类，因为它包含基类的成员，还有它本身声明中新增功能\n\n派生类不能删除它所继承的任何成员\n\n\n访问继承的成员继承的成员可以被访问，就像它们是派生类自己声明的一样\n所有类都派生自object除了特殊的类object，所有类都是派生类，即使没有基类规格说明，类object是唯一的非派生类，因为它是继承层次结构的基础\n\n没有基类规格说明的类隐式地直接派生自类object\n一个类声明的基类规格说明中只能有一个单独的类。称为单继承\n虽然类只能直接继承一个基类，但派生的层次没有限制\n\n屏蔽基类成员虽然派生类不能删除它继承的任何成员，但可以用与基类成员名称相同的成员来屏蔽基类成员。\n\n要屏蔽一个继承的数据成员，需要声明一个新的相同类型的成员，并使用相同的名称\n\n通过在派生类中声明新的带有相同签名的函数成员，可以屏蔽继承的函数成员，签名由名称和参数列表组成，不包括返回类型\n\n要让编译器知道故意屏蔽继承的成员，可使用new修饰符，否则编译器会警告你隐藏了一个继承的成员\nclass Base\n&#123;\n    public int val;\n&#125;\n\nclass Sub : Base\n&#123;\n    &#x2F;&#x2F;使用new 关键字 显示的告诉编译器屏蔽继承的成员\n    new public int val;\n&#125;\n也可以屏蔽静态成员\n\n\n基类访问如果派生类必须访问被隐藏的继承成员，可以使用基类访问表达式，基类访问表达式由关键字base后面跟着一个点和成员名称组成\nclass Base\n&#123;\n    public int val&#x3D;20;\n&#125;\n\n&#x2F;&#x2F;使用基类规格说明,Base是Sub的基类\nclass Sub : Base\n&#123;\n    &#x2F;&#x2F;使用new 关键字 显示的告诉编译器屏蔽继承的成员\n    new public int val;\n    public void PrintfFun()\n    &#123;\n        &#x2F;&#x2F;使用base关键字访问被隐藏的基类成员\n        Console.WriteLine(base.val);\n    &#125;\n&#125;\n\n使用基类的引用派生类的实例由基类的实例和派生类新增的成员组成。派生类的引用指向整个类对象，包括基类部分\n如果有一个派生类对象的引用，就可以获取该对象基类部分的引用（使用类型转换运算符把该引用转换为基类类型）\nclass Base\n&#123;\n    public void Printf()\n    &#123;\n        Console.WriteLine(&quot;My Base Class&quot;);\n    &#125;\n&#125;\n\n&#x2F;&#x2F;使用基类规格说明,Base是Sub的基类\nclass Sub : Base\n&#123;\n    &#x2F;&#x2F;隐藏基类的Printf函数\n    new public void Printf()\n    &#123;\n        Console.WriteLine(&quot;My Sub Class&quot;);\n    &#125;\n&#125;\n\nclass Program\n&#123;\n    static void Main()\n    &#123;\n        Sub s1&#x3D;new Sub();\n        Base b1 &#x3D; (Base)s1;&#x2F;&#x2F;强转成基类类型\n        b1.Printf();&#x2F;&#x2F;调用的是基类的Printf\n    &#125;  \n&#125;\n\n虚方法和覆写方法当使用基类的引用访问派生类对象时，得到的是基类的成员，虚方法可以使基类的引用访问“升至”派生类内\n使用基类引用调用派生类方法\n派生类的方法和基类的方法有相同的签名和返回类型\n基类的方法使用virtual标注\n派生类的方法使用override标注\n\nclass Base\n&#123;\n    &#x2F;&#x2F;virtual标记表示该方法可被覆写\n    virtual public void Printf()\n    &#123;\n        Console.WriteLine(&quot;My Base Class&quot;);\n    &#125;\n&#125;\n\n&#x2F;&#x2F;使用基类规格说明,Base是Sub的基类\nclass Sub : Base\n&#123;\n    &#x2F;&#x2F;override标记覆写基类方法\n    override public void Printf()\n    &#123;\n        Console.WriteLine(&quot;My Sub Class&quot;);\n    &#125;\n&#125;\n\n\nclass Program\n&#123;\n    static void Main()\n    &#123;\n        Sub s1&#x3D;new Sub();\n        Base b1 &#x3D; (Base)s1;&#x2F;&#x2F;强转成基类类型\n        b1.Printf();&#x2F;&#x2F;因为派生类覆写了基类方法，所以调用派生类方法\n    &#125;    \n&#125;\n\n\n\n\n\n\n\n\n注意\n\n覆写和被覆写的方法必须有相同的可访问性\n不能覆写static方法或非虚方法\n方法，属性和索引器，事件都可以被声明成virtual和override\n\n\n\n覆写标记为override的方法\n当使用对象基类部分的引用调用一个被覆写的方法时，方法的调用被沿派生层次上溯执行，一直到标记为override的方法的最高派生版本\n如果在更高的派生级别有该方法的其它声明，但没有被override标记，那么不会被调用\n\n构造函数执行\n要创建对象的基类部分，需要隐式调用基类的某个构造函数\n继承层次链中的每个类在执行它自己的构造函数体之前执行它基类的构造函数\n\n\n\n\n\n\n\n\n\n注意\n​    强烈反对在构造函数中调用虚方法，在执行基类的构造函数时，基类的虚方法会调用派生类的覆写方法，但这是在执行派生类的构造函数方法之前。\n​    因此，调用会在派生类完全初始化之前传递到派生类。\n\n\n构造函数初始化语句默认情况下，在构造对象时，将调用基类的无参构造函数。\n如果希望派生类使用指定的基类构造函数，必须在构造函数初始化语句中指定它\n\n第一种形式使用关键字base指明使用哪一个基类构造函数\nclass Base\n&#123;\n    public Base(int val1,int val2)\n    &#123;\n        Val1 &#x3D; val1;\n        Val2 &#x3D; val2;\n    &#125;\n\n    public int Val1;\n    public int Val2;\n&#125;\n\nclass SubClass : Base\n&#123;\n    &#x2F;&#x2F;base指明使用哪一个基类构造函数\n    public SubClass(int val1, int val2) : base(val1, val2)\n    &#123;\n\n    &#125;\n&#125;\n第二种形式使用关键字this并指明应该使用当前类的哪一个构造函数\nclass Base\n&#123;\n    &#x2F;&#x2F;使用this指定调用当前类的无参构造函数\n    public Base(int val1):this()\n    &#123;\n        Val1 &#x3D; val1;\n    &#125;\n\n    public Base()\n    &#123;\n        Val2 &#x3D; 20;\n    &#125;\n\n    public int Val1;\n    public int Val2;\n\n    public void Printf()\n    &#123;\n        Console.WriteLine($&quot;Val1:&#123;Val1&#125;\\nVal2:&#123;Val2&#125;&quot;);\n    &#125;\n&#125;\n\n类访问修饰符类的可访问性有两个级别\n\n标记为public的类可以被系统内任何程序集中的代码访问，要是一个类对其它程序集可见，使用public访问修饰符\npublic class Base\n&#123;\n    \n&#125;\n标记为internal的类只能被它自己所在的程序集内的类看到\n\n这是C#默认的可访问级别\n可以使用internal访问修饰符显示的声明一个类为内部的\n\ninternal class Base\n&#123;\n    \n&#125;\n\n程序集之间的继承要从不同程序集中定义的基类派生类，必须具备两个条件\n\n基类必须被声明成public，这样才能从它所在的程序集外部访问它\n必须在VS工程中的References节点中添加对包含该基类的程序集的引用\n\n成员访问修饰符\n所有显示声明在类声明中的成员都是相互可见的，无论访问性如何\n继承的成员不在类的声明中显式声明，所以继承的成员对派生类的成员可能是可见的，也可能是不可见的\n五个成员访问级别\npublic\n访问级别是限制最少的。所有的类，包括程序集内部的类和外部的类都可以自由的访问成员\n\n\nprivate\n修饰的类成员只能被它自己的类的成员访问，不能被其它的类访问，包括继承它的类\nprivate成员能被嵌套在它的类中的类成员访问\n\n\nprotected\n访问级别类似private访问级别，但它允许派生自该类的类访问该成员\n\n\ninternal\n标记为internal的成员对程序集内部的所有类可见，但对程序集外部的类不可见\n\n\nprotected internal\n标记为protected internal的成员对所有继承该类的类以及程序集内部的所有类可见\n\n\n\n\n\n抽象成员\n必须是一个函数成员，字段和常量不能为抽象成员\n必须用abstract修饰符标记\n不能有实现代码块，抽象成员的代码用分号表示\n抽象成员只能在抽象类中声明\n一共有四种类型的成员可以声明为抽象的\n方法\n属性\n事件\n索引器\n\n\n\n\n\n\n\n\n\n\n注意\n\n尽管抽象成员必须在派生类中用相应的成员覆写，但不能把virtual修饰符附加到abstract修饰符\n类似于虚成员，派生类中抽象成员的实现必须指定override修饰符\n\n\n\n\n抽象类抽象类是指设计为被继承的类。抽象类只能被用作其它类的基类\n\n不能创建抽象类实例\n\n抽象类使用abstract修饰符声明\nabstract class Test\n&#123;\n\n&#125;\n抽象类可以包含抽象成员或普通的非抽象成员，抽象类的成员可以是抽象成员和普通带实现的成员的任意组合\n\n抽象类自己可以派生自另一个抽象类。\n\n任何派生自抽象类的类必须使用override关键字实现该类所有的抽象成员，除非派生类自己也是抽象类\n\n\n密封类\n密封类只能被用作独立的类，不能被用作基类（与抽象类相反，抽象类只能用作基类）\n密封类使用sealed修饰符标注\n\n&#x2F;&#x2F;密封类\nsealed class Test\n&#123;\n    \n&#125;\n\n静态类\n静态中所有成员都是静态的\n静态类用于存放不受实例数据影响的数据和函数\n类本身必须标记为static\n类的所有成员必须是静态的\n类可以有一个静态构造函数，但不能有实例构造函数，因为不能创建该类的实例\n静态类是隐式密封的，不能够继承静态类\n可以使用类名和成员名，像访问其它静态成员那样访问静态类成员\n\n&#x2F;&#x2F;静态类\nstatic class Test\n&#123;\n    static Test()\n    &#123;\n        val &#x3D; 10;\n    &#125;\n    public static int val;\n    public static void PrintfMe()\n    &#123;\n        Console.WriteLine(&quot;My is static class&quot;);\n    &#125;\n&#125;\n\n拓展方法为一个类添加方法的几种方式\n如果有源代码并可以修改这个类，只需要为这个类增加一个新方法\n\n如果不能修改这个类，但是这个类不是密封的，可以将这个类作为基类在派生类中添加一个新方法\n\n如果这个类是密封类\n\n用一个静态类，在静态类中写一个新方法给这个类使用（不推荐）\n\n使用拓展方法（推荐使用）\nclass Test\n&#123;\n    public Test(int val1, int val2)\n    &#123;\n        Val1 &#x3D; val1;\n        Val2 &#x3D; val2;\n    &#125;\n    public int Val1 &#123; get; set; &#125;\n    public int Val2 &#123; get; set; &#125;\n    \n    public int Sum() &#123; return Val1 + Val2; &#125;\n    \n&#125;\n    \nstatic class ExtendTest\n&#123;\n    &#x2F;&#x2F;为Test类添加一个拓展方法\n    public static double Average(this Test t1)\n    &#123;\n        return t1.Sum() &#x2F; 2.0f;\n    &#125;\n&#125;\n    \nclass Program\n&#123;\n    static void Main()\n    &#123;\n        Test t1 &#x3D; new Test(10, 20);\n        &#x2F;&#x2F;直接用该类调用该拓展方法\n        Console.WriteLine(t1.Average());\n    &#125;\n    \n&#125;\n\n\n拓展方法的要求\n\n声明拓展方法的类必须声明为static\n拓展方法本身必须声明为static\n拓展方法必须包含关键字this作为它的第一个参数类型，并在后面跟着它的拓展的类的名称\n\n\n\n命名约定表达式和运算符运算符运算符是一个符号\n\n将操作数作为输入（操作数是指作为运算符输入的数据元素）\n执行某个操作\n基于该操作返回一个值\n\n字面量字面量是源代码中键入的数字或字符串，表示一个指定类型的明确的，固定的值\n\nfloat字面量结尾要加上一个f\nfloat f1&#x3D;12.5f;\nbool有两个字面量：true和false\n\n对于引用类型变量，字面量null表示变量没有指向内存中的数据\n\n\n整数字面量整数字面量是最常用的字面量，它们被书写为十进制数字序列\n\n没有小数点\n\n带有可选的后缀，指明整数的类型\n234&#x2F;&#x2F;整型\n236L&#x2F;&#x2F;长整型\n236U&#x2F;&#x2F;无符号整型\n236UL&#x2F;&#x2F;无符号长整形\n整数类型字面量还可以写成十六进制（hex）形式，数字必须是十六进制数（0到F），且字符串必须以0x或0X开始\n\n整数类型字面量的第三种格式是二进制计法，所有数字必须是0或1，且以0b或者0B开始\n\n\n\n实数字面量C#有三种实数数据类型：float，double，decimal\n\n字符字面量字符字面量由两个单引号内的字符组成。字符字面量用于表示单个字符（a），非打印字符（\\n），或执行特殊任务的字符\n\n字符字面量的类型是char\n简单转义序列是一个反斜杠后面跟着单个字符\n十六进制转义序列是一个反斜杠后面跟着一个大写或小写的x，再跟着4个十六进制数字\nUnicode转义序列是一个反斜杠后面跟着一个大写或小写的u，再跟着4个十六进制数字\n\n\n\n字符串字面量字符串字面量使用双引号标记，不同于字符字面量使用单引号。\n有两种字符串字面量类型：\n\n常规字符串字面量\n常规字符串字面量由双引号内的字符序列组成\n可以包含字符，简单转义序列，十六进制和Unicode转义序列\n\n\n逐字字符串字面量\n逐字字符串的字面量的书写如同常规字符串字面量，以@字符为前缀\n逐字字符串字面量和常规字符串字面量的区别在于字符串中的转义序列不会被求值，再双引号中间的内容会全部被打印\n逐字字符串字面量的唯一例外是相邻的双引号组，会被解释成单个双引号字符\n\n\n\n\n\n\n\n\n\n\n注意\n​    编译器让相同的字符串字面量共享堆中同一内存位置以节约内存\n\n\n求值顺序\n优先级\n\n\n\n结合性\n左结合运算符从左至右求值\n右结合运算符从右至左求值\n除赋值运算符以外，其它二元运算符是左结合的\n赋值运算符和条件运算符是右结合的\n\n\n\n比较操作和相等性操作对于大多数引用类型来说，比较它们的相等性时，只比较它们的引用\n\n如果引用相等，说明指向相同的对象，那么相等性比较为true，这称为浅比较\nstring类型对象也是引用类型，但它的比较方式不同，比较字符串的相等性时，将比较它们的长度和内容\n如果两个字符串有相同的长度和内容（区分大小写），那么相等性为true即使占用不同的内存区域\n称为深比较\n\n\n\n\n\n\n\n\n\n\n注意\n​    一般引用类型比较的是引用，不是值\n\n\n递增和递减运算符\n\n前置递增和递减是先自增或自减后运算\n后置递增和递减是先运算后自增或自减\n\n条件逻辑运算符\n\n条件运算符使用“短路”模式操作，所以不要在第二个表达式中放置带副作用的表达式，因为可能不执行\n\n逻辑运算符\n用户定义的类型转换\n可以为自己的类和结构定义隐式转换和显示转换\n\nC#提供隐式转换和显示转换\n\n对于隐式转换，当决定在特定上下文中使用特定类型时，如有必要，编译器会自动执行转换\n对于显示转换，编译器只在使用显示转换运算符时才执行转换\n\n\n声明隐式转换的语法\n\n\n声明显示转换的语法只是将implicit替换成explicit\n\n\n运算符重载\n运算符重载只能用于类和结构\n一元运算符的重载方法带一个单独的class或struct类型的参数\n二元运算符的重载方法带两个参数，其中必须有一个是class或者struct类型\n声明必须同时使用public和static的修饰符\n运算符必须是要操作的类或者结构的成员\n\n&#x2F;&#x2F;重载加法运算符\npublic static Test operator +(Test t, int i)\n&#123;\n    Test t1&#x3D;new Test();\n    t1.val &#x3D; t1.val + i;\n    return t1;\n&#125;\n\n\n\n\n\n\n\n\n注意\n​    重载运算符应该符合运算符的直观含义\n\n\n\n运算符重载的限制\n运算符重载不能创建新运算符\n不能改变运算符语法\n不能重新定义运算符如何处理预定义类型\n不能改变运算符的优先级和结合性\n\n\n\n\n\n重载递增递减运算符\n前置\n在对象上执行递增递减代码\n返回对象\n\n\n后置\n如果对象是值类型，系统复制该对象，如果对象是引用类型，则引用会被复制\n在对象上执行递增或递减\n返回保存的操作数\n\n\n\n\n\n\n\n\n\n\n\n\n注意\n\n对于值类型参数，重载递增和递减运算符没有一点问题\n对于引用类型参数，重载递增递减运算符时\n重载前置运算符操作没有问题\n重载后置操作时，原始引用和引用副本指向相同的对象\n\n\n\n\n\ntypeof运算符typeof运算符返回作为其参数的任何类型的System.Type对象，通过该对象可以了解类的特征\n\n不能重载typeof运算符\ntypeof是一元运算符\nGetType方法也会调用typeof运算符\n\nnameof运算符nameof运算符返回一个表示传入参数的字符串\n语句C#中的语句跟C/C++中的语句非常类似\n\n语句是描述某个类型或让程序执行某个动作的源代码指令\n语句的类型\n声明语句：声明类型或变量\n嵌入语句：执行动作或管理控制流\n标签语句：控制跳转\n\n\n\n控制流语句\n条件执行语句\n\nif\n&#x2F;&#x2F;TestExpr必须计算成bool型值\n&#x2F;&#x2F;如果为true执行\nif(TestExpr)\n&#123;\n\t&#x2F;&#x2F;执行语句\n&#125;\n\n\n\nif…else\n&#x2F;&#x2F;如果TestExpr为true执行语句1，否则执行语句二\nif(TestExpr)\n&#123;\n\t&#x2F;&#x2F;执行语句1\n&#125;\nelse\n&#123;\n\t&#x2F;&#x2F;执行语句2\n&#125;\n\n\n\nswitch\nint test &#x3D; 11;\nswitch (test)\n&#123;\n    case 0:\n        Console.WriteLine(0);\n        break;\n    case 1:\n        Console.WriteLine(1);\n        break;\n    case 2:\n        Console.WriteLine(2);\n        break;\n    case 3:\n        Console.WriteLine(3);\n        break;\n    default:\n        Console.WriteLine(&quot;可选&quot;);\n        break;\n&#125;\n\n&#x2F;&#x2F;注意\n&#x2F;&#x2F;case后的表达式可以是任何类型的模式（C#7.0之后）\n&#x2F;&#x2F;C#中不可以执行一个switch段中的代码再直接执行下一个switch段，除非没有插入可执行语句\n&#x2F;&#x2F;case 1:\n&#x2F;&#x2F;case 2:\n\n\n循环语句重复执行一个代码片段\n\nwhile\n&#x2F;&#x2F;首先对TestExpr求值只要不为false就会一直执行循环体\nwhile(TestExpr)\n&#123;\n\t&#x2F;&#x2F;循环体\n&#125;\ndo\n&#x2F;&#x2F;do循环至少执行一次循环体\nint a &#x3D; 0;\ndo\n&#123;\n    Console.WriteLine(a++);\n&#125; while (a &lt;&#x3D; 10);&#x2F;&#x2F;注意此处有个分号\nfor\n&#x2F;&#x2F;在for循环的开始执行一次Initializar\n&#x2F;&#x2F;然后对TestExpr求值\n&#x2F;&#x2F;如果返回true执行Statement，接着执行IterationExpr\nfor(Initializar;TestExpr;IterationExpr)\n&#123;\n    &#x2F;&#x2F;Statement\n&#125;\nforeach\n\n\n\n跳转语句把控制流从一个代码片段改变到另一个代码片段中的指定语句\n\nbreak\n用在循环语句中，跳出最内层循环\n\n\ncontinue\n结束当前循环，执行下一次循环\n\n\nreturn\n将控制权返回到调用函数的成员，且能返回一个值\n\n\ngoto\n不推荐使用该语句，所以直接放弃\n\n\nthrow\n\n\n\n结构结构是程序员定义的数据类型，与类非常相似\n\n类是引用类型，结构是值类型\n\n结构是隐式密封的，所以不能从结构派生其它结构\n\n语法\nstruct StructName\n&#123;\n    &#x2F;&#x2F;成员\n&#125;c\n\n结构是值类型和所有值类型一样，结构类型变量含有自己的数据\n\n结构类型的变量不能为null\n两个结构变量不能引用同一对象\n\n\n对结构赋值\n把一个结构赋值给另一个结构，就是将一个结构的值复制给另一个结构，和复制类变量不同，复制类变量时只复制引用\n\n\n\n构造函数和析构函数\n结构可以有实例构造函数和静态构造函数，但不允许有析构函数\nC#语言隐式的为每个结构提供一个无参数的构造函数（该构造函数把结构的每个成员设置为该类型的默认值，值成员设置成默认值，引用成员设置成null）\n调用一个构造函数，包括无参构造函数，要使用new运算符\n对于每个结构都存在无参数的构造函数，且不能删除或重定义（结构不能声明无参构造函数）\n\n\n\n\n\n\n\n\n注意\n​    对于类，编译器只在没有声明其它构造函数时提供隐式的无参构造函数\n\n\n\n使用new运算符创建结构的实例\nstruct MyTestStruct\n&#123;\n    public int Test;\n&#125;\n\nclass Test\n&#123;\n    static void Main()\n    &#123;\n        MyTestStruct m1 &#x3D; new MyTestStruct();\n\n\n    &#125;\n&#125;\n不使用new运算符创建结构的实例\n\n必须在显示设置数据成员之后，才能使用它们的值\n在对所有数据成员赋值之后，才能调用结构的函数成员\n\n\n\n静态构造函数与类相似，结构的静态构造函数创建并初始化静态数据成员，且不能引用实例成员\n\n结构的静态构造函数遵从与类的静态构造函数一样的规则，但允许有不带参数的静态构造函数（实例构造函数必须要有形参）\n以下两种行为，会调用静态构造函数\n调用显式声明的构造函数\n引用结构的静态成员\n\n\n\n结构的构造函数和析构函数小结\n属性和字段初始化语句在声明结构时，不允许使用实例属性和字段初始化语句，但是静态属性和静态字段都可以在声明结构体时进行初始化\nstruct MyTestStruct\n&#123;\n    &#x2F;&#x2F;静态字段可以在声明时进行初始化\n    public static int B&#x3D;20;\n    &#x2F;&#x2F;静态属性可以在声明时进行初始化\n    public static int A &#123; get; set; &#125; &#x3D; 30;\n\n    &#x2F;&#x2F;不允许使用实例属性和字段初始化语句\n    &#x2F;&#x2F;public int Test&#x3D;30;\n&#125;\n\n结构是密封的\n结构总是隐式密封的，因此，不能从它们派生其它结构\n不能用于结构的修饰符\nprotected\nprotected internal\nabstruct\nsealed\nvirtual\n\n\n\n装箱和拆箱\n如同其它值类型数据，如果想将一个结构的实例作为引用类型对象，必须创建装箱的副本\n装箱的过程就是制作值类型变量的引用类型副本\n\n结构作为返回值和参数结构可以作为返回值和参数\n\n返回值：当作为返回值时，将创建它的副本并从函数成员返回\n值参数（形参列表）：当结构被用作值参数时，将创建实参结构的副本，该副本用于方法的执行\nref和out参数：如果把一个结构用作ref或out参数，传入方法的是该结构的引用，形参会影响实参\n\n结构的其它内容\n对结构的分配的开销比创建类实例小，使用结构代替类有时可以提高性能，但要注意装箱和拆箱的高昂代价\n预定义简单类型（int，short，long,…）在.NET和C#中被视作原始类型，但实际上在.NET中都实现为结构\n可以使用与声明分部\n\n枚举枚举是由程序员定义的类型\n\n与结构一样，枚举是值类型，因此是直接存储它们的数据，而不是分开存储成引用和数据\n\n枚举只有一种类型的成员：命名的整数值常量\n\n枚举成员声明列表使用逗号分隔，没有分号\nenum TrafficLight\n&#123;\n    Red,\n    Green,\n    Yello\n&#125;\n每个枚举成员都有一个底层整数类型，默认为int\n\n在默认情况下，编译器为第一个成员赋值为0，对后续每个成员赋的值都比前一个成员多1\n\n\n设置底层类型和显式值\n可以把冒号和类型名放在枚举名之后，这样可以使用int以外的整数类型\nenum TrafficLight : ulong\n&#123;\n    Red &#x3D; 100000000000,&#x2F;&#x2F;此处使用的是ulong类型\n    Green,\n    Yello\n&#125;\n\n位标记//请参考书籍\n关于枚举的更多内容\n枚举只有单一的成员类型：声明的成员常量\n\n不能对成员使用修饰符，它们都是隐式的具有和枚举相同的可访问性\n\n由于成员是静态的，即使没有该枚举类型的变量也可以访问\n\n.NET Enum类型（enum就是基于该类型）中的一些静态方法\n\nGetName方法以一个枚举类型对象和一个整数为参数，返回相应的枚举成员名称\nenum TrafficLight\n&#123;\n    Red,\n    Green,\n    Yello\n&#125;\n\nclass Test\n&#123;\n    static void Main()\n    &#123;\n        TrafficLight tra &#x3D; TrafficLight.Red;\n        Console.WriteLine(Enum.GetName(tra.GetType(), 1));\n    &#125;\n&#125;\nGetNames方法以一个枚举类型对象为参数，返回该枚举中所有成员的名称\nenum TrafficLight : ulong\n&#123;\n    Red &#x3D; 100000000000,&#x2F;&#x2F;此处使用的是ulong类型\n    Green,\n    Yello\n&#125;\n\nclass Test\n&#123;\n    static void Main()\n    &#123;\n        TrafficLight tra &#x3D; TrafficLight.Red;\n        foreach (var t in Enum.GetNames(tra.GetType()))\n        &#123;\n            Console.WriteLine(t);\n        &#125;\n    &#125;\n&#125;\n\n\n\n数组数组实际上是由一个变量名称表示的一组同类型的数据元素，每个元素通过数组名和方括号来访问\n定义\n元素：数组的独立数据项称作元素（数组的所有元素必须是相同的类型，或继承自相同的类型）\n秩/维度：数组的维度数可以为任何正数，数组的维度称为秩\n维度长度：数组的每一个维度有长度，是这个方向的位置个数\n数组长度：数组的所有维度中的元素总数称为数组的长度\n\n重要细节\n数组一旦创建，大小就是固定的。C#中不支持动态数组\n数组索引号是从0开始的，所以索引号范围是0~n-1\n\n数组的类型C#提供两种类型的数组\n\n一维数组可以认为是单行元素或元素向量\n多维数组是由主向量中的位置组成的，每个位置本身又是一个数组，称为子数组\n\n两种类型的多维数组\n矩形数组\n某个维度的所有子数组具有相同长度的多维数组\n不管有多少维度，总是使用一组方括号\n\n\n交错数组\n每一个子数组都是独立数组的多维数组\n可以有不同长度的子数组\n为数组的每一个维度使用一对方括号\n\n\n\nC#中的各种数组图示\n数组是对象\nRank返回数组维度数的属性\n\nLength返回数组的长度（数组中所有元素的个数）的属性\n\n数组是引用类型，数组对象本身总是在堆上\n\n数组的元素既可以是值类型也可以是引用类型\n\n如果存储的元素是值类型，数组被称作值类型对象\n如果存储的元素是引用类型，数组被称作引用类型数组\n\n\n\n\n声明一维数组或矩形数组\n一维数组\nint[] MyArr &#x3D; &#123; 1, 2, 3 &#125;;\n矩形数组\n\n可以使用任意多个秩说明符\n不能再数组类型区域中放数组维度长度\n数组声明后，维度数就是固定的，维度长度直到数组实例化时才能确定\n\nint[,] MyArr2 &#x3D; &#123; &#123; 1, 2 &#125;, &#123; 3, 4 &#125; &#125;;&#x2F;&#x2F;二维整型数组\nint[,,] MyArr2&#x3D;;&#x2F;&#x2F;三维整型数组\n\n\n\n\n\n\n\n\n注意\n​    C#中数组方括号放在基类型的后面，C/C++中数组的方括号放在变量名称后面\n\n\n交错数组\n本质是数组的数组\n\n数组协变当某个对象不是数组的基类型，也可以把它赋值给数组元素，这种属性叫做数组协变\n\n当数组是引用类型数组（数组的元素是引用类型）\n在赋值的对象类型和数组基类型之间有隐式转换或显式转换\n值类型数组没有协变\n\n数组继承的有用成员\nClone方法Clone方法为数组进行浅复制，它只创建数组本身的克隆，如果是引用类型数组，不会复制元素引用的对象\n\n克隆值类型数组会产生两个独立数组\n\n克隆引用类型数组会产生指向相同对象的两个数组\n\nClone方法返回object类型的引用，必须被强制转换成数组类型\nint[] TestArr &#x3D; &#123; 2, 3, 4 &#125;;\nint[] TestArr2 &#x3D; (int[])TestArr.Clone();\n\n比较数组类型\n数组与ref返回和ref局部变量static class MyTest\n&#123;\n    public static ref int GetNum(int[] Arr)\n    &#123;\n        return ref Arr[0];\n    &#125;\n\n&#125;\n\nclass Test\n&#123;\n\n    static void Main()\n    &#123;\n        int[] TestArr &#x3D; &#123; 2, 3, 4 &#125;;\n        int[] TestArr2 &#x3D; (int[])TestArr.Clone();\n        ref int cs &#x3D; ref MyTest.GetNum(TestArr);&#x2F;&#x2F;使用ref关键字\n        cs &#x3D; 1000;&#x2F;&#x2F;会改变数组中的值\n        Console.WriteLine(TestArr[0]);\n    &#125;\n&#125;\n\n委托什么是委托可以认为委托是持有一个或多个方法的对象（类似C++中的函数指针）\ndelegate void MyDel(int num);&#x2F;&#x2F;声明一个返回类型为void接受一个int值的委托类\n\nclass Test\n&#123;\n    void PrintLow(int num)\n    &#123;\n        Console.WriteLine(&quot;低:&quot;+num);\n    &#125;\n\n    void PrintHeight(int num)\n    &#123;\n        Console.WriteLine(&quot;高:&quot; + num);   \n    &#125;\n\n    static void Main()\n    &#123;\n        Test t1&#x3D;new Test();\n\n        &#x2F;&#x2F;声明委托变量\n        MyDel del;\n\n        &#x2F;&#x2F;生成一个0~99的随机数\n        Random rand &#x3D; new Random();\n        int num &#x3D; rand.Next(99);\n        del&#x3D;num&lt;&#x3D;50?new MyDel(t1.PrintLow):new MyDel(t1.PrintHeight);\n\n        del(num);\n    &#125;\n&#125;\n\n委托概述\n可以将delegate看作一个包含有序方法列表的对象，这些方法具有相同的签名和返回类型\n\n方法的列表称为调用列表\n\n委托持有的方法可以来自任何类或结构，只要满足下面两个要求\n\n委托的返回类型\n委托的签名（包括ref和out修饰符）\n\n\n调用列表中的方法可以是实例方法也可以是静态方法\n\n在调用委托的时候，会执行其调用列表中的所有方法\n\n\n\n声明委托类型委托是类型，与类一样，委托类型必须在被用来创建变量以及类型的对象之前声明。\n\n委托类型声明\n\n以delegate关键字开头\n\n没有方法主体\ndelegate void MyDel(int num);\n\n\n\n\n\n\n\n\n\n\n注意\n​    委托类型声明不需要声明在类内部，因为委托是类型声明\n\n\n创建委托对象委托是引用类型，因此有引用和对象。\n两种创建委托对象的方法\n\n第一种是使用带new运算符的对象创建表达式\nmyDel &#x3D; new MyDel(test.MyFunc);\n第二种快捷语法（与上面是等价的）\nmyDel &#x3D; test.MyFunc;\n\n给委托赋值由于委托是引用类型，可以通过给它赋值来改变包含在委托变量中引用，旧的委托对象被垃圾回收器回收\nTest test&#x3D; new Test();\nmyDel &#x3D; test.MyFunc;\n\n组合委托MyDel myDel, myDel2, myDel3;\nTest test&#x3D; new Test();\nmyDel &#x3D; test.MyFunc;\nmyDel2 &#x3D; test.MyFunc2;\nmyDel3 &#x3D; myDel + myDel2;&#x2F;&#x2F;组合委托\nmyDel3(2);\n\n为委托添加方法使用+=运算符\nMyDel myDel;\nTest test&#x3D; new Test();\nmyDel &#x3D; test.MyFunc;\n&#x2F;&#x2F;为委托添加方法\nmyDel +&#x3D; test.MyFunc2;\nmyDel(3);\n\n从委托移除方法使用-=运算符\nMyDel myDel;\nTest test&#x3D; new Test();\nmyDel &#x3D; test.MyFunc;\n&#x2F;&#x2F;为委托添加方法\nmyDel +&#x3D; test.MyFunc2;\n&#x2F;&#x2F;为委托移除方法\nmyDel -&#x3D; test.MyFunc2;\nmyDel(3);\n\n\n\n\n\n\n\n\n注意\n移除委托的注意事项：\n\n如果调用列表中的方法有多个实例，-=运算符将从列表最后开始搜索，移除第一个与方法匹配的实例\n试图删除委托中不存在的方法将无效\n试图调用空委托会抛出异常\n将委托与null进行比较可以判断是否为空委托\n\n\n\n调用委托\n可以通过两种方式调用委托，一种是像调用方法一样调用委托，一种是使用委托的Invoke方法\nMyDel myDel;\nTest test&#x3D; new Test();\nmyDel &#x3D; test.MyFunc;\n\n&#x2F;&#x2F;为委托添加方法\nmyDel +&#x3D; test.MyFunc2;\n\n&#x2F;&#x2F;普通调用\nmyDel(2);\n\n&#x2F;&#x2F;使用Invoke调用\nmyDel.Invoke(2);\n检查委托是否是空委托然后调用\nMyDel myDel;\nTest test&#x3D; new Test();\nmyDel &#x3D; test.MyFunc;\n\n&#x2F;&#x2F;为委托添加方法\nmyDel +&#x3D; test.MyFunc2;\n\nif (myDel !&#x3D; null)\n&#123;\n    &#x2F;&#x2F;普通调用\n    myDel(2);\n&#125;\n\n\n&#x2F;&#x2F;使用Invoke调用，用空条件运算符\nmyDel?.Invoke(2);\n\n调用带返回值的委托\n调用列表中最后一个方法返回的值就是委托调用返回的值\n调用列表中所有其它方法的返回值都会被忽略\n\n调用带引用参数的委托如果委托有引用参数，参数值会根据调用列表中的一个或多个方法的返回值而改变\n匿名方法是在实例化委托时内联声明的方法\n\n使用匿名方法的时机\n声明委托变量时作为初始化表达式\n组合委托时在赋值语句的右边\n为委托增加事件时在赋值语句的右边\n\n\n匿名方法的语法\ndelegate关键字\n参数列表\n语句块\n\n\n\ndelegate(参数列表)&#123;语句块&#125;\n\ndelegate void MyFunc(int num);\n\nclass Test\n&#123;\n    static void Main()\n    &#123;\n        &#x2F;&#x2F;匿名方法\n        MyFunc TestA &#x3D; delegate (int num) &#123; Console.WriteLine(num); &#125;;\n        TestA(10);\n    &#125;\n&#125;\n\nLambda可完全代替匿名方法\ndelegate void MyFunc(int num);\n\nclass Test\n&#123;\n    static void Main()\n    &#123;\n    \t&#x2F;&#x2F;Lambda表达式\n        MyFunc TestA &#x3D; (x) &#x3D;&gt; &#123; Console.WriteLine(x); &#125;;\n        TestA(10);\n    &#125;\n&#125;\n\n\nLambda表达式参数列表中的参数必须在参数数量，类型，位置上与委托匹配\n表达式的参数列表中的参数不一定需要包含类型。除非委托有ref或out关键字（必须注明）\n如果只有一个参数，并且是隐式类型的，则两端的圆括号可以省略，否则必须有括号\n如果没有参数，必须使用一组空的圆括号\n\n事件发布者和订阅者当一个特定的程序事件发生时，程序的其它部分可以得到该事件已经发生的通知，发布者/订阅者可以满足该需求。\n\n发布者：发布某个事件的类或者结构，其它类可以在该事件发生时得到通知\n订阅者：注册并在事件发生时得到通知的类或结构\n事件处理程序：由订阅者注册到事件的方法，在发布者触发事件时执行，事件处理程序方法可以定义在事件所在的类或结构中，也可以定义在不同的类或结构中\n触发事件：当事件被触发时，所有注册到它的方法都会被依次调用\n\n声明事件\n事件声明在一个类中，关键字event\n声明为public，其他类和结构就可以在上面注册事件处理\n不能使用对象常见表达式（new表达式）创建它的对象\n需要委托类型的名称，任何附加到事件的处理程序都必须与委托类型的签名和返回类型匹配\n\ndelegate void MyFunc(int num);\n\nclass Test\n&#123;\n    &#x2F;&#x2F;声明事件\n    public event MyFunc eventTest;\n\n    static void Main()\n    &#123;\n        \n    &#125;\n&#125;\n\n事件是成员事件和方法，属性一样，事件是类或结构的成员\n\n由于事件是成员\n所以不能在一段可执行代码中声明事件\n必须声明在类或者结构中，和其他成员一样\n\n\n事件成员被隐式自动初始化成null\n\n订阅事件\n使用+=运算符来为事件添加事件处理程序\n事件处理程序的规范可以是以下任意一种\n实例方法的名称\n静态方法的名称\n匿名方法\nLambda表达式\n\n\n\n触发事件事件成员本身只是保存了需要被调用的事件处理程序，如果事件不被触发，什么都不会发生\n\n在触发事件之前和null进行比较，来查看事件是否包含事件处理程序\n触发事件的语法和调用方法一样\n使用事件名称，后面跟着参数列表（包含在圆括号中）\n参数列表必须与事件的委托类型相匹配\n\n\n\n完整示例using System;\n\nnamespace EventLearn\n&#123;\n    &#x2F;&#x2F;声明一个委托\n    delegate void TestDelegate();\n\n    &#x2F;&#x2F;发布者\n    class Promulgator\n    &#123;\n        &#x2F;&#x2F;创建事件并发布\n        public event TestDelegate EventTestDelegate;\n\n        &#x2F;&#x2F;触发事件\n        public void TriggerEvent()\n        &#123;\n            EventTestDelegate();\n        &#125;\n    &#125;\n\n    &#x2F;&#x2F;订阅者\n    class Subscriber\n    &#123;\n        public Subscriber(Promulgator promulgator)\n        &#123;\n            promulgator.EventTestDelegate +&#x3D; Func;&#x2F;&#x2F;订阅事件\n        &#125;\n\n        public void Func()\n        &#123;\n            Console.WriteLine(&quot;事件处理程序&quot;);\n        &#125;\n    &#125;\n\n    class MyMain\n    &#123;\n        static void Main()\n        &#123;\n            Promulgator p1&#x3D;new Promulgator();\n            Subscriber s1&#x3D;new Subscriber(p1);\n            Subscriber s2 &#x3D; new Subscriber(p1);\n            p1.TriggerEvent();\n        &#125;\n    &#125;\n&#125;\n\n接口什么是接口接口是指定一组函数成员而不实现它们的引用类型，只能类和结构来实现接口\nIComparable接口\n数组中的排序方法（Sort）依赖于该接口，用户自定义的类要想使用排序必须实现该接口\n\n负数值：如果当前对象小于参数对象\n正数值：如果当前对象大于参数对象\n零：如果两个对象在比较时相等\n\n\n\n声明接口\n接口声明不能包含以下成员\n数据成员\n静态成员\n\n\n接口声明只能包含如下类型的非静态成员函数的声明\n方法\n属性\n事件\n索引器\n\n\n这些函数成员的声明不能包含任何实现代码，必须使用分号代替每一个成员声明的主体。\n按照惯例，接口名称必须从大写的I开始\n与类和结构一样，接口声明也可以分隔成分部接口声明\n接口的访问性和接口成员的访问性之间的一些区别\n接口声明可以有任何访问修饰符\n接口成员是隐式public的，不允许有任何修饰访问符（包括public）\n\n\n\n实现接口只有类和结构可以实现接口\n\n在基类列表中包括接口名称\n\n为每个接口成员提供实现\n\n如果类实现了接口，它必须实现接口的所有成员\n\n如果类派生自基类并实现接口，基类列表中的基类名称必须放在所有接口之前\npublic interface ITest\n&#123;\n    \n&#125;\npublic interface ITest2\n&#123;\n\n&#125;\n\npublic interface ITest3\n&#123;\n\n&#125;\n\nclass TestBase\n&#123;\n    \n&#125;\n\n&#x2F;&#x2F;基类名称必须在所有接口名称之前\nclass SubTest : TestBase, ITest, ITest2, ITest3\n&#123;\n    \n&#125;\n\n\n接口是引用类型using System;\n\nnamespace EventLearn\n&#123;\n    interface IPrint\n    &#123;\n        &#x2F;&#x2F;接口默认访问级别是public\n        void MyPrint();\n    &#125;\n\n    class Test : IPrint\n    &#123;\n        public void MyPrint()\n        &#123;\n            Console.WriteLine(&quot;Test调用接口函数&quot;);\n        &#125;\n    &#125;\n\n    class Test2 : IPrint\n    &#123;\n        public void MyPrint()\n        &#123;\n            Console.WriteLine(&quot;Test2调用接口函数&quot;);\n        &#125;\n    &#125;\n\n    class Program\n    &#123;\n        static void Main()\n        &#123;\n            Test test &#x3D; new Test();\n            Test2 test2 &#x3D; new Test2();\n\t\t\t\n            IPrint p1 &#x3D; test;\n            p1.MyPrint();\n\n            p1 &#x3D; test2;\n            p1.MyPrint();\n        &#125;\n    &#125;\n&#125;\n\n接口和as运算符如果将类对象引用强制转换为类未实现的接口引用，强制转换操作会抛出异常，使用as运算符可以避免抛出异常。\n\nas运算符如果类实现了接口，表达式返回指向接口的引用\nas运算符如果类没有实现接口，表达式返回null不是抛出异常\n\nTest test &#x3D; new Test();\nTest2 test2 &#x3D; new Test2();\n\nIPrint p1 &#x3D; test as IPrint;\nif (p1 !&#x3D; null)\n&#123;\n    p1.MyPrint();\n&#125;\n\np1 &#x3D; test2 as IPrint;\nif (p1 !&#x3D; null)\n&#123;\n    p1.MyPrint();\n&#125;\n\n实现具有重复成员的接口如果类实现多个接口，且其中一些接口成员具有相同签名和返回类型，那么类可以实现单个成员来满足所有包含重复成员的接口\nusing System;\n\nnamespace EventLearn\n&#123;\n    interface IPrint\n    &#123;\n        void MyPrint();\n    &#125;\n\n    interface IPrint2\n    &#123;\n        void MyPrint();\n    &#125;\n\n    class Test : IPrint,IPrint2\n    &#123;\n        &#x2F;&#x2F;同时实现IPrint,IPrint2的接口实现\n        public void MyPrint()\n        &#123;\n            Console.WriteLine(&quot;Test调用接口函数&quot;);\n        &#125;\n    &#125;\n\n\n    class Program\n    &#123;\n        static void Main()\n        &#123;\n            Test test &#x3D; new Test();\n            IPrint p1 &#x3D; test;\n            IPrint p2 &#x3D; test;\n            p1.MyPrint();\n            p2.MyPrint();          \n        &#125;\n    &#125;\n&#125;\n\n派生成员作为接口实现using System;\n\nnamespace EventLearn\n&#123;\n    interface IPrint\n    &#123;\n        void MyPrint();\n    &#125;\n\n    interface IPrint2\n    &#123;\n        void MyPrint();\n    &#125;\n\n    class Base\n    &#123;\n        &#x2F;&#x2F;基类有和子类对应的接口实现\n        public void MyPrint()\n        &#123;\n            Console.WriteLine(&quot;接口实现&quot;);\n        &#125;\n    &#125;\n\n    class Sub : Base, IPrint, IPrint2\n    &#123;\n        \n    &#125;\n\n    class Program\n    &#123;\n        static void Main()\n        &#123;\n            Sub test &#x3D; new Sub();\n            IPrint p1 &#x3D; test;\n            IPrint p2 &#x3D; test;\n            p1.MyPrint();\n            p2.MyPrint();          \n        &#125;\n    &#125;\n&#125;\n\n显式接口成员实现\n使用限定接口名称来声明，由接口名称和成员名称以及它们中间的点分隔符号构成\n显式接口成员实现只可以通过指向接口的引用来访问\n\nusing System;\n\nnamespace EventLearn\n&#123;\n    interface IPrint\n    &#123;\n        void MyPrint();\n    &#125;\n\n    interface IPrint2\n    &#123;\n        void MyPrint();\n    &#125;\n\n    class Base\n    &#123;\n        &#x2F;&#x2F;基类有和子类对应的接口实现\n        public void MyPrint()\n        &#123;\n            Console.WriteLine(&quot;接口实现&quot;);\n        &#125;\n    &#125;\n\n    class Sub : Base, IPrint, IPrint2\n    &#123;\n\n        &#x2F;&#x2F;显示接口成员实现\n        void IPrint.MyPrint()\n        &#123;\n            Console.WriteLine(&quot;IPrint接口&quot;);\n        &#125;\n        &#x2F;&#x2F;显示接口成员实现\n        void IPrint2.MyPrint()\n        &#123;\n            Console.WriteLine(&quot;IPrint2接口&quot;);\n        &#125;\n    &#125;\n\n    class Program\n    &#123;\n        static void Main()\n        &#123;\n            Sub test &#x3D; new Sub();\n            IPrint p1 &#x3D; test;\n            IPrint2 p2 &#x3D; test;\n            p1.MyPrint();\n            p2.MyPrint();          \n        &#125;\n    &#125;\n&#125;\n\n接口可以继承接口接口可以从一个或多个接口继承而来\n\n类在基类列表中只能有一个类名，而接口可以在基接口列表中有任意多个接口\n列表中的接口本身可以继承其它接口\n结果接口包含它声明的所有成员和基接口的所有成员\n\n\n\nusing System;\n\nnamespace EventLearn\n&#123;\n    interface ITest1\n    &#123;\n        void PrintName();\n    &#125;\n\n    interface ITest2\n    &#123;\n        void PrintAge();\n    &#125;\n\n    &#x2F;&#x2F;接口继承了接口\n    interface ITest : ITest1, ITest2\n    &#123;\n        \n    &#125;\n\n    class MyTestClass : ITest\n    &#123;\n        public void PrintAge()\n        &#123;\n            Console.WriteLine(&quot;25&quot;);\n        &#125;\n\n        public void PrintName()\n        &#123;\n            Console.WriteLine(&quot;cBao&quot;);\n        &#125;\n    &#125;\n\n    class Program\n    &#123;\n        static void Main()\n        &#123;\n            MyTestClass myTestClass &#x3D; new MyTestClass();\n            myTestClass.PrintAge();\n            myTestClass.PrintName();\n        &#125;\n    &#125;\n&#125;\n\n转换什么是转换\n转换（conversion）是接受一个类型的值并将它作为另一个类型的等价值的过程\n转换过的值和源值一样，但其类型为目标类型\n\n隐式转换\n有些类型的转换不会丢失数据或精度，语言会自动做这些转换，这就叫做隐式转换\n从位数更少的源类型转换为位数更多的目标类型时，目标中多出来的位需要用0或1填充\n当从更小的无符号类型转换为更大的无符号类型时，目标类型多出来的最高位都以0进行填充，叫做零扩展\n\n显式转换和强制转换强制转换表达式(可能会丢失数据)\ndouble testDouble &#x3D; 19.4;\n&#x2F;&#x2F;强制类型转换\nint testInt &#x3D; (int)testDouble;\nConsole.WriteLine(testInt);\n\n数字的转换\n任何数字类型都能转换为其它数字类型\n\n\n\n隐式数字转换\n\n占据较少位的数字类型可以隐式转换为占据较多位的数字类型\n\n\n\n\n溢出检测上下文\n对于整数类型，C#允许我们选择运行时是否应该在进行类型转换时检测结果溢出\n\n语法\nchecked(表达式);&#x2F;&#x2F;如果溢出将抛出OverflowException异常\nunchecked(表达式);&#x2F;&#x2F;忽略溢出\n\nusing System;\n\nnamespace EventLearn\n&#123;\n    class Program\n    &#123;\n        static void Main()\n        &#123;\n            int testInt &#x3D; 1000;\n            byte b1 &#x3D; checked((byte)testInt);&#x2F;&#x2F;抛出溢出异常\n            byte b2 &#x3D; unchecked((byte)testInt);&#x2F;&#x2F;忽略溢出\n            Console.WriteLine(b1);\n        &#125;\n    &#125;\n&#125;\n\n引用转换引用类型对象由内存中的两部分组成：引用和数据\n\n由引用保存的那部分信息是它指向的数据类型\n引用转换接受源引用并返回一个指向堆中同一位置的引用，但是把引用“标记”为其它类型\n\n隐式引用转换\n所有引用类型可以被隐式转换为object类型\n任何接口可以隐式转换为它继承的接口\n类可以隐式转换为\n继承链中的任何类\n实现的任何接口\n\n\n\n显式引用转换\n从object到任何引用类型的转换\n从基类到派生自它的类的转换\n\n装箱转换包括值类型在内的所有C#类型都派生自object类型\n装箱是一种隐式转换，接受值类型的值，根据这个值在堆上创建一个完整的引用类型对象并返回对象的引用\nusing System;\n\nnamespace EventLearn\n&#123;\n\n    class Program\n    &#123;\n        static void Main()\n        &#123;\n            int i &#x3D; 100;\n            &#x2F;&#x2F;装箱操作\n            object oi &#x3D; i;\n            Console.WriteLine(oi);\n        &#125;\n    &#125;\n&#125;\n\n\n装箱是创建副本\n装箱是值类型到引用类型的隐式转换\n\n拆箱转换拆箱是把装箱后的对象转换回值类型的过程\n\n拆箱是显式转换\n\n系统在把值拆箱成ValueTypeT时执行如下步骤\n\n检测到要拆箱的对象实际是ValueTypeT的装箱值\n把对象的复制到变量\n\n\n拆箱示例代码\nusing System;\n\nnamespace EventLearn\n&#123;\n\n    class Program\n    &#123;\n        static void Main()\n        &#123;\n            int testi &#x3D; 20;\n            &#x2F;&#x2F;装箱\n            object oi &#x3D; testi;\n            oi &#x3D; 30;\n            &#x2F;&#x2F;拆箱\n            int testi2 &#x3D; (int)oi;\n            Console.WriteLine($&quot;testi:&#123;testi&#125;\\noi:&#123;oi&#125;\\ntesti2:&#123;testi2&#125;&quot;);\n        &#125;\n    &#125;\n&#125;\n尝试将值拆箱成非原始类型时会抛出InvalidCastException异常\n\n\n用户自定义的转换可以为类和结构定义隐式和显式转换\n\n除了implicit和explicit关键字外，隐式转换和显式转换的声明语法是一样的\n\n需要public和static修饰符\n\n示例代码\nusing System;\n\nnamespace EventLearn\n&#123;\n    class Test\n    &#123;\n        int i &#x3D; 30;\n        &#x2F;&#x2F;public static implicit&#x2F;explicit operator 目标类型 (源)\n        public static implicit operator int(Test ts)\n        &#123;\n            return ts.i;\n        &#125;\n    &#125;\n\n    class Program\n    &#123;\n        static void Main()\n        &#123;\n            Test ts &#x3D; new Test();\n            int i &#x3D; (int)ts;\n            Console.WriteLine(i);\n        &#125;\n    &#125;\n&#125;\n\n用户自定义转换的约束\n只可以为类和结构定义用户自定义转换\n不能重定义标准隐式或显式转换\n对于源类型S和目标类型T，如下命题为真\nS和T必须是不同类型\nS和T不能通过继承关联，S不能派生自T，T也不能派生自S\nS和T都不能是接口类型或object类型\n转换运算符必须是S或T的成员\n\n\n对于相同的源类型和目标类型，不能声明两种转换，一个是隐式转换一个是显式转换\n\nis运算符使用is运算符来检查转换是否会成功完成，避免盲目尝试转换\n语法：Expr is TargetType\n如果Expr可以通过以下方式成功转换为目标类型，则运算符返回true\n\n引用转换\n装箱转换\n拆箱转换\n\nis运算符只可以用于上面三种方式的转换，不能用于用户自定义转换\nusing System;\n\nnamespace EventLearn\n&#123;\n    class Base\n    &#123;\n        \n    &#125;\n\n    class Sub : Base\n    &#123; &#125;\n    class Program\n    &#123;\n        static void Main()\n        &#123;\n            Sub s1 &#x3D; new Sub();\n            if (s1 is Base)\n            &#123;\n                Console.WriteLine(&quot;可以成功转换&quot;);\n            &#125;\n        &#125;\n    &#125;\n&#125;\n\nas运算符as运算符和强制转换运算符类似，只是不抛出异常，如果转换失败返回null\n语法：Expr as TargetType\n\nExpr是源表达式\nTargetType是目标类型，必须是引用类型\n\nusing System;\n\nnamespace EventLearn\n&#123;\n    class Base\n    &#123;\n        public int Test &#x3D; 100;\n    &#125;\n\n    class Sub : Base\n    &#123; &#125;\n    class Program\n    &#123;\n        static void Main()\n        &#123;\n            Sub sub &#x3D; new Sub();\n            Base b1 &#x3D; sub as Base;\n            if (b1 !&#x3D; null)\n            &#123;\n                Console.WriteLine(b1.Test);\n            &#125;\n        &#125;\n    &#125;\n&#125;\n\n泛型C#提供了5中泛型：类，结构，接口，委托和方法\n泛型类声明泛型类\n在类名之后放置一组尖括号&lt;&gt;\n\n在尖括号中用逗号分隔的占位符来表示需要提供的类型，叫做类型参数\n\n在泛型类声明的主体中使用类型参数来表示替代类型\n\n示例\nclass Test&lt;T1, T2&gt;\n&#123;\n    public T1 t1;\n    public T2 t2;\n&#125;\n\n创建构造类型Test&lt;int,float&gt; test &#x3D; new Test&lt;int,float&gt;();\n\n类型参数的约束可以额外提供一些信息让编译器知道参数可以接受哪些类型（约束）\nWhere子句约束使用where子句列出\n\n每一个有约束的类型参数都有自己的where子句\n\n如果形参有多个约束，在where子句中使用逗号分隔\n\n语法\nwhere 类型参数:约束列表\n注意事项\n\n在类型参数列表的关闭尖括号之后列出\n不使用逗号或其它分隔符分隔\n可以以任何次序列出\nwhere是上下文关键字，所以可以在其它上下文中使用\n\n\n\nclass Test&lt;T1, T2&gt; where T1 : IComparable where T2 : IComparable\n&#123;\n    \n&#125;\n\n约束类型和次序\nwhere子句可以以任何次序列出。然而where子句中的约束必须有特定的顺序\n\n最多只能有一个主约束，而且必须放在第一位\n可以有任意多的接口名称约束\n如果存在构造函数约束，则必须放在最后\n\n\n泛型方法泛型方法是成员，不是类型，泛型方法可以在泛型和非泛型以及结构和接口中声明\n声明泛型方法泛型方法具有类型参数列表和可选的约束\n\n泛型方法有两个参数列表\n\n封闭在圆括号内的方法参数列表\n封闭在尖括号内的类型参数列表\n\n\n声明泛型方法\n\n在方法名称之后和方法参数列表之前放置类型参数列表\n在方法参数列表后放置可选的约束子句\n\npublic void TestFunc&lt;T1, T2&gt;(T1 p, T2 p2) where T1 : class where T2 : struct\n&#123;\n    \n&#125;\n\n\n\n\n\n\n\n\n注意\n​        类型参数列表在方法名称之后，在方法参数列表之前\n\n\n调用泛型方法调用泛型方法时，需要提供类型实参\nProgram p1 &#x3D; new Program();\np1.TestFunc&lt;string, int&gt;(&quot;tset&quot;, 20);\n&#x2F;&#x2F;由于编译器可以从方法参数中推断类型参数，可以省略类型参数和调用中的尖括号\np1.TestFunc(&quot;test&quot;, 20);\n\n拓展方法和泛型类泛型类的拓展方法\n\n必须声明为static\n\n必须是静态类的成员\n\n第一个参数类型中必须有关键字this，后面是拓展的泛型类的名字\n\n示例\nusing System;\n\nnamespace EventLearn\n&#123;\n    class Test&lt;T&gt;\n    &#123;\n        public T Value &#123; get; set; &#125;\n    &#125;\n\n    static class TestEx\n    &#123;\n        &#x2F;&#x2F;声明一个拓展方法\n        public static void PrintfFunc&lt;T&gt;(this Test&lt;T&gt; test)\n        &#123;\n            Console.WriteLine(test.Value);\n        &#125;\n    &#125;\n\n    class Program\n    &#123;\n      \n\n        static void Main()\n        &#123;\n            Test&lt;int&gt; test &#x3D; new Test&lt;int&gt;();\n            test.Value &#x3D; 100;\n            &#x2F;&#x2F;调用拓展方法\n            test.PrintfFunc();\n        &#125;\n    &#125;\n&#125;\n\n泛型结构与泛型类相似，泛型结构可以有类型参数和约束。泛型结构的规则和条件与泛型是一样的。\n泛型委托\n要声明泛型委托，在委托名称之后，委托参数列表之前的尖括号中放置类型参数列表\n\n泛型委托有两个参数列表：委托形参列表和类型参数列表\n\n类型参数的范围包括\n\n返回类型\n形参列表\n约束子句\n\n\n示例\nusing System;\n\nnamespace EventLearn\n&#123;\n    &#x2F;&#x2F;声明一个泛型委托\n    delegate R MyDelegate&lt;R, T&gt;(T value);\n\n    class Program\n    &#123;    \n        static void Main()\n        &#123;\n            Program p&#x3D;new Program();\n            var dele &#x3D; new MyDelegate&lt;int, string&gt;(p.Func);\n            dele(&quot;33333&quot;);\n        &#125;\n\n        public int Func(string value)\n        &#123;\n            Console.WriteLine(value);\n            return 0;\n        &#125;\n    &#125;\n&#125;\n\n泛型接口泛型接口允许编写形参和接口成员返回类型是泛型类型参数的接口\nusing System;\n\nnamespace EventLearn\n&#123;\n    &#x2F;&#x2F;声明一个泛型接口\n    interface ITest&lt;T&gt;\n    &#123;\n        void PrintfInterface(T value);\n    &#125;\n\n    class TestClass : ITest&lt;int&gt;,ITest&lt;string&gt;\n    &#123;\n        public void PrintfInterface(int value)\n        &#123;\n            Console.WriteLine($&quot;int类型:&#123;value&#125;&quot;);\n        &#125;\n\n        public void PrintfInterface(string value)\n        &#123;\n            Console.WriteLine($&quot;string类型:&#123;value&#125;&quot;);\n        &#125;\n    &#125;\n\n\n    class Program\n    &#123;    \n        static void Main()\n        &#123;\n            TestClass testClass &#x3D; new TestClass();\n            testClass.PrintfInterface(20);\n            testClass.PrintfInterface(&quot;sss&quot;);\n        &#125;\n    &#125;\n&#125;\n\n协变和逆变协变协变允许你将一个派生类类型（子类）的泛型实例赋值给基类类型（父类）的泛型实例。在C#中， 协变仅适用于泛型接口和委托 ，并且只有在返回类型中使用泛型参数时才能支持协变。要在泛型接口或委托中启用协变，需要使用out关键字。\npublic interface ICovariant&lt;out T&gt;\n&#123;\n    T Get();\n&#125;\n\npublic class CovariantClass&lt;T&gt; : ICovariant&lt;T&gt;\n&#123;\n    public T Get()\n    &#123;\n        &#x2F;&#x2F; ...\n    &#125;\n&#125;\n\nICovariant&lt;Animal&gt; animals &#x3D; new CovariantClass&lt;Animal&gt;();\nICovariant&lt;Mammal&gt; mammals &#x3D; new CovariantClass&lt;Mammal&gt;();\nICovariant&lt;Cat&gt; cats &#x3D; new CovariantClass&lt;Cat&gt;();\n\nanimals &#x3D; mammals; &#x2F;&#x2F; 协变允许这样的赋值\nanimals &#x3D; cats;    &#x2F;&#x2F; 协变允许这样的赋值\n\n逆变逆变允许你将基类类型（父类）的泛型实例赋值给派生类类型（子类）的泛型实例。在C#中， 逆变仅适用于泛型接口和委托 ，并且只有在参数类型中使用泛型参数时才能支持逆变。要在泛型接口或委托中启用逆变，需要使用in关键字。\npublic interface IContravariant&lt;in T&gt;\n&#123;\n    void Set(T item);\n&#125;\n\npublic class ContravariantClass&lt;T&gt; : IContravariant&lt;T&gt;\n&#123;\n    public void Set(T item)\n    &#123;\n        &#x2F;&#x2F; ...\n    &#125;\n&#125;\n\nIContravariant&lt;Cat&gt; cats &#x3D; new ContravariantClass&lt;Cat&gt;();\nIContravariant&lt;Mammal&gt; mammals &#x3D; new ContravariantClass&lt;Mammal&gt;();\nIContravariant&lt;Animal&gt; animals &#x3D; new ContravariantClass&lt;Animal&gt;();\n\ncats &#x3D; mammals; &#x2F;&#x2F; 逆变允许这样的赋值\ncats &#x3D; animals; &#x2F;&#x2F; 逆变允许这样的赋值\n\n\n\n\n\n\n\n\n注意\n​        请注意，协变和逆变仅适用于引用类型，不适用于值类型。这是因为值类型的变量直接包含其数据，而引用类型的变量只是对内存中实际对象的引用。\n\n\n","slug":"CSharp图解教程第5版","date":"2023-03-12T05:00:17.000Z","categories_index":"C#","tags_index":"C#","author_index":"cBao"},{"id":"321e20a64de3485e0958a3f7db00142f","title":"UE中的网络同步RPC","content":"UE网络中的服务器在哪！\n在UE中存在服务器和客户端重合，创建房间的客户端同时具备服务器特性\n\nUE中服务器和客户端中对象的关系\n在服务器端，所有的角色（Actor）都是Authority（权威的）\n在客户端眼，除了自己控制的角色外，其他的所有角色都是Simulated proxy（模拟代理）\n在UE网络框架中，Actor是促成网络同步的重要对象\n\nActor的更新方式\n属性更新（针对成员变量）具有及时性，随属性变换而进行通知。属性更新不变化不消耗带宽，但会消耗CPU进行监听\nRPC（针对函数），由用户进行调用\n\nUE网络框架对象归属分类\n\n\nServer Only（仅存在于服务器上）\nServer &amp; Clients（存在于服务器和所有客户端）\nServer &amp; Owning Client（仅存在于服务器和自身客户端）\nOwning Client Only（仅存在于自己客户端）\n\n\n\nAGameMode\nAGameState\nAPlayerController\nAHUD\n\n\n\nAPlayerState\n\nUMG Widget\n\n\n\nAPawn\n\n\n\n\n角色类型标记\n每个Actor中都存在两个属性用来裁定当前Actor在服务器/客户端上的身份类型，分为Role和RemoteRole\n在蓝图中为LocalRole和RemoteRole\nGet Local Role：判断当前角色在本地端身份类型\nGet Remote Role：判断当前角色在远端身份类型（当是客户端时，远端为服务端，当是服务端时，远端是客户端）\n\n网络角色三种类型\nSimulated：由服务器进行数据发送，当前终端进行操控模拟。操控来源于服务器，Simulate对象无法执行RPC函数\nAutonomous：由当前终端实例进行操控。操控来源于真人\nAuthority：服务器端存在标记，表明当前Actor存在于服务器\n\nRPC远端调用，在本机上调用函数，但在其他机器上远程执行的函数。\nRPC执行的三种形式\n服务端执行（Server） ：由客户端调用，在服务器端执行\n客户端执行（Client）： 由服务器端调用，在客户端执行\n所有终端执行（Multicast）  ：由服务器端调用，在所有终端执行\n\nRPC调用注意事项\n必须从 Actor 上调用\n\nActor 必须能被复制（Replicates=true）\n\n如果 RPC 是从服务器调用并在客户端上执行，则只有实际拥有这个 Actor 的客户端才会执行函数\n\n如果 RPC 是从客户端调用并在服务器上执行，客户端就必须拥有调用 RPC 的 Actor。\n\n从服务器上调用RPC\n\n\n\nActor所有权\n未复制\nNetMulticast\nServer\nClient\n\n\n\nClient-Owned Actor\n在服务器上运行\n在服务器和所有客户端上运行\n在服务器上运行\n在 actor  的所属客户端上运行\n\n\nServer-owned actor\n在服务器上运行\n在服务器和所有客户端上运行\n在服务器上运行\n在服务器上运行\n\n\nUnowned actor\n在服务器上运行\n在服务器和所有客户端上运行\n在服务器上运行\n在服务器上运行\n\n\n\n从客户端上调用RPC\n\n\n\nActor所有权\n未复制\nNetMulticast\nServer\nClient\n\n\n\nOwned by invoking client（当前终端所有权）\n在执行调用的客户端上运行\n在执行调用的客户端上运行\n在服务器上运行\n在执行调用的客户端上运行\n\n\nOwned by a different client  （其他终端所有权）\n在执行调用的客户端上运行\n在执行调用的客户端上运行\n丢弃\n在执行调用的客户端上运行\n\n\nServer-owned actor\n在执行调用的客户端上运行\n在执行调用的客户端上运行\n丢弃\n在执行调用的客户端上运行\n\n\nUnowned actor\n在执行调用的客户端上运行\n在执行调用的客户端上运行\n丢弃\n在执行调用的客户端上运行\n\n\n\n\n蓝图中判断服务器和客户端\n\nAuthority：服务器\nRemote：客户端\n\nRPC执行的三种形式\n服务端执行（Server）：在客户端调用，在服务端执行\n客户端执行（Client）:在服务端调用，在客户端执行\n所有终端执行（Multicast）：只能在服务端调用，在所有终端执行\n\n设置Actor所有权\n蓝图中使用Set Owner节点在服务器上获得Actor所有权\n\n\n\n数据同步\nActor必须满足在网络上被复制,设置的参数需要开启复制\n参数的修正必须在服务器端修改,才可以在网络上同步\n蓝图参数同步的两种方式：\nReplicated，同步数据，但没有通知，无法直接通过参数修改驱动逻辑\n•RepNotify，同步数据，并生成通知函数，进行更新通知（向所有终端通知，满足相关性）\n\n\n\n","slug":"UE中的网络同步RPC","date":"2022-08-15T07:32:03.000Z","categories_index":"UnrealEngine","tags_index":"网络同步RPC","author_index":"cBao"},{"id":"fa2dad943cb3925ed47cb72cd3308d02","title":"UE中的文件API","content":"检查文件夹是否存在//文件路径\nFString Dir=FPaths::ProjectDir()/TEXT(\"cBao\");\n//检查文件是否存在\nIFileManager::Get().DirectoryExists(*Dir)\n\n创建文件夹IFileManager::Get().MakeDirectory(*Dir);\n\n检查文件是否存在//注意是/=\nFString Dir=FPaths::ProjectDir()/TEXT(\"cBao\");\nDir /=TEXT(\"cBao.txt\");\n\n//检查文件是否存在\nIFileManager::Get().FileExists(*Dir);\n//创建文件\n\nFFileHelper::SaveStringToFile(TEXT(\"cBao\"),*Dir);\n\n删除文件FString Dir=FPaths::ProjectDir()/TEXT(\"cBao/cc/cc2/cBao.txt\");\n//一般用于删除单个特定文件\nIFileManager::Get().Delete(*Dir);\n\nFString Dir2=FPaths::ProjectDir()/TEXT(\"cBao\");\n//一般用于删除整个文件夹\nIFileManager::Get().DeleteDirectory(*Dir2,true,true);\n\n拷贝文件//不带拷贝进度的拷贝\nFString Src=FPaths::ProjectDir()/TEXT(\"cBao/cc.pdf\");\nFString Dest=FPaths::ProjectDir()/TEXT(\"cBao/cc2.pdf\");\nIFileManager::Get().Copy(*Dest,*Src);\n\n//带拷贝进度的拷贝\n//继承FCopyProgress抽象类,用来显示拷贝进度\nstruct MyProgress:public FCopyProgress\n&#123;\n    //Fraction为拷贝进度百分比\n\tFORCEINLINE virtual bool Poll( float Fraction ) override\n\t&#123;\n\t\tGEngine->AddOnScreenDebugMessage(-1,10.f,FColor::Blue,FString::SanitizeFloat(Fraction));\n\t\treturn true;\n\t&#125;\n&#125;;\nFString Src2=FPaths::ProjectDir()/TEXT(\"cBao/cc.pdf\");\nFString Dest2=FPaths::ProjectDir()/TEXT(\"cBao/cc2.pdf\");\n//创建进度结构\nMyProgress cBaoProgress;\nIFileManager::Get().Copy(*Dest2,*Src2,true,false,false,&amp;cBaoProgress);\n\n文件信息//文件信息(创建日期，访问日期，修改日期，文件大小，是否是文件夹，是否只读，是否有效)\nFFileStatData FileState=IFileManager::Get().GetStatData(*Src);\n\n查找文件//文件路径\nFString Dir=FPaths::ProjectDir()/TEXT(\"cBao\");\n//检查路径是否存在\nif (IFileManager::Get().DirectoryExists(*Dir))\n&#123;\n    //保存文件名称\n\tTArray&lt;FString> NameArray;\n    //查找文件操作 *代表通配符\n\tIFileManager::Get().FindFiles(NameArray,*Dir,TEXT(\"*\"));\n\tfor(auto &amp;Temp:NameArray)\n\t&#123;\n\t\tGEngine->AddOnScreenDebugMessage(-1,10.f,FColor::Blue,Temp);\n\t&#125;\n&#125;\n\n递归查找指定目录下的文件路径//文件路径\nFString Dir=FPaths::ProjectDir()/TEXT(\"cBao\");\n//检查路径是否存在\nif (IFileManager::Get().DirectoryExists(*Dir))\n&#123;\n    //保存文件路径\n\tTArray&lt;FString> PathNameArray;\n    //查找文件操作 *代表通配符 第一个true代表查找文件,第二个false代表忽略文件夹\n\tIFileManager::Get().FindFilesRecursive(PathNameArray,*Dir,TEXT(\"*\"),true,false);\n\tfor (auto&amp; Name:PathNameArray)\n\t&#123;\n\t\tGEngine->AddOnScreenDebugMessage(-1,10.f,FColor::Red,Name);\n\t&#125;\n\n&#125;\n\n","slug":"UE中的文件操作","date":"2022-08-05T05:58:47.000Z","categories_index":"UnrealEngine","tags_index":"文件操作","author_index":"cBao"},{"id":"62bbf97645975b25a08d1c093027a65e","title":"UE中内存操作","content":"分配内存// C\nuint8* Ptr_C=(uint8*)malloc(sizeof(uint8)*1024);\n\t\n// C++\nuint8* Ptr_CPlus=new uint8[1024];\n\n// UEC++\nuint8* Ptr_UnrealCPlus=(uint8*)FMemory::Malloc(sizeof(uint8)*1024);\n\n\n重新分配内存// C/C++\nPtr_C=(uint8*)realloc(Ptr_C,sizeof(uint8)*2048);\n\t\n// UEC++\nFMemory::Realloc(Ptr_UnrealCPlus,sizeof(uint8)*2048);\n\n获得分配的内存大小int32 i = FMemory::GetAllocSize(Ptr_UnrealCPlus);\n\n\n\n\n\n\n\n\n特别注意\n只能获得 FMemory::Malloc() 分配的内存大小，否则会产生崩溃\n\n拷贝char Date1[1024]=\"Hello,World\";\nchar Date2[1024];\n// C/C++\nmemcpy(Date2,Date1,strlen(Date1));\n\n// UEC++\nFMemory::Memcpy(Date2,Date1,strlen(Date1));\n\n移动内存char Date1[1024]=\"Hello,World\";\nchar Date2[1024];\n// C/C++\nmemmove(Date2,Date1,strlen(Date1));\n\n// UEC++\nFMemory::Memmove(Date2,Date1,strlen(Date1));\n\n比较// C/C++\nchar DateComp[1024]=\"cBao2\";\nchar DateComp_2[1024]=\"cBao\";\nint32 Size=memcmp(DateComp,DateComp_2,sizeof(uint8)*5);\n\n// UEC++\nint32 Size2 = FMemory::Memcmp(DateComp,DateComp_2,sizeof(uint8)*5);\n\n\n\n\n\n\n\n\n注意\n当 DateComp&lt;DateComp_2 时返回值&lt;0\n当 DateComp=DateComp_2 时返回值=0\n当 DateComp&gt;DateComp_2 时返回值&gt;0\n\n\n交换char DateComp[1024]=\"cBao2\";\nchar DateComp_2[1024]=\"cBao\";\nFMemory::Memswap(DateComp,DateComp_2,sizeof(uint8)*5)\n\n\n\n\n\n\n\n\n注意\n仅UEC++中存在该API\n\n\n初始化方式//原生C\nmemset(Ptr_C,0,sizeof(uint8)*1024);\nmemset(Ptr_CPlus,0,sizeof(uint8)*1024);\n\n//C++中\nuint8* Ptr_CPlus2=new uint8[]&#123;1,23,4,5,5&#125;;\n\t\n//UEC++\nZeroMemory(Ptr_C,sizeof(uint8)*1024);\nZeroMemory(Ptr_CPlus,sizeof(uint8)*1024);\nFMemory::Memset(Ptr_UnrealCPlus,0,sizeof(uint8)*1024);\nFMemory::Memzero(Ptr_UnrealCPlus,sizeof(uint8)*1024);\n//在申请时就进行初始化\nuint8* Ptr_UnrealC=(uint8*)FMemory::MallocZeroed(sizeof(uint8)*1024);\n\n清除//C\nfree(Ptr_C);\n\t\n//C++中\ndelete[](Ptr_CPlus);\ndelete[](Ptr_CPlus2);\n\n//UEC++中\nFMemory::Free(Ptr_UnrealCPlus);\n\n\n\n\n\n\n\n\n特别注意\nFMemory::Free() 容易造成引擎崩溃\n\n\n","slug":"UE内存操作","date":"2022-08-04T07:41:08.000Z","categories_index":"UnrealEngine","tags_index":"内存操作","author_index":"cBao"},{"id":"ae911ea8c615446cd5e6fd02771c3f77","title":"Json","content":"JSON 语法规则\n数据在键/值对中\n数据由逗号 , 分隔\n使用斜杆来转义 \\ 字符\n大括号 {} 保存对象\n中括号 [] 保存数组，数组可以包含多个对象\n\nJSON 键值对JSON 数据的书写格式是：\n\"name\" : \"cBao\"\n\nJSON 值可以是\n数字（整数或浮点数）\n\"age\":30\n字符串（在双引号中）\n\"name\":\"cBao\"\n逻辑值（true 或 false）\n\"IsDeath\":false\n数组（在中括号中）\n&#123;\n    \"Info\": [\n    &#123; \"age1\":30 , \"name1\":\"cBao\" &#125;, \n    &#123; \"age2\":30 , \"name2\":\"cBao\" &#125;, \n    &#123; \"age3\":30 , \"name3\":\"cBao\" &#125;,\n    ]\n&#125;\n对象（在大括号中）\n&#123;\n  \"Object\":&#123;\n      \"age\":30, \n    \"name\":\"cBao\" \n  &#125;  \n&#125;\nnull\n\"runoob\":null\n\nUE5中将结构体转换成Json示例\n.Build.cs文件需要加入\nPrivateDependencyModuleNames.Add(\"Json\");\n.h文件\n// Fill out your copyright notice in the Description page of Project Settings.\n\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"Kismet/BlueprintFunctionLibrary.h\"\n#include \"StructToJson.generated.h\"\n\nUSTRUCT(BlueprintType)\nstruct FMyInfo\n&#123;\n\tGENERATED_BODY()\n\n\tUPROPERTY(EditAnywhere,BlueprintReadWrite)\n\tFString Name;\n\tUPROPERTY(EditAnywhere,BlueprintReadWrite)\n\tint32 Age;\n&#125;;\n\n\nUSTRUCT(BlueprintType)\nstruct FMyStruct\n&#123;\n\tGENERATED_BODY()\n\t\n\tUPROPERTY(EditAnywhere,BlueprintReadWrite)\n\tFString Name;\n\t\n\tUPROPERTY(EditAnywhere,BlueprintReadWrite)\n\tint32 Age;\n\t\n\tUPROPERTY(EditAnywhere,BlueprintReadWrite)\n\tbool Gender;\n\t\n\tUPROPERTY(EditAnywhere,BlueprintReadWrite)\n\tfloat Weight;\n\n\tUPROPERTY(EditAnywhere,BlueprintReadWrite)\n\tFMyInfo Info;\n\t\n\tUPROPERTY(EditAnywhere,BlueprintReadWrite)\n\tTArray&lt;FMyInfo> Array;\n&#125;;\n\n/**\n * \n */\nUCLASS()\nclass UE_ADVANCE_API UStructToJson : public UBlueprintFunctionLibrary\n&#123;\n\tGENERATED_BODY()\n\n\tUFUNCTION(BlueprintCallable,Category=cBao)\n\tstatic FString StructToString(const FMyStruct&amp; s1);\n\n&#125;;\n\n.cpp文件\n// Fill out your copyright notice in the Description page of Project Settings.\n\n\n#include \"StructToJson.h\"\n\nFString UStructToJson::StructToString(const FMyStruct&amp; s1)\n&#123;\n\t\tFString JsonString;\n\t\t//UE中的Json工程模式\n\t\tTSharedPtr&lt;TJsonWriter&lt;TCHAR,TCondensedJsonPrintPolicy&lt;TCHAR>>> JsonWriter=TJsonWriterFactory&lt;TCHAR,TCondensedJsonPrintPolicy&lt;TCHAR>>::Create(&amp;JsonString);\n\t\tJsonWriter->WriteObjectStart();\n\t\t&#123;\n\t\t\tJsonWriter->WriteValue(TEXT(\"Name\"),s1.Name);\n\t\t\tJsonWriter->WriteValue(TEXT(\"Age\"),s1.Age);\n\t\t\tJsonWriter->WriteValue(TEXT(\"Gender\"),s1.Gender);\n\t\t\tJsonWriter->WriteValue(TEXT(\"Weight\"),s1.Weight);\n\t\t\tJsonWriter->WriteObjectStart(TEXT(\"Info\"));\n\t\t\t&#123;\n\t\t\t\tJsonWriter->WriteValue(TEXT(\"Name\"),s1.Info.Name);\n\t\t\t\tJsonWriter->WriteValue(TEXT(\"Age\"),s1.Info.Age);\n\t\t\t&#125;\n\t\t\tJsonWriter->WriteObjectEnd();\n\t\t\tJsonWriter->WriteArrayStart(TEXT(\"Array\"));\n\t\t\t&#123;\n\t\t\t\tfor (auto &amp; s:s1.Array)\n\t\t\t\t&#123;\n\t\t\t\t\tJsonWriter->WriteObjectStart();\n\t\t\t\t\t&#123;\n\t\t\t\t\t\tJsonWriter->WriteValue(TEXT(\"Name\"),s.Name);\n\t\t\t\t\t\tJsonWriter->WriteValue(TEXT(\"Age\"),s.Age);\n\t\t\t\t\t&#125;\n\t\t\t\t\tJsonWriter->WriteObjectEnd();\n\t\t\t\t&#125;\n\t\t\t&#125;\n\t\t\tJsonWriter->WriteArrayEnd();\n\t\t&#125;\n\t\tJsonWriter->WriteObjectEnd();\n\t\tJsonWriter->Close();\n\t\treturn JsonString;\n&#125;\n\n蓝图中配置输出\n&#123;\"Name\":\"cBao\",\"Age\":24,\"Gender\":true,\"Weight\":2222,\"Info\":&#123;\"Name\":\"ccc\",\"Age\":32324&#125;,\"Array\":[&#123;\"Name\":\"cdd\",\"Age\":22131&#125;,&#123;\"Name\":\"dsaf\",\"Age\":232&#125;]&#125;\n\nUE5中将Json转换成结构体示例\n.h文件\n//FString反序列化成结构体\nUFUNCTION(BlueprintCallable,Category=cBao)\nstatic bool StructFromFString(const FString&amp; s1,FMyStruct&amp; MyStruct);\n.cpp文件\nbool UStructToJson::StructFromFString(const FString&amp; s1, FMyStruct&amp; MyStruct)\n&#123;\n\tTSharedRef&lt;TJsonReader&lt;>> JsonReader=TJsonReaderFactory&lt;>::Create(s1);\n\tTSharedPtr&lt;FJsonObject> ReadRoot;\n\n\tif (FJsonSerializer::Deserialize(JsonReader,ReadRoot))\n\t&#123;\n\t\t//获得String数据\n\t\tMyStruct.Name=ReadRoot->GetStringField(TEXT(\"Name\"));\n\t\t\n\t\t//获得int数据\n\t\tMyStruct.Age=ReadRoot->GetIntegerField(TEXT(\"Age\"));\n\t\t\n\t\t//获得bool数据\n\t\tMyStruct.Gender=ReadRoot->GetBoolField(TEXT(\"Gender\"));\n\t\t\n\t\t//获得浮点数据\n\t\tMyStruct.Weight=ReadRoot->GetNumberField(TEXT(\"Weight\"));\n\t\t\n\t\t//获得对象数据\n\t\tTSharedPtr&lt;FJsonObject> TestRoot=ReadRoot->GetObjectField(TEXT(\"Info\"));\n\t\t&#123;\n\t\t\tMyStruct.Info.Name=TestRoot->GetStringField(TEXT(\"Name\"));\n\t\t\tMyStruct.Info.Age=TestRoot->GetIntegerField(TEXT(\"Age\"));\n\t\t&#125;\n\n\t\t//获得数组数据\n\t\tTArray&lt;TSharedPtr&lt;FJsonValue>>TempArray=ReadRoot->GetArrayField(TEXT(\"Array\"));\n\t\tfor (auto &amp;i:TempArray)\n\t\t&#123;\n\t\t\tTSharedPtr&lt;FJsonObject> JsonObj = i->AsObject();\n\t\t\tFMyInfo TempInfo;\n\t\t\tTempInfo.Name=JsonObj->GetStringField(TEXT(\"Name\"));\n\t\t\tTempInfo.Age=JsonObj->GetIntegerField(TEXT(\"Age\"));\n\t\t\tMyStruct.Array.Add(TempInfo);\n\t\t&#125;\n\t\treturn true;\n\t&#125;\n\t\n\treturn false;\n&#125;\n\n","slug":"Json_UnrealEngine","date":"2022-08-02T06:17:49.000Z","categories_index":"Json","tags_index":"Json","author_index":"cBao"},{"id":"32edd7bc4a69fac72c5e2e1809026b07","title":"UE串口通信","content":"sdasfsa\nUE串口通信\n.h文件\n#pragma once\n\n#define FC_DTRDSR       0x01\n#define FC_RTSCTS       0x02\n#define FC_XONXOFF      0x04\n#define ASCII_BEL       0x07\n#define ASCII_BS        0x08\n#define ASCII_LF        0x0A\n#define ASCII_CR        0x0D\n#define ASCII_XON       0x11\n#define ASCII_XOFF      0x13\n\n\n#include \"CoreMinimal.h\"\n#include \"UObject/NoExportTypes.h\"\n#include \"Serial.generated.h\"\n\n/**\n * \n */\n\n // Forward declaration\ntypedef struct _OVERLAPPED OVERLAPPED;\n\nUENUM(BlueprintType, Category = \"UE4Duino\")\nenum class ELineEnd : uint8\n&#123;\n\trn\tUMETA(DisplayName = \"\\r\\n\"),\n\tn\tUMETA(DisplayName = \"\\n\"),\n\tr\tUMETA(DisplayName = \"\\r\"),\n\tnr\tUMETA(DisplayName = \"\\n\\r\")\n&#125;;\n\nUCLASS(BlueprintType, Category = \"UE4Duino\", meta = (Keywords = \"com arduino serial\"))\nclass INKPROJECTION_API USerial : public UObject\n&#123;\n\tGENERATED_BODY()\npublic:\n\t/** Determines the line ending used when writing lines to serial port with PrintLine. */\n\tUPROPERTY(BlueprintReadWrite, Category = \"UE4Duino | String\")\n\t\tELineEnd WriteLineEnd;\n\npublic:\n\tUSerial();\n\t~USerial();\n\n\t/**\n\t * Open a serial port and return the created Serial instance.\n\t * Don't forget to close the port before exiting the game.\n\t *\n\t * @param bOpened If the serial port was successfully opened.\n\t * @param Port The serial port to open.\n\t * @param BaudRate BaudRate to open the serial port with.\n\t * @return A Serial instance to work with the opened port.\n\t */\n\tUFUNCTION(BlueprintCallable, meta = (DisplayName = \"Open Serial Port\"), Category = \"UE4Duino\", meta = (Keywords = \"com arduino serial start\"))\n\t\tstatic USerial* OpenComPort(bool&amp; bOpened, int32 Port = 1, int32 BaudRate = 9600);\n\n\t/**\n\t * Utility function to convert 4 bytes into an Integer. If the input array's length is not 4, returns 0.\n\t *\n\t * @param Bytes A byte array with 4 values representing the integer in little-endian format.\n\t * @return The final integer value or 0 for an invalid array.\n\t */\n\tUFUNCTION(BlueprintPure, meta = (DisplayName = \"Bytes to Int\"), Category = \"UE4Duino\", meta = (Keywords = \"cast concatenate group bit bitwise\"))\n\t\tstatic int32 BytesToInt(TArray&lt;uint8> Bytes);\n\n\t/**\n\t * Utility function to get the 4 bytes that make an integer.\n\t *\n\t * @param Int The integer value to be converted.\n\t * @return A byte array containing the 4 bytes that make the integer, starting from the least significant one (little endian).\n\t */\n\tUFUNCTION(BlueprintPure, meta = (DisplayName = \"Int to Bytes\"), Category = \"UE4Duino\", meta = (Keywords = \"cast separate bit bitwise\"))\n\t\tstatic TArray&lt;uint8> IntToBytes(const int32&amp; Int);\n\n\t/**\n\t * Utility function to convert 4 bytes into a float. If the input array's length is not 4, returns 0.0.\n\t *\n\t * @param Bytes A byte array with 4 values representing the float in IEEE 754 standard format.\n\t * @return The final float value or 0.0 for an invalid array.\n\t */\n\tUFUNCTION(BlueprintPure, meta = (DisplayName = \"Bytes to Float\"), Category = \"UE4Duino\", meta = (Keywords = \"cast concatenate group bit bitwise\"))\n\t\tstatic float BytesToFloat(TArray&lt;uint8> Bytes);\n\n\t/**\n\t * Utility function to get the 4 bytes that make a float.\n\t *\n\t * @param Float The float value to be converted.\n\t * @return A byte array containing the 4 bytes that make the float, in IEEE 754 standard format.\n\t */\n\tUFUNCTION(BlueprintPure, meta = (DisplayName = \"Float to Bytes\"), Category = \"UE4Duino\", meta = (Keywords = \"cast separate bit bitwise\"))\n\t\tstatic TArray&lt;uint8> FloatToBytes(const float&amp; Float);\n\n\t/**\n\t * Open a serial port. Don't forget to close the port before exiting the game.\n\t * If this Serial instance has already an opened port,\n\t * return false and doesn't change the opened port number.\n\t *\n\t * @param Port The serial port to open.\n\t * @param BaudRate BaudRate to open the serial port with.\n\t * @return If the serial port was successfully opened.\n\t */\n\tUFUNCTION(BlueprintCallable, meta = (DisplayName = \"Open Port\"), Category = \"UE4Duino\", meta = (Keywords = \"com start init\"))\n\t\tbool Open(int32 Port = 2, int32 BaudRate = 9600);\n\t/**\n\t * Close and end the communication with the serial port. If not open, do nothing.\n\t */\n\tUFUNCTION(BlueprintCallable, meta = (DisplayName = \"Close Port\"), Category = \"UE4Duino\", meta = (Keywords = \"com end finish release\"))\n\t\tvoid Close();\n\n\t/**\n\t * Will read characters from Serial port until \\0 (null char) is found or there are no\n\t * characters left to read.\n\t *\n\t * @param bSuccess If there was anything to read.\n\t * @return The read string\n\t */\n\tUFUNCTION(BlueprintCallable, meta = (DisplayName = \"Read String\", keywords = \"get read receive string words text characters\"), Category = \"UE4Duino\")\n\t\tFString ReadString(bool&amp; bSuccess);\n\t/**\n\t * Will read characters from Serial port until \\r\\n (Arduino println line end) is found.\n\t *\n\t * @param bSuccess If there was anything to read.\n\t * @return The read string\n\t */\n\tUFUNCTION(BlueprintCallable, meta = (DisplayName = \"Read Line\", keywords = \"get read receive string words text characters\"), Category = \"UE4Duino\")\n\t\tFString Readln(bool&amp; bSuccess);\n\t/**\n\t * Reads the string until a specific char is met.\n\t * The Terminator char won't be included in the result string.\n\t */\n\t //UFUNCTION(BlueprintCallable, meta = (DisplayName = \"Read String Until\", keywords = \"get read receive string words text characters\"), Category = \"UE4Duino\")\n\tFString ReadStringUntil(bool&amp; bSuccess, uint8 Terminator);\n\t/**\n\t * Reads a float from the serial port (sent as 4 bytes).\n\t * @param bSuccess True if there were 4 bytes to read.\n\t * @return The read value\n\t */\n\tUFUNCTION(BlueprintCallable, meta = (DisplayName = \"Read a Float\", keywords = \"get read receive\"), Category = \"UE4Duino\")\n\t\tfloat ReadFloat(bool&amp; bSuccess);\n\t/**\n\t * Reads an integer from the serial port (sent as 4 bytes).\n\t * @param bSuccess True if there were 4 bytes to read.\n\t * @return The read value\n\t */\n\tUFUNCTION(BlueprintCallable, meta = (DisplayName = \"Read an Int\", keywords = \"get read receive integer\"), Category = \"UE4Duino\")\n\t\tint32 ReadInt(bool&amp; bSuccess);\n\t/**\n\t * Reads a byte from the serial port.\n\t * @param bSuccess True if there were 4 bytes to read.\n\t * @return The read value\n\t */\n\tUFUNCTION(BlueprintCallable, meta = (DisplayName = \"Read a Byte\", keywords = \"get read receive\"), Category = \"UE4Duino\")\n\t\tuint8 ReadByte(bool&amp; bSuccess);\n\t/**\n\t * Reads up to Limit bytes from the serial port. If there are less than Limit,\n\t * reads all of them and return True.\n\t * @param bSuccess True if there was at least 1 byte to read.\n\t * @return An array containing the read bytes\n\t */\n\tUFUNCTION(BlueprintCallable, meta = (DisplayName = \"Read Bytes\", keywords = \"get read receive\"), Category = \"UE4Duino\")\n\t\tTArray&lt;uint8> ReadBytes(int32 Limit = 256);\n\n\t/**\n\t * Writes a string without newline to the serial port.\n\t * @param String The string to be sent to the serial port.\n\t * @return True if the string was sent.\n\t */\n\tUFUNCTION(BlueprintCallable, meta = (DisplayName = \"Print\", keywords = \"send write string words text characters\"), Category = \"UE4Duino\")\n\t\tbool Print(FString String);\n\t/**\n\t * Writes a string with newline (\\n) appended at the end to the serial port.\n\t * @param String The string to be sent to the serial port.\n\t * @return True if the string was sent.\n\t */\n\tUFUNCTION(BlueprintCallable, meta = (DisplayName = \"Print Line\", keywords = \"send write string words text characters\"), Category = \"UE4Duino\")\n\t\tbool Println(FString String);\n\t/**\n\t * Writes a float value to the serial port as 4 bytes.\n\t * @param Value The value to be sent to the serial port.\n\t * @return True if the bytes were sent.\n\t */\n\tUFUNCTION(BlueprintCallable, meta = (DisplayName = \"Write a Float\", keywords = \"send\"), Category = \"UE4Duino\")\n\t\tbool WriteFloat(float Value);\n\t/**\n\t * Writes an integer value to the serial port as 4 bytes.\n\t * @param Value The value to be sent to the serial port.\n\t * @return True if the bytes were sent.\n\t */\n\tUFUNCTION(BlueprintCallable, meta = (DisplayName = \"Write an Int\", keywords = \"integer send\"), Category = \"UE4Duino\")\n\t\tbool WriteInt(int32 Value);\n\t/**\n\t * Writes a byte value to the serial port.\n\t * @param Value The value to be sent to the serial port.\n\t * @return True if the byte was sent.\n\t */\n\tUFUNCTION(BlueprintCallable, meta = (DisplayName = \"Write a Byte\", keywords = \"send\"), Category = \"UE4Duino\")\n\t\tbool WriteByte(uint8 Value);\n\t/**\n\t * Writes a byte array as a sequence of bytes to the serial port.\n\t * @param Buffer The byte array to be sent to the serial port.\n\t * @return True if the bytes were sent.\n\t */\n\tUFUNCTION(BlueprintCallable, meta = (DisplayName = \"Write Bytes\", keywords = \"send\"), Category = \"UE4Duino\")\n\t\tbool WriteBytes(TArray&lt;uint8> Buffer);\n\n\t/** Clean the serial port by reading everything left to be read. */\n\tUFUNCTION(BlueprintCallable, meta = (DisplayName = \"Flush Port\"), Category = \"UE4Duino\")\n\t\tvoid Flush();\n\n\t/**\n\t * Check if the serial port is open.\n\t * @return True if the serial port is open.\n\t */\n\tUFUNCTION(BlueprintPure, meta = (DisplayName = \"Is Port Open\"), Category = \"UE4Duino\")\n\t\tbool IsOpened() &#123; return m_hIDComDev != NULL; &#125;\n\n\t/**\n\t * Read the number of the serial port selected for this Serial instance.\n\t * @return The number of the serial port.\n\t */\n\tUFUNCTION(BlueprintPure, meta = (DisplayName = \"Get Port Number\"), Category = \"UE4Duino\")\n\t\tint32 GetPort() &#123; return m_Port; &#125;\n\n\t/**\n\t * Read the selected BaudRate for this Serial instance.\n\t * @return The baud rate.\n\t */\n\tUFUNCTION(BlueprintPure, meta = (DisplayName = \"Get Baud Rate\"), Category = \"UE4Duino\")\n\t\tint32 GetBaud() &#123; return m_Baud; &#125;\n\n\t/**\n\t * Converts a LineEnd enum value to String.\n\t * @param LineEnd LineEnd enum value.\n\t * @return The LineEnd value in string format.\n\t */\n\tUFUNCTION(BlueprintCallable, meta = (DisplayName = \"Line End to String\", keywords = \"cast convert\"), Category = \"UE4Duino\")\n\t\tFString LineEndToStr(ELineEnd LineEnd);\n\nprotected:\n\tvoid* m_hIDComDev;\n\n\t// These are pointers to be able to use OVERLAPPED with forward declaration\n\tOVERLAPPED* m_OverlappedRead;\n\tOVERLAPPED* m_OverlappedWrite;\n\n\tint32 m_Port;\n\tint32 m_Baud;\n&#125;;\n\n.cpp文件\n// Fill out your copyright notice in the Description page of Project Settings.\n\n\n#include \"Serial.h\"\n\n#include \"Windows/AllowWindowsPlatformTypes.h\"\n#include \"Windows/MinWindows.h\"\n#include \"Windows/HideWindowsPlatformTypes.h\"\n#include&lt;iostream>\n#include&lt;cmath>\n#include&lt;cstring>\n\nusing namespace std;\n#define BOOL2bool(B) B == 0 ? false : true\n\nUSerial* USerial::OpenComPort(bool&amp; bOpened, int32 Port, int32 BaudRate)\n&#123;\n\tUSerial* Serial = NewObject&lt;USerial>();\n\tbOpened = Serial->Open(Port, BaudRate);\n\treturn Serial;\n&#125;\n\nint32 USerial::BytesToInt(TArray&lt;uint8> Bytes)\n&#123;\n\tif (Bytes.Num() != 4)\n\t&#123;\n\t\treturn 0;\n\t&#125;\n\n\treturn *reinterpret_cast&lt;int32*>(Bytes.GetData());\n&#125;\n\nTArray&lt;uint8> USerial::IntToBytes(const int32&amp; Int)\n&#123;\n\tTArray&lt;uint8> Bytes;\n\tBytes.Append(reinterpret_cast&lt;const uint8*>(&amp;Int), 4);\n\treturn Bytes;\n&#125;\n\nfloat USerial::BytesToFloat(TArray&lt;uint8> Bytes)\n&#123;\n\tif (Bytes.Num() != 4)\n\t&#123;\n\t\treturn 0;\n\t&#125;\n\n\treturn *reinterpret_cast&lt;float*>(Bytes.GetData());\n&#125;\n\nTArray&lt;uint8> USerial::FloatToBytes(const float&amp; Float)\n&#123;\n\tTArray&lt;uint8> Bytes;\n\tBytes.Append(reinterpret_cast&lt;const uint8*>(&amp;Float), 4);\n\treturn Bytes;\n&#125;\n\nUSerial::USerial()\n\t: WriteLineEnd(ELineEnd::n)\n\t, m_hIDComDev(nullptr)\n\t, m_OverlappedRead(nullptr)\n\t, m_OverlappedWrite(nullptr)\n\t, m_Port(-1)\n\t, m_Baud(-1)\n&#123;\n\t// Allocate the OVERLAPPED structs\n\tm_OverlappedRead = new OVERLAPPED();\n\tm_OverlappedWrite = new OVERLAPPED();\n\n\tFMemory::Memset(m_OverlappedRead, 0, sizeof(OVERLAPPED));\n\tFMemory::Memset(m_OverlappedWrite, 0, sizeof(OVERLAPPED));\n&#125;\n\nUSerial::~USerial()\n&#123;\n\tClose();\n\n\t// Delete allocated OVERLAPPED structs\n\tdelete m_OverlappedRead;\n\tdelete m_OverlappedWrite;\n&#125;\n\nbool USerial::Open(int32 nPort, int32 nBaud)\n&#123;\n\tif (nPort &lt; 0)\n\t&#123;\n\t\tUE_LOG(LogTemp, Error, TEXT(\"Invalid port number: %d\"), nPort);\n\t\treturn false;\n\t&#125;\n\tif (m_hIDComDev)\n\t&#123;\n\t\tUE_LOG(LogTemp, Warning, TEXT(\"Trying to use opened Serial instance to open a new one. \"\n\t\t\t\"Current open instance port: %d | Port tried: %d\"), m_Port, nPort);\n\t\treturn false;\n\t&#125;\n\n\tFString szPort;\n\tif (nPort &lt; 10)\n\t\tszPort = FString::Printf(TEXT(\"COM%d\"), nPort);\n\telse\n\t\tszPort = FString::Printf(TEXT(\"\\\\\\\\.\\\\COM%d\"), nPort);\n\tDCB dcb;\n\n\tm_hIDComDev = CreateFile(*szPort, GENERIC_READ | GENERIC_WRITE, 0, NULL, OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL | FILE_FLAG_OVERLAPPED, NULL);\n\tif (m_hIDComDev == NULL)\n\t&#123;\n\t\tunsigned long dwError = GetLastError();\n\t\tUE_LOG(LogTemp, Error, TEXT(\"Failed to open port COM%d (%s). Error: %08X\"), nPort, *szPort, dwError);\n\t\treturn false;\n\t&#125;\n\n\tFMemory::Memset(m_OverlappedRead, 0, sizeof(OVERLAPPED));\n\tFMemory::Memset(m_OverlappedWrite, 0, sizeof(OVERLAPPED));\n\n\tCOMMTIMEOUTS CommTimeOuts;\n\t//CommTimeOuts.ReadIntervalTimeout = 10;\n\tCommTimeOuts.ReadIntervalTimeout = 0xFFFFFFFF;\n\tCommTimeOuts.ReadTotalTimeoutMultiplier = 0;\n\tCommTimeOuts.ReadTotalTimeoutConstant = 0;\n\tCommTimeOuts.WriteTotalTimeoutMultiplier = 0;\n\tCommTimeOuts.WriteTotalTimeoutConstant = 10;\n\tSetCommTimeouts(m_hIDComDev, &amp;CommTimeOuts);\n\n\tm_OverlappedRead->hEvent = CreateEvent(NULL, true, false, NULL);\n\tm_OverlappedWrite->hEvent = CreateEvent(NULL, true, false, NULL);\n\n\tdcb.DCBlength = sizeof(DCB);\n\tGetCommState(m_hIDComDev, &amp;dcb);\n\tdcb.BaudRate = nBaud;\n\tdcb.ByteSize = 8;\n\n\tif (!SetCommState(m_hIDComDev, &amp;dcb) ||\n\t\t!SetupComm(m_hIDComDev, 10000, 10000) ||\n\t\tm_OverlappedRead->hEvent == NULL ||\n\t\tm_OverlappedWrite->hEvent == NULL)\n\t&#123;\n\t\tunsigned long dwError = GetLastError();\n\t\tif (m_OverlappedRead->hEvent != NULL) CloseHandle(m_OverlappedRead->hEvent);\n\t\tif (m_OverlappedWrite->hEvent != NULL) CloseHandle(m_OverlappedWrite->hEvent);\n\t\tCloseHandle(m_hIDComDev);\n\t\tm_hIDComDev = NULL;\n\t\tUE_LOG(LogTemp, Error, TEXT(\"Failed to setup port COM%d. Error: %08X\"), nPort, dwError);\n\t\treturn false;\n\t&#125;\n\n\t//FPlatformProcess::Sleep(0.05f);\n\tAddToRoot();\n\tm_Port = nPort;\n\tm_Baud = nBaud;\n\treturn true;\n&#125;\n\nvoid USerial::Close()\n&#123;\n\tif (!m_hIDComDev) return;\n\n\tif (m_OverlappedRead->hEvent != NULL) CloseHandle(m_OverlappedRead->hEvent);\n\tif (m_OverlappedWrite->hEvent != NULL) CloseHandle(m_OverlappedWrite->hEvent);\n\tCloseHandle(m_hIDComDev);\n\tm_hIDComDev = NULL;\n\n\tRemoveFromRoot();\n&#125;\n\nFString USerial::ReadString(bool&amp; bSuccess)\n&#123;\n\treturn ReadStringUntil(bSuccess, '\\0');\n&#125;\n\nFString USerial::Readln(bool&amp; bSuccess)\n&#123;\n\treturn ReadStringUntil(bSuccess, '\\n');\n&#125;\n\nFString USerial::ReadStringUntil(bool&amp; bSuccess, uint8 Terminator)\n&#123;\n\tbSuccess = false;\n\tif (!m_hIDComDev) return TEXT(\"\");\n\n\tTArray&lt;uint8> Chars;\n\tuint8 Byte = 0x0;\n\tbool bReadStatus;\n\tunsigned long dwBytesRead, dwErrorFlags;\n\tCOMSTAT ComStat;\n\n\tClearCommError(m_hIDComDev, &amp;dwErrorFlags, &amp;ComStat);\n\tif (!ComStat.cbInQue) return TEXT(\"\");\n\n\tdo &#123;\n\t\tbReadStatus = BOOL2bool(ReadFile(\n\t\t\tm_hIDComDev,\n\t\t\t&amp;Byte,\n\t\t\t1,\n\t\t\t&amp;dwBytesRead,\n\t\t\tm_OverlappedRead));\n\n\t\tif (!bReadStatus)\n\t\t&#123;\n\t\t\tif (GetLastError() == ERROR_IO_PENDING)\n\t\t\t&#123;\n\t\t\t\tWaitForSingleObject(m_OverlappedRead->hEvent, 2000);\n\t\t\t&#125;\n\t\t\telse\n\t\t\t&#123;\n\t\t\t\tChars.Add(0x0);\n\t\t\t\tbreak;\n\t\t\t&#125;\n\t\t&#125;\n\n\t\tif (Byte == Terminator || dwBytesRead == 0)\n\t\t&#123;\n\t\t\t// when Terminator is \\n, we know we're expecting lines from Arduino. But those\n\t\t\t// are ended in \\r\\n. That means that if we found the line Terminator (\\n), our previous\n\t\t\t// character could be \\r. If it is, we remove that from the array.\n\t\t\tif (Chars.Num() > 0 &amp;&amp; Terminator == '\\n' &amp;&amp; Chars.Top() == '\\r') Chars.Pop(false);\n\n\t\t\tChars.Add(0x0);\n\t\t\tbreak;\n\t\t&#125;\n\t\telse Chars.Add(Byte);\n\n\t&#125; while (Byte != 0x0 &amp;&amp; Byte != Terminator);\n\n\tbSuccess = true;\n\tauto Convert = FUTF8ToTCHAR((ANSICHAR*)Chars.GetData());\n\treturn FString(Convert.Get());\n&#125;\n\nfloat USerial::ReadFloat(bool&amp; bSuccess)\n&#123;\n\tbSuccess = false;\n\n\tTArray&lt;uint8> Bytes = ReadBytes(4);\n\tif (Bytes.Num() == 0) return 0;\n\n\tbSuccess = true;\n\treturn *(reinterpret_cast&lt;float*>(Bytes.GetData()));\n&#125;\n\nint32 USerial::ReadInt(bool&amp; bSuccess)\n&#123;\n\tbSuccess = false;\n\n\tTArray&lt;uint8> Bytes = ReadBytes(4);\n\tif (Bytes.Num() == 0) return 0;\n\n\tbSuccess = true;\n\treturn *(reinterpret_cast&lt;int32*>(Bytes.GetData()));\n&#125;\n\nuint8 USerial::ReadByte(bool&amp; bSuccess)\n&#123;\n\tbSuccess = false;\n\tif (!m_hIDComDev) return 0x0;\n\n\tuint8 Byte = 0x0;\n\tbool bReadStatus;\n\tunsigned long dwBytesRead, dwErrorFlags;\n\tCOMSTAT ComStat;\n\n\tClearCommError(m_hIDComDev, &amp;dwErrorFlags, &amp;ComStat);\n\tif (!ComStat.cbInQue) return 0x0;\n\n\tbReadStatus = BOOL2bool(ReadFile(\n\t\tm_hIDComDev,\n\t\t&amp;Byte,\n\t\t1,\n\t\t&amp;dwBytesRead,\n\t\tm_OverlappedRead));\n\n\tif (!bReadStatus)\n\t&#123;\n\t\tif (GetLastError() == ERROR_IO_PENDING)\n\t\t&#123;\n\t\t\tWaitForSingleObject(m_OverlappedRead->hEvent, 2000);\n\t\t&#125;\n\t\telse\n\t\t&#123;\n\t\t\treturn 0x0;\n\t\t&#125;\n\t&#125;\n\n\tbSuccess = dwBytesRead > 0;\n\treturn Byte;\n&#125;\n\nTArray&lt;uint8> USerial::ReadBytes(int32 Limit)\n&#123;\n\tTArray&lt;uint8> Data;\n\n\tif (!m_hIDComDev) return Data;\n\n\tData.Empty(Limit);\n\n\tuint8* Buffer = new uint8[Limit];\n\tbool bReadStatus;\n\tunsigned long dwBytesRead, dwErrorFlags;\n\tCOMSTAT ComStat;\n\n\tClearCommError(m_hIDComDev, &amp;dwErrorFlags, &amp;ComStat);\n\tif (!ComStat.cbInQue) return Data;\n\n\tbReadStatus = BOOL2bool(ReadFile(\n\t\tm_hIDComDev,\n\t\tBuffer,\n\t\tLimit,\n\t\t&amp;dwBytesRead,\n\t\tm_OverlappedRead));\n\n\tif (!bReadStatus)\n\t&#123;\n\t\tif (GetLastError() == ERROR_IO_PENDING)\n\t\t&#123;\n\t\t\tWaitForSingleObject(m_OverlappedRead->hEvent, 2000);\n\t\t&#125;\n\t\telse\n\t\t&#123;\n\t\t\treturn Data;\n\t\t&#125;\n\t&#125;\n\n\tData.Append(Buffer, dwBytesRead);\n\treturn Data;\n&#125;\n\nbool USerial::Print(FString String)\n&#123;\n\tauto Convert = FTCHARToUTF8(*String);\n\tTArray&lt;uint8> Data;\n\tData.Append((uint8*)Convert.Get(), Convert.Length());\n\n\treturn WriteBytes(Data);\n&#125;\n\nbool USerial::Println(FString String)\n&#123;\n\treturn Print(String + LineEndToStr(WriteLineEnd));\n&#125;\n\nbool USerial::WriteFloat(float Value)\n&#123;\n\tTArray&lt;uint8> Buffer;\n\tBuffer.Append(reinterpret_cast&lt;uint8*>(&amp;Value), 4);\n\treturn WriteBytes(Buffer);\n&#125;\n\nbool USerial::WriteInt(int32 Value)\n&#123;\n\tTArray&lt;uint8> Buffer;\n\tBuffer.Append(reinterpret_cast&lt;uint8*>(&amp;Value), 4);\n\treturn WriteBytes(Buffer);\n&#125;\n\nbool USerial::WriteByte(uint8 Value)\n&#123;\n\tTArray&lt;uint8> Buffer(&#123; Value &#125;);\n\treturn WriteBytes(Buffer);\n&#125;\n\nbool USerial::WriteBytes(TArray&lt;uint8> Buffer)\n&#123;\n\tif (!m_hIDComDev) false;\n\n\tbool bWriteStat;\n\tunsigned long dwBytesWritten;\n\n\tbWriteStat = BOOL2bool(WriteFile(m_hIDComDev, Buffer.GetData(), Buffer.Num(), &amp;dwBytesWritten, m_OverlappedWrite));\n\tif (!bWriteStat &amp;&amp; (GetLastError() == ERROR_IO_PENDING))\n\t&#123;\n\t\tif (WaitForSingleObject(m_OverlappedWrite->hEvent, 1000))\n\t\t&#123;\n\t\t\tdwBytesWritten = 0;\n\t\t\treturn false;\n\t\t&#125;\n\t\telse\n\t\t&#123;\n\t\t\tGetOverlappedResult(m_hIDComDev, m_OverlappedWrite, &amp;dwBytesWritten, false);\n\t\t\tm_OverlappedWrite->Offset += dwBytesWritten;\n\t\t\treturn true;\n\t\t&#125;\n\t&#125;\n\n\treturn true;\n&#125;\n\nvoid USerial::Flush()\n&#123;\n\tif (!m_hIDComDev) return;\n\n\tTArray&lt;uint8> Data;\n\n\tdo &#123;\n\t\tData = ReadBytes(8192);\n\t&#125; while (Data.Num() > 0);\n&#125;\n\nFString USerial::LineEndToStr(ELineEnd LineEnd)\n&#123;\n\tswitch (LineEnd)\n\t&#123;\n\tcase ELineEnd::rn:\n\t\treturn TEXT(\"\\r\\n\");\n\tcase ELineEnd::n:\n\t\treturn TEXT(\"\\n\");\n\tcase ELineEnd::r:\n\t\treturn TEXT(\"\\r\");\n\tcase ELineEnd::nr:\n\t\treturn TEXT(\"\\n\\r\");\n\tdefault:\n\t\treturn TEXT(\"null\");\n\t&#125;\n&#125;\n蓝图使用\n\n蓝图代码连接https://blueprintue.com/blueprint/ss-s-s83/\n\n\n","slug":"UE串口通信","date":"2022-07-22T08:14:36.000Z","categories_index":"UnrealEngine","tags_index":"串口通信","author_index":"cBao"}]