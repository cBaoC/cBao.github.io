[{"id":"666eeba740dffa28e952c25ed8f5ff46","title":"C#图解教程第5版","content":"C#中的命名约定\n\n\n风格名称\n描述\n推荐使用\n示例\n\n\n\nPascal大小写\n标识符每个单词首字母大写\n用于类型名称和类中对外可见成员的名称（类，方法，命名空间，属性和公有字段）\nCardDeck\n\n\nCamel大小写\n标识符每个单词首字母大写，第一个单词除外\n用于局部变量的名称和方法声明的形参名称\ncardDeck\n\n\n下划线和Camel大小写\n以下划线开头的Camel大小写的标识符\n用于私有和受保护的字段\n_cardDeck\n\n\n\n\n\n\n\n\n\n注意\n\n标识符命名可以使用字母，数字，下划线\n\n标识符只能以字母和下划线开头，不能以数字开头\n\n@字符只能放在标识符首位，不推荐使用\n\n不能将关键字用于标识符\n\nC#区分大小写\n\n\n\n\n\nC#程序的起点：Main\n每个C#程序必须有一个类带有Main方法\n\n每个C#程序的可执行点在Main的第一条指令\n\nMain首字母必须大写\n\nMain的最简单形式\nstatic void Main()\n&#123;\n   &#x2F;&#x2F;更多语句\n&#125;\n\n空白符\n空格（Space）\n制表符（Tab）\n换行符\n回车符\n\n块\n语法上只需要一条语句，而你需要执行的动作无法用一条简单的语句表达的情况下，考虑使用块\n有些特定的程序结构只能使用块。在这些结构，不能用简单语句替代快\n块后面不跟分号\n\n从程序中输出文本Write\nWrite是Console类的成员，将文本字符串发送到程序控制台窗口\nWrite不会自动添加换行符\n\nConsole.Write(&quot;Hello&quot;);\n\nWriteLine\nWriteLine是Console类的成员，将文本字符串发送到程序控制台窗口\nWriteLine会自动在结尾添加一个换行符\n\nConsole.WriteLine(&quot;Hello,World&quot;);\n\n格式字符串\nWrite和WriteLine语句的常规形式中可以有一个以上的参数，参数间用逗号分隔\n\n第一个参数必须是字符串，称为格式字符串，包含替代标记\n\n语法：Console.WriteLine(格式字符串(含替代标记),替换值0,替换值1,替换值2,……);\nConsole.WriteLine(&quot;Hell&#123;0&#125;,Wor&#123;1&#125;d&quot;, &#39;o&#39;, &#39;l&#39;);\n\n\n\n\n\n\n\n提示\n​        C#6.0引入字符串插值，通过直接在替代标记内插入变量名实现，前提需要加上$符号    \nint var1 &#x3D; 3;\nint var2 &#x3D; 4;\nConsole.WriteLine($&quot;&#123;var1&#125;+&#123;var2&#125;&#x3D;?&quot;);\n\n\n\n多重标记和值\n在C#中可以使用任意数量的替代标记和任意数量的值，值可以以任何顺序使用\n值可以在格式字符串中替换任意次\n标记不能试图引用超出替换值列表长度以外位置的值，若引用超过长度以外的值，不会产生编译错误，但会产生运行时错误（异常）\n\nConsole.WriteLine(&quot;He&#123;0&#125;&#123;0&#125;o,Worl&#123;1&#125;&quot;,&#39;l&#39;,&#39;d&#39;);&#x2F;&#x2F;正确用法\n\n\n格式化数字字符串\n把值作为货币或者某个小数位数的定点值来显示\n\nConsole.WriteLine(&quot;The value:&#123;0:C&#125;&quot;, 500);\n\n\n\n注释\n\n\n类型\n开始\n结束\n描述\n\n\n\n单行注释\n//\n\n从开始标记到该行行尾的文本被编译器忽略\n\n\n带分隔符的注释\n/*\n*/\n从开始标记到结束标记之间的文本被编译器忽略\n\n\n文档注释\n///\n\n这种类型的注释包含XML文本，可以使用工具生成程序文档\n\n\n预定义类型\nC#提供16种预定义类型\n\n\n\n\n用户定义类型6种类型可以由用户自己创建\n类类型（class）\n结构类型（struct）\n数组类型（array）\n枚举类型（enum）\n委托类型（delegate）\n接口类型（interface）\n\n栈和堆栈\n栈是一个内存数组，是一个LIFO(后进先出的数据结构)\n\n栈存储几种类型的数据\n\n某些类型变量的值\n程序当前的执行环境\n传递给方法的参数\n\n\n栈的特征\n\n数据只能从栈的顶端插入和删除\n将数据放到栈顶称为入栈（push）\n从栈顶删除数据称为出栈（pop）\n\n\n\n\n\n\n\n\n\n\n提示\n​        系统管理所有栈操作\n\n\n堆\n堆是一块内存区域，在堆里可以分配大块的内存用于存储某种类型的数据对象\n与栈不同，堆里的内存能够以任意顺序存入和移除\n在C#中GC会自动清除无主的堆对象（C++需要程序员自己释放内存）\nGC垃圾收集的过程\n\n\n值类型和引用类型\n\n\n类声明类class Player\n&#123;\n    &#x2F;&#x2F;...\n&#125;\n\n类成员\n字段和方法是最重要的类成员类型。字段是数据成员，方法是函数成员\n\n字段：隶属于类的变量\n\n\n\n\n\n\n\n注意\n​        与C/C++不同，C#在类型外部不能声明全局变量（变量或字段）。所有字段都属于类型，必须在类型内部声明。\n\n\n\n方法：相当于C++中的成员函数\n\n\n\n\n\n\n\n注意\n​        与C/C++不同，C#中没有全局函数​        C#中的所有方法必须包含返回类型或void\n\n\n\n\n\n\n为数据分配内存\n使用new运算符为实际数据分配内存\n\nnew运算符为任意指定类型的实例分配并初始化内存。依据类型的不同从栈或堆里分配\nPlayer p1&#x3D;new Player();\n\n访问修饰符\n语法\n字段：访问修饰符 类型 标识符;\n方法：访问修饰符 返回类型 方法名() {…}\n\n\n五种修饰符\n私有的（private）\nC#默认的访问级别是私有访问\n私有成员只能从声明它的类的内部访问，其它的类看不见且无法访问它们\n\n\n公有的（public）\n受保护的（protected）\n内部的（internal）\n受保护内部的（protected internal）\n\n\n\n方法方法的结构方法头\n指示方法是否返回数据，如果返回，返回什么类型\n方法的名称\n接受的数据类型\n\n方法体\n包含可执行代码的语句序列，执行过程从方法体的第一条语句开始，一直到整个方法结束\n\n\n方法体内部的代码执行\n局部变量\n控制流结构\n方法调用\n内嵌的块\n其它方法（局部函数，C#7.0开始）\n\n局部变量\n局部变量的生命周期仅限于创建它的块及其内嵌的块\n声明时开始存在\n在块完成时结束存在\n\n\n可以在方法体内任意位置声明局部变量，但必须在使用它们前声明\n不会隐式初始化，使用之前未赋值，编译器会产生错误消息\n类型推断和var关键字\nvar关键字只能用于局部变量，不能用于字段（属于类的变量为字段）\n只能在局部变量声明中包含初始化时使用\n一旦编译器推断出变量的类型，它就是固定且不能更改的\nvar关键字不改变C#的强类型性质\n\n\n在C#中不管嵌套级别如何，都不能在第一个名称的有效范围内声明另一个同名的局部变量\n\n控制流选择语句\nif\nif…else\nswitch\n\n迭代语句\nfor循环\nwhile循环\ndo循环\nforeach（为一组中每个成员执行一次）\n\n跳转语句\nbreak：跳出当前循环\ncontinue：到当前循环的底部\ngoto：到一个标签\nreturn：返回到调用方法继续执行\n\n返回值\n如果要返回值，方法必须在方法名前面声明一个返回类型\n如果方法不返回值，必须声明为void返回类型\n\n参数形参\n形参是局部变量，声明在方法的参数列表中\n\n实参\n用于初始化形参的表达式或变量称作实参\n\n值参数\n在栈中为形参分配空间\n将实参的值复制给形参\n改变形参不会影响实参\n\n引用参数\n使用引用参数时，必须在方法的声明和调用中都是用ref修饰符\n实参必须是变量，且必须被赋值\n形参会改变实参\n\n引用类型作为值参数和引用参数\n将引用类型对象作为值参数传递：如果在方法内创建一个新对象并赋值给形参，将切断形参与实参之间的关联，并且再调用方法后，新对象也不复存在。\n将引用类型对象作为引用参数传递：如果在方法内创建一个新对象并赋值给形参，在方法结束后该对象依然存在，并且是实参所引用的值。\n\n输出参数\n必须在声明和调用中都使用修饰符。输出参数的修饰符是out不是ref\n\n和引用参数相似，实参必须是变量，不能是其它类型的表达式\n\nout修饰的形参，不用再外部初始化，但必须要在内部赋值，再使用\n\n在C#7.0之后，\nusing System;\n\nnamespace Simple\n&#123;\n\n    class Program\n    &#123;\n        int Sum(out int val1, out int val2)\n        &#123;\n            val1 &#x3D; 20;\n            val2 &#x3D; 30;\n            return val1 + val2;\n        &#125;\n        static void Main()\n        &#123;\n            Program p1 &#x3D; new Program();\n            int sum &#x3D; p1.Sum(out int val1, out int val2);&#x2F;&#x2F;不在需要预先声明一个变量用作out参数\n            Console.WriteLine(&quot;val1:&#123;0&#125;,val2:&#123;1&#125;&quot;, val1, val2);\n        &#125;\n    &#125;\n&#125;\n\n参数数组\n在一个参数列表中只能有一个参数数组\n\n如果有，必须是列表中的最后一个\n\n由参数数组表示的所有参数必须是同一类型\n\n在数据类型前使用params修饰符\n\n在数据类型后放置一组空的方括号\nvoid Test(params int[] vals);\n如果数组参数是值类型，那么值被复制，实参在方法内部不受影响\n\n如果数组参数是引用类型，那么引用被赋值，实参引用的对象在方法内部会受到影响\n\n\n参数类型总结\nref局部变量和ref返回ref局部变量\n创建一个对象的别名，即使引用的对象是值类型\n\n对任意一个变量的赋值都会反映到另一个变量上（类似C++中的引用），即使是值类型\n\n语法\nref int y &#x3D; ref x;&#x2F;&#x2F;y是x的别名\n\nref返回\n使方法返回变量的引用而不是变量值\n\n语法\npublic ref int RefToVal()\n&#123;\n    return ref Score;\n&#125;\n\n方法重载一个类中可以有多个同名方法，叫做方法重载，使用相同名称的每个方法必须有一个和其它方法不同的签名\n\n方法签名组成\n方法名称\n参数的数目\n参数的类型和顺序\n参数修饰符\n\n\n返回类型不是签名的一部分\n形参的名称也不是签名的一部分\n\n递归方法调用自身，叫做递归\n深入理解类成员修饰符的顺序\n修饰符\n如果有修饰符，必须放在核心声明之前\n如果有多个修饰符，可以任意顺序排列\n\n\n特性\n如果有特性，必须放在核心声明之前\n如果有多个特性，可以任意顺序排列\n\n\n\n\n静态字段\n静态字段被类的所有实例共享，所有实例都访问同一内存位置\n\n用static修饰符将字段声明成静态\nstatic int test &#x3D; 100;\n使用类名和’.’运算符访问静态字段\n\n即使不存在类实例，静态成员也存在\n\n\n静态函数成员\n静态函数成员独立于任何类实例，即使没有类实例，仍然可以调用静态方法\n静态函数成员不能访问实例成员，但能访问静态成员\n\n成员常量\n类似于静态字段，没有实例也可以使用\n与真正的静态量不同，常量没有自己的存储位置，类似于C/C++中的#define值\n不能声明成static\n\n属性属性是代表类实例或类中数据项的成员\n\n属性的特征\n\n是命名的类成员\n有类型\n可以被赋值和读取\n属性是一个函数成员\n不一定为数据存储分配内存\n执行代码\n\n\n属性是一组被称为访问器的方法\n\nset访问器为属性赋值\n拥有一个单独的，隐式的值参，名称为value，与属性的类型相同\n拥有一个返回类型void\n\n\nget访问器从属性获取值\n没有参数\n拥有一个与属性类型相同的返回类型\nget访问器的所有执行路径必须包含一条return语句，返回一个属性类型的值\n\n\n访问器set和get可以以任何顺序声明，且除了这两个访问器外，属性上不允许有其它方法\n\n\n不能显示的调用访问器，会产生编译错误\n\n属性和关联字段\n\n将字段声明成private，声明一个public属性来控制从类的外部对该字段的访问\nclass Test\n&#123;\n    private int val;\n    public int Value\n    &#123;\n        set &#123; val &#x3D; value; &#125;\n        get &#123; return val; &#125;\n        \n    &#125;  \n&#125;\n属性和它们对应的后备字段的命名约定\n\n字段使用Camel大小写，属性使用Pascal大小写\nclass Test\n&#123;\n    private int val;&#x2F;&#x2F;字段使用Camel大小写\n    public int Value&#x2F;&#x2F;属性使用Pascal大小写\n    &#123;\n        set &#123; val &#x3D; value; &#125;\n        get &#123; return val; &#125;\n        \n    &#125;  \n&#125;\n字段使用Camel大小写，并以下划线_开头，属性使用Pascal大小写（按照C#命名约定，推荐使用这种方式）\nclass Test\n&#123;\n    private int _val;&#x2F;&#x2F;字段使用Camel大小写，并以下划线_开头\n    public int Value&#x2F;&#x2F;属性使用Pascal大小写\n    &#123;\n        set &#123; val &#x3D; value; &#125;\n        get &#123; return val; &#125;\n        \n    &#125;  \n&#125;\n\n\n\n\n属性和lambda表达式\n\nC#7.0引入的新语法\n\n只能在访问函数体由一个表达式组成时才能使用\nprivate int val;\npublic int Value\n&#123;\n    set&#x3D;&gt; val &#x3D; value &gt; 100 ? 100 : value;\n    get &#x3D;&gt; val;\n&#125;\n\n\n\n只读和只写属性属性的访问器可以单独声明\n\n只有get访问器的属性称为只读属性。只读属性能够安全的将一个数据项从类或类的实例中传出\n只有set访问器的属性称为只写属性\n两个访问器中至少有一个必须定义，否则编译器会报错\n\n属性与公有字段按照推荐的编码实践，属性比公有字段更好\n\n属性是函数成员而不是数据成员，允许处理输入和输出，而公有字段不行\n属性可以只读或只写，而字段不行\n编译后的变量和编译后的属性语义不同\n\n自动实现属性因为属性经常被关联到后备字段，所以C#提供了自动实现属性（自动属性）\n\n允许只声明属性而不声明后备字段，编译器会创建后备字段，自动挂接到get和set访问器上\n\n自动实现属性的要点如下\n\n不声明后备字段，编译器根据属性的类型分配存储\n不能提供访问器的方法体，必须被简单的声明为分号\n\nclass Test\n&#123;\n    public int Value&#123; get; set; &#125;\n&#125;\n\n静态属性属性也可以声明为static。静态属性的访问器和所有静态成员一样，具有以下特点：\n\n不能访问类的实例成员，但能被实例成员访问\n不管类是否有实例，都存在\n在类的内部，可以仅使用名称来引用静态属性\n在类的外部，可以使用类名或者使用using static结构来引用静态属性\n\n实例构造函数实例构造函数是一个特殊的方法，它在创建每个新实例时执行\n\n构造函数用于初始化类实例的状态\n如果希望能从类的外部创建类的实例，需要将构造函数声明为public\n构造函数的名称和类名相同\n构造函数不能有返回值\n构造函数可以带参数\n构造函数可以被重载\n如果在类的声明中没有显示的提供实例构造函数，编译器会提供一个隐式的默认构造函数（没有参数，构造体为空）\n如果为类显示定义了构造函数，编译器不会为该类定义默认构造函数\n将构造函数的访问修饰符设置成private，这样在类外部就不能实例该类型对象\n\n静态构造函数构造函数可以声明为static，实例构造函数初始化每个新实例，static构造函数初始化类级别的项，通常静态构造函数初始化类的静态字段\n\n在引用任何静态成员之前\n在创建类的任何实例之前\n静态构造函数的名称必须和类名相同\n构造函数不能有返回值\n静态构造函数声明中使用static关键字\n类只能有一个静态构造函数，且不能带参数\n静态构造函数不能有访问修饰符\n\n\n\n\n\n\n\n\n注意\n\n类既可以有静态构造函数也可以有实例构造函数\n如同静态方法，静态构造函数不能访问所在类的实例成员，因此不能使用this访问器\n不能从程序中显示的调用静态构造函数，系统自动调用\n\n\n\n对象初始化语句\n创建对象的代码必须能够访问要初始化的字段和属性（公有的）\n\n初始化语句发生在构造方法执行之后\n\n语法示例\nTest t2 &#x3D; new Test &#123; X &#x3D; 10, Y &#x3D; 20&#125;;&#x2F;&#x2F;使用了初始化语句\n\n析构函数析构函数执行在类的实例被销毁之前需要的清理或释放非托管资源的行为\nreadonly修饰符字段可以用readonly修饰符声明，作用类似于const，一旦值被设定就不能改变\n\nconst字段只能在字段的声明语句中初始化，而readonly字段可以在下列任意位置设置它的值\n\n字段声明语句，类似const\n类的任何构造函数，如果是static字段，初始化必须在静态构造函数中完成\n\n\nconst字段的值必须在编译时决定，而readonly字段的值可以在运行时决定\n\n语法示例\nclass Test\n&#123;\n    public Test()\n    &#123;\n        val &#x3D; 20;&#x2F;&#x2F;在构造函数中为只读字段赋值\n    &#125;\n    public readonly int val;&#x2F;&#x2F;只读字段\n&#125;\n\nthis关键字this关键字在类中使用，是对当前实例的引用，它只能被用在下列类成员的代码块中\n\n实例构造函数\n实例方法\n属性和索引器的实例访问器\n用于区分类的成员和局部变量或参数\n作为调用方法的实参\n\n\n\n\n\n\n\n\n注意\n​    因为静态成员不是实例的一部分，所以不能在任何静态函数成员的代码中使用this关键字\n\n\n索引器索引器是一组get和set的访问器，与属性类似\n\n和属性一样，索引器不用分配内存来存储\n索引器和属性都主要被用来访问其它数据成员，它们与这些成员关联，并为它们提供获取和设置访问\n属性通常表示单个数据成员\n索引器通常表示多个数据成员\n\n\n和属性一样，索引器可以只有一个访问器，也可以两个都有\n索引器总是实例成员，所以不能被声明成static\n和属性一样，实现get和set的访问器的代码不一定要关联到某个字段或属性\n不能显示调用get和set访问器\n\n声明索引器\n索引器没有名称。在名称的位置是关键字this\n参数列表在方括号中间\n参数列表中必须至少声明一个参数\n\nstring this[int index]\n&#123;\n    get &#123; return this[index]; &#125;\n    set &#123; this[index] &#x3D; value; &#125;\n&#125;\n\n索引器的set访问器当索引器被用于赋值时，set访问器被调用，并接受两项数据\n\n一个名为value的隐式参数，其中持有要保存的数据\n一个或更多索引参数，表示数据应该保存到哪里\n\n索引器示例class Test\n&#123;\n    private int val1;\n    private int val2;\n    private int val3;\n\n    public int this[int index]\n    &#123;\n        get\n        &#123;\n            switch (index)\n            &#123;\n                case 0: return val1;\n                case 1: return val2;\n                case 2: return val3;\n                default:  throw new IndexOutOfRangeException();\n            &#125;\n        &#125;\n        set\n        &#123;\n            switch (index)\n            &#123;\n                case 0:val1&#x3D; value; break;\n                case 1:val2&#x3D; value; break;\n                case 2:val3&#x3D; value; break;\n                default:throw new IndexOutOfRangeException();\n            &#125;\n        &#125;\n    &#125;\n&#125;\n\n索引器重载只要索引器的参数列表不同，类就可以有任意多个索引器。索引器类型不同是不够的\n\n\n\n\n\n\n\n注意\n​        类中重载的索引器必须有不同的参数列表\n\n\n访问器的访问修饰符\n仅当成员（属性或索引器）既有get访问器也有set访问器时，其访问器才能有访问修饰符\n虽然两个访问器都必须出现，但其中只能有一个访问修饰符\n访问器的访问修饰符的限制必须比成员的访问级别更严格\n\n\n分部类和分部类型类的声明可以分割成几个分部类的声明\n\n每个分部类的声明都含有一些类成员的声明\n\n类的分部类声明可以在同一个文件中也可以在不同文件中\n\n每个分部类声明必须标注为partial class，而不是单独的关键字class\n\n分部类声明和普通类声明相同，只是增加了类型修饰符partial\n\n分部类示例\npartial class Test\n&#123;\n    public int val1;\n&#125;\n\npartial class Test\n&#123;\n    public Test()\n    &#123;\n        val1 &#x3D; 1;\n    &#125;\n    public int val2;\n&#125;\n\n分部方法分部方法是声明在分部类中不同部分的方法，分部方法的不同部分可以声明在分部类的不同部分中，也可以声明在同一个部分中\n分部方法的两个部分\n定义分部方法声明\n给出签名和返回类型\n声明的实现部分只是一个分号\n\n\n实现分部方法声明\n给出签名和返回类型\n以普通的语句块形式实现\n\n\n\n类和继承类继承通过继承可以定义一个新类，新类为一个已经声明的类进行拓展\n\n可以使用一个已经存在的类作为新类的基础。已经存在的类称为基类，新类称为派生类\n\n派生类组成如下\n\n本身声明中的成员\n基类的成员\n\n\n要声明一个派生类，需要在类名后加入基类规格说明\nclass Base\n&#123;\n    \n&#125;\n\n&#x2F;&#x2F;使用基类规格说明,Base是Sub的基类\nclass Sub : Base\n&#123;\n    \n&#125;\n派生类拓展它的基类，因为它包含基类的成员，还有它本身声明中新增功能\n\n派生类不能删除它所继承的任何成员\n\n\n访问继承的成员继承的成员可以被访问，就像它们是派生类自己声明的一样\n所有类都派生自object除了特殊的类object，所有类都是派生类，即使没有基类规格说明，类object是唯一的非派生类，因为它是继承层次结构的基础\n\n没有基类规格说明的类隐式地直接派生自类object\n一个类声明的基类规格说明中只能有一个单独的类。称为单继承\n虽然类只能直接继承一个基类，但派生的层次没有限制\n\n屏蔽基类成员虽然派生类不能删除它继承的任何成员，但可以用与基类成员名称相同的成员来屏蔽基类成员。\n\n要屏蔽一个继承的数据成员，需要声明一个新的相同类型的成员，并使用相同的名称\n\n通过在派生类中声明新的带有相同签名的函数成员，可以屏蔽继承的函数成员，签名由名称和参数列表组成，不包括返回类型\n\n要让编译器知道故意屏蔽继承的成员，可使用new修饰符，否则编译器会警告你隐藏了一个继承的成员\nclass Base\n&#123;\n    public int val;\n&#125;\n\nclass Sub : Base\n&#123;\n    &#x2F;&#x2F;使用new 关键字 显示的告诉编译器屏蔽继承的成员\n    new public int val;\n&#125;\n也可以屏蔽静态成员\n\n\n基类访问如果派生类必须访问被隐藏的继承成员，可以使用基类访问表达式，基类访问表达式由关键字base后面跟着一个点和成员名称组成\nclass Base\n&#123;\n    public int val&#x3D;20;\n&#125;\n\n&#x2F;&#x2F;使用基类规格说明,Base是Sub的基类\nclass Sub : Base\n&#123;\n    &#x2F;&#x2F;使用new 关键字 显示的告诉编译器屏蔽继承的成员\n    new public int val;\n    public void PrintfFun()\n    &#123;\n        &#x2F;&#x2F;使用base关键字访问被隐藏的基类成员\n        Console.WriteLine(base.val);\n    &#125;\n&#125;\n\n使用基类的引用派生类的实例由基类的实例和派生类新增的成员组成。派生类的引用指向整个类对象，包括基类部分\n如果有一个派生类对象的引用，就可以获取该对象基类部分的引用（使用类型转换运算符把该引用转换为基类类型）\nclass Base\n&#123;\n    public void Printf()\n    &#123;\n        Console.WriteLine(&quot;My Base Class&quot;);\n    &#125;\n&#125;\n\n&#x2F;&#x2F;使用基类规格说明,Base是Sub的基类\nclass Sub : Base\n&#123;\n    &#x2F;&#x2F;隐藏基类的Printf函数\n    new public void Printf()\n    &#123;\n        Console.WriteLine(&quot;My Sub Class&quot;);\n    &#125;\n&#125;\n\nclass Program\n&#123;\n    static void Main()\n    &#123;\n        Sub s1&#x3D;new Sub();\n        Base b1 &#x3D; (Base)s1;&#x2F;&#x2F;强转成基类类型\n        b1.Printf();&#x2F;&#x2F;调用的是基类的Printf\n    &#125;  \n&#125;\n\n虚方法和覆写方法当使用基类的引用访问派生类对象时，得到的是基类的成员，虚方法可以使基类的引用访问“升至”派生类内\n使用基类引用调用派生类方法\n派生类的方法和基类的方法有相同的签名和返回类型\n基类的方法使用virtual标注\n派生类的方法使用override标注\n\nclass Base\n&#123;\n    &#x2F;&#x2F;virtual标记表示该方法可被覆写\n    virtual public void Printf()\n    &#123;\n        Console.WriteLine(&quot;My Base Class&quot;);\n    &#125;\n&#125;\n\n&#x2F;&#x2F;使用基类规格说明,Base是Sub的基类\nclass Sub : Base\n&#123;\n    &#x2F;&#x2F;override标记覆写基类方法\n    override public void Printf()\n    &#123;\n        Console.WriteLine(&quot;My Sub Class&quot;);\n    &#125;\n&#125;\n\n\nclass Program\n&#123;\n    static void Main()\n    &#123;\n        Sub s1&#x3D;new Sub();\n        Base b1 &#x3D; (Base)s1;&#x2F;&#x2F;强转成基类类型\n        b1.Printf();&#x2F;&#x2F;因为派生类覆写了基类方法，所以调用派生类方法\n    &#125;    \n&#125;\n\n\n\n\n\n\n\n\n注意\n\n覆写和被覆写的方法必须有相同的可访问性\n不能覆写static方法或非虚方法\n方法，属性和索引器，事件都可以被声明成virtual和override\n\n\n\n覆写标记为override的方法\n当使用对象基类部分的引用调用一个被覆写的方法时，方法的调用被沿派生层次上溯执行，一直到标记为override的方法的最高派生版本\n如果在更高的派生级别有该方法的其它声明，但没有被override标记，那么不会被调用\n\n构造函数执行\n要创建对象的基类部分，需要隐式调用基类的某个构造函数\n继承层次链中的每个类在执行它自己的构造函数体之前执行它基类的构造函数\n\n\n\n\n\n\n\n\n\n注意\n​    强烈反对在构造函数中调用虚方法，在执行基类的构造函数时，基类的虚方法会调用派生类的覆写方法，但这是在执行派生类的构造函数方法之前。\n​    因此，调用会在派生类完全初始化之前传递到派生类。\n\n\n构造函数初始化语句默认情况下，在构造对象时，将调用基类的无参构造函数。\n如果希望派生类使用指定的基类构造函数，必须在构造函数初始化语句中指定它\n\n第一种形式使用关键字base指明使用哪一个基类构造函数\nclass Base\n&#123;\n    public Base(int val1,int val2)\n    &#123;\n        Val1 &#x3D; val1;\n        Val2 &#x3D; val2;\n    &#125;\n\n    public int Val1;\n    public int Val2;\n&#125;\n\nclass SubClass : Base\n&#123;\n    &#x2F;&#x2F;base指明使用哪一个基类构造函数\n    public SubClass(int val1, int val2) : base(val1, val2)\n    &#123;\n\n    &#125;\n&#125;\n第二种形式使用关键字this并指明应该使用当前类的哪一个构造函数\nclass Base\n&#123;\n    &#x2F;&#x2F;使用this指定调用当前类的无参构造函数\n    public Base(int val1):this()\n    &#123;\n        Val1 &#x3D; val1;\n    &#125;\n\n    public Base()\n    &#123;\n        Val2 &#x3D; 20;\n    &#125;\n\n    public int Val1;\n    public int Val2;\n\n    public void Printf()\n    &#123;\n        Console.WriteLine($&quot;Val1:&#123;Val1&#125;\\nVal2:&#123;Val2&#125;&quot;);\n    &#125;\n&#125;\n\n类访问修饰符类的可访问性有两个级别\n\n标记为public的类可以被系统内任何程序集中的代码访问，要是一个类对其它程序集可见，使用public访问修饰符\npublic class Base\n&#123;\n    \n&#125;\n标记为internal的类只能被它自己所在的程序集内的类看到\n\n这是C#默认的可访问级别\n可以使用internal访问修饰符显示的声明一个类为内部的\n\ninternal class Base\n&#123;\n    \n&#125;\n\n程序集之间的继承要从不同程序集中定义的基类派生类，必须具备两个条件\n\n基类必须被声明成public，这样才能从它所在的程序集外部访问它\n必须在VS工程中的References节点中添加对包含该基类的程序集的引用\n\n成员访问修饰符\n所有显示声明在类声明中的成员都是相互可见的，无论访问性如何\n继承的成员不在类的声明中显式声明，所以继承的成员对派生类的成员可能是可见的，也可能是不可见的\n五个成员访问级别\npublic\n\n\n\n","slug":"CSharp图解教程第5版","date":"2023-03-12T05:00:17.000Z","categories_index":"C#","tags_index":"C#","author_index":"cBao"},{"id":"297e7259160304ea1919564f5d876933","title":"C语言字符输入/输出","content":"单字符I/Ogetchar()和putchar()\ngetchar()和putchar()每次只处理一个字符\n#include &lt;iostream>\n\nint main()\n&#123;\n\tchar c;\n\twhile((c=getchar())!='#')//当遇到'#'时结束打印\n\t&#123;\n\t\tputchar(c);\n\t&#125;\n\treturn 0;\n&#125;\n\n缓冲输入和无缓冲输入\n\n\n\n\n\n\n提示\n​    完全缓存I/O：当缓冲区被填满时才刷新缓冲区（内容发送至目的地），通常出现在文件输入中。（缓冲区的大小取决于系统，通常为512字节和4096字节）\n​    行缓冲I/O：当出现换行符时刷新缓冲区。（键盘输入通常是行缓冲输入，按下Enter键后才刷新缓冲区）\n\n\n无缓冲输入#include &lt;iostream>\n#include &lt;conio.h>//提供无缓冲输入的头文件\n\nint main()\n&#123;\n\tchar c;\n    //有回显的无缓冲输入的函数_getche()\n    //无回显的无缓冲输入函数_getch()\n\twhile((c=_getche())!='c')\n\t&#123;\n\t\tputchar(c);\n\t&#125;\n    \n\treturn 0;\n&#125;\n\n\n\n\n\n\n\n提示\n​    检查换行符的方法\nif(ch=='\\n')//用于检查换行符\n\n\n\n文件结尾\n操作系统可以使用内嵌的Ctrl+Z标记文件结尾\n记录文件大小用来读取文件内容\n\n\n\n\n\n\n\n提示\n​    在C语言中，用getchar()读取文件和scanf()函数检测到文件结尾时会返回一个特殊的值（EOF）。\n​    EOF定义在stdio.h文件中\n#define EOF(-1)\n\n#include &lt;iostream>\n\nint main()\n&#123;\n    //这里是int\n\tint ch;\n\twhile((ch=getchar())!=EOF)\n\t&#123;\n\t\tputchar(ch);\n\t&#125;\n\treturn 0;\n&#125;\n\n\n\n","slug":"C语言字符输入输出","date":"2023-03-04T08:23:17.000Z","categories_index":"C","tags_index":"C","author_index":"cBao"},{"id":"74d1a6628a5df30cefe103fae4a073dc","title":"UEC++基础","content":"五个最常见的基类UObjectUObject类提供的功能\nGarbage collection 垃圾回收(GC)\n原生C++中的内存管理由程序员完成\n虚幻引擎提供两种垃圾回收的解决方案\n继承自UObject类，同时指向UObject类实例对象的指针成员变量用 UPROPERTY宏进行标记 ，虚幻会自动地进行对象的生命周期管理\n采用智能指针：只有 非UObject类型 ，才能使用智能指针进行自动内存释放\n\n\n\n\nReference updating 引用自动更新\nReflection 反射\n反射是一套可以在 运行时获取 一个类的成员变量和成员函数的一种机制\n\n\nSerialization序列化\n将对象保存到磁盘，下次运行时完好无损的加载\n\n\nAutomatic updating of default property changes 自动检测默认变量的更改\nAutomatic property initialzation 自动变量初始化\nAutomatic editor integration 和虚幻引擎编辑器的自动交互\n将变量暴露到虚幻引擎的Edit面板进行编辑\n\n\nType information available at runtime 运行时类型识别\nNetwork replication 网络复制\n\n\n\n\n\n\n\n\n注意\n\n当需要上述这些功能时，类该继承自UObject类\nUObject类会在引擎加载阶段，创建一个Default Object默认对象\n构造函数并不是在游戏运行时候调用，即便只有一个UObject对象，构造函数也会被 调用两次\n构造函数调用时UWorld不一定存在。 GetWorld()返回值可能为空\n\n\n\n\n\nActorActor类的能力\nActor类能被 挂载组件\n\n\n\n\n\n\n\n\n注意\n\n当需要挂载组件时，才继承自Actor类\n\n\n\n灵魂与肉体: Pawn、Character和ControllerPawn\n一个可以被Controller操作的兵或卒\n\nCharacter\n继承自Pawn类，代表一个角色\n相比于Pawn类，Character类提供了一个特殊组件 Character Movement ，该组件提供了角色移动的功能\n\nController\nController操纵着Pawn和Character的行为（Pawn和Character是肉体，Controller是用来操控肉体的灵魂）\nController可以是 AI Controller  也可以是 Player Controller\n\n虚幻引擎类的命名规则\nF 纯C++类\nU 继承自UObject，但不继承自Actor\nA 继承自Actor\nS Slate控件相关类\nH HItResult相关类\n\n类对象类对象的产生\n如果类是一个纯C++类型(F开头)，通过new来产生对象\n\n如果类继承自UObject但不继承自Actor，通过NewObject函数来产生对象\nNewObject&lt;T&gt;();\n如果类继承自Actor，需要通过SpawnActor函数产生对象\nGetWorld()-&gt;SpawnActor&lt;AYourActorCLass&gt;();\n\n类对象的获取\n获取一个类对象的唯一方法，是通过某种方式传递到这个对象的指针或引用\n\n如果要获取场景中，某个Actor的实例，需要借助Actor迭代器:TActorIterator\nfor(TActorIterator&lt;AActor&gt; Iterator(GetWorld());Iterator;++Iterator)\n&#123;\n    \t&#x2F;&#x2F;*Iterator获取指向对象的指针\n&#125;\n\n类对象的销毁纯C++类\n当纯C++类实在函数体中创建，并且不是通过new来进行分配内存，不需要手动干涉释放，会随着函数调用结束后，随着函数栈空间一起被释放\n\n当纯C++类使用new来分配内存，除非手动删除(delete)，否则该内存永远不会被释放，产生内存泄漏\n\n当纯C++类使用new来分配内存，同时使用智能指针TSharedPtr/TSharedRef来进行管理，不应该手动干涉释放，智能指针会自动完成内存的释放\nTSharedPtr&lt;Test&gt; YourClassPtr&#x3D;MakeShareable(new YourClass());&#x2F;&#x2F;通过MakeShareable函数转化普通指针为智能指针\n\nUObject类\nUObject类采用自动垃圾回收机制（当一个类的成员变量包含指向UObject的对象，同时又带有UPROPERTY宏定义，该成员变量将会触发引用计数机制）\n\n\n\n\n\n\n\n提示\n        垃圾回收器会定期从根节点Root开始检查，当一个UObject没有被别的任何UObject引用，就会被垃圾回收\n​        可以通过AddToRoot函数来让一个UObject一直不被回收\n\n\nActor类\nActor类对象通过Destory函数请求销毁，使用该方式销毁是将Actor从所属世界中摧毁，但对象的内存回收依然由系统决定\n\n从C++到蓝图UPROPERTY宏\n可以将一个 UObject类的子类 成员变量注册到蓝图中\nUPROPERTY(BlueprintReadWrite,VisibleAnywhere,Category&#x3D;&quot;YourName&quot;)\n\nUFUNCTION宏\n可以将函数注册到蓝图中\nUFUNCTION(BlueprintCallable,Category&#x3D;&quot;YourName&quot;)\n\n\nBlueprintCallable：表示函数可以被蓝图调用\nBlueprintImplementableEvent：该成员函数由蓝图的子类实现，不应在C++中实现（编译错误）\nBlueprintNativeEvent：该成员函数提供一个C++的默认实现，同时也可以被蓝图重载，再C++中需要提供一个“函数名_Implement”为名字的函数实现\n\n\n\n引擎系统相关类FPaths类\n该类是用于处理路径相关的类\n具体路径类：如获取游戏根目录\n工具类：如判断一个文件是否存在\n路径转换类：如将相对路径转换为绝对路径\n\nConfig类的使用\n写配置\nGConfig.SetString((TEXT(&quot;MySection&quot;),TEXT(&quot;Name&quot;),TEXT(&quot;cBao&quot;),FPath::GameDir&#x2F;&quot;MyConfig.ini&quot;));\n\n\n第一个参数指定Section（区块）\n第二个参数配置Key\n第三个参数配置具体的值\n第四个参数是路径，没有会自动创建\n\n\n\n\n\n\n\n\n\n提示\n​        GConfig对各种类型的数据都有相应的函数，如SetInt，SetBool，SetFloiat等\n\n\n\n读配置\nFString Result;\nGConfig-&gt;GetString(TEXT(&quot;cBao&quot;),TEXT(&quot;Name&quot;),Result,FPaths::ProjectConfigDir()&#x2F;&quot;cBaoCsConfig.ini&quot;);\n\n","slug":"UEC++基础","date":"2023-02-02T06:19:47.000Z","categories_index":"UnrealEngine","tags_index":"UEC++","author_index":"cBao"},{"id":"2d7fcd3211374fac141da523879cb012","title":"Unity3D引擎","content":"场景中的对象\nGameObject类对象是Unity引擎提供作为场景中所有对象的根本\n\nUnity中脚本的基本规则\n创建规则\n不在VS中创建脚本\n可以放在Assets文件夹下的任意位置（建议同一文件夹下）\n类名和文件名必须一致，不然不能挂载（因为反射机制创建对象，会通过文件名去找Type） 重要\n不要使用中文命名\n没有特殊需求，不需要管命名空间\n创建的脚本默认继承MonoBehaviour\n\n\nMonoBehavior基类\n创建的脚本默认继承MonoBehaviour，继承该类才能挂载到GameObject上\n继承了MonoBehaviour的脚本不能new只能挂载！！！\n继承了MonoBehaviour的脚本不要写构造函数（也可以写，会自动调用），因为不能new，构造函数无意义\n继承了MonoBehaviour的脚本可以在一个对象上挂多个（没有添加DisallowMultipleComponent特性时）\n继承MonoBehaviour的类也可以再次被继承，遵循面向对象继承多态原则\n\n\n不继承MonoBehaviour的类\n不继承MonoBehaviour的类不能挂载到GameObject对象上\n不继承MonoBehaviour的类 想怎么写就怎么写 如果要使用 需要自己new实例化一个对象\n不继承MonoBehaviour的类 一般是单例模式的类（用于管理模块）或者数据结构类（用于存储数据）\n不继承MonoBehaviour的类 不用保留默认出现的几个函数\n\n\n\n在Unity中打印信息的两种方式\n没有继承MonoBehaviour类\n\n\n\nAPI\n\n\n\nDebug.Log(“…”);\n\n\nDebug.LogError(“出错”);\n\n\nDebug.LogWarning(“警告”);\n\n\n\n继承了MonoBehaviour类\n\n\n\nAPI\n\n\n\nprint(“…”);\n\n\n\n\n生命周期函数\n所有继承MonoBehaviour的脚本，最终都会挂载到GameObject游戏对象上\n\n生命周期函数就是该脚本对象依附的GameObject对象从出生到消亡的整个生命周期上\n\n会通过反射自动调用的一些特殊函数，是Unity自己调用的\n\n生命周期函数的访问修饰符一般为private和protected，因为不需要在外部自己调用生命周期函数\n\n生命周期函数并不是基类中的成员\n\n常用的生命周期函数（从上到下的执行先后）\n\n\n\nAPI\n描述\n\n\n\nAwake\n当脚本对象创建时，自动调用，类似构造函数，一个对象只会调用一次\n\n\nOnEnable\n依附的GameObject对象每次激活时调用\n\n\nStart\n当脚本对象创建后，第一次帧更新之前调用，一个对象只会调用一次（比Awake要晚）\n\n\nFixedUpdate\n物理帧更新，固定间隔时间执行，间隔时间可以设置（project Setting -&gt; Time）\n\n\nUpdate\n逻辑帧更新每帧执行\n\n\nLateUpdate\n每帧执行，于Update之后执行（一般用来处理摄像机位置更新（防止渲染出错））\n\n\nOnDisable\n依附的GameObject对象每次失活时调用\n\n\nOnDestroy\n对象销毁时调用，依附的GameObject对象被删除时\n\n\n\n\n生命周期函数支持继承多态\n\n\nInspector窗口可编辑的变量\nInspector显示的可编辑内容就是脚本的公共成员变量，默认情况下私有和保护的无法显示编辑\n加上强制序列化字段特性[SerializeField]，可以让私有的和保护的成员也可以被显示编辑\n在公共成员变量前加上[HideInInspector]，可以让公共成员变量在Inspector隐藏，默认是显示的\n大部分类型都能显示编辑\n自定义类型和Dictionary类型不能显示编辑\n\n\n加上序列化特性[System.Serializable]可以让自定义类型和结构体可以被显示编辑\n一些辅助特性\n分组：[Header(“分组说明”)]\n悬停注释：[Tooltip(“说明内容”)]\n间隔特性：[Space()]\n修饰数值的滑条范围Range：[Range(最小值,最大值)]\n多行显示字符串，默认不写参数显示3行：[Multiline()]\n滚动条显示字符串，默认不写参数超过3行显示滚动条：[TextArea(3,4)]最少显示3行，最多显示4行，超过4行显示滚动条\n为变量添加快捷方法：[ContextMenuItem(“显示按钮名”,”方法名”)]，方法名不能有参数\n为方法添加特性能够在Inspector中执行：[ContextMenu(“测试函数”)]\n\n\n注意\nInspector窗口中的变量关联的就是对象的成员变量，运行时改变它们就是在改变成员变量\n拖拽到GameObject对象后，再改变脚本中的变量默认值 界面上不会改变\n运行中修改的信息不会被保存\n\n\n\nMonoBehaviour中的重要内容\n重要成员\n\n获取依附的GameObject\nthis.gameObject;\n//gameObject与上面一样\n获取依附的GameObject位置信息\nthis.transform.position;//获得位置信息\nthis.transform.eulerAngles;//获得欧拉角\nthis.transform.lossyScale;//获得缩放大小\nthis.gameObject.transform;//该方法与以上相同\n设置脚本是否激活\nthis.enable=false;//失活\nthis.enable=true;//激活\n\n\n重要方法\n\n得到依附对象上挂载的其它脚本\n\n根据脚本名获取，获取失败返回null\nthis.GetComponent(\"脚本名\");//使用时用as进行转换使用\n根据Type获取\nthis.GetComponent(typeof(脚本类型));\n根据泛型获取 建议使用泛型获取，不用二次转换  建议使用\nthis.GetComponent&lt;脚本类型>();\n\n\n得到自己挂载的多个脚本\nthis.GetComponents&lt;脚本类型>(也可以直接用List);\n得到子对象挂载的脚本（默认也会找自身是否挂载该脚本）\nthis.GetComponentInChildren&lt;脚本类型>(true/false);//得单个\n//true子对象失活时也会查找，false子对象失活时不会查找\n\nthis.GetComponentsInChildren&lt;脚本类型>(true/false);//得多个\n得到父对象挂载得脚本（默认也会查找自身是否挂载该脚本）\nthis.GetComponentInParent&lt;脚本类型>();//得单个\n//true子对象失活时也会查找，false子对象失活时不会查找\n\nthis.GetComponentsInParent&lt;脚本类型>();//得多个\n尝试获取脚本\nthis.TryGetComponent&lt;脚本类型&gt;(out type);\n\n\n\nGameObject常用成员变量\n\n\nAPI\n描述\n\n\n\nthis.gameObject.name\n名字\n\n\nthis.gameObject.activeSelf\n是否激活\n\n\nthis.gameObject.isStatic\n是否是静态\n\n\nthis.gameObject.layer\n层级\n\n\nthis.gameObject.tag\n标签\n\n\nthis.gameObject.transform / this.transform\ntransform\n\n\nGameObject常用静态方法\n\n\nAPI\n描述\n\n\n\nGameObject.CreatePrimitive()\n创建自带几何体，会返回一个GameObject对象\n\n\nGameObject.Find()\n通过名字查找对象，效率较低，找不到失活对象，有相同名字的对象时，随机查找其中一个\n\n\nGameObject.FindWithTag()\n通过标签查找对象，找不到失活对象，有相同标签的对象时，随机查找其中一个\n\n\nGameObject.FindGameObjectWithTag()\n通过标签查找对象,与上一个API功能相同\n\n\nGameObject.FindGameObjectsWithTag()\n查找多个对象只能tag去找，无法通过名字 ，找不到失活对象\n\n\nGameObject.FindObjectOfType&lt;脚本类型&gt;()\n找到场景中挂载的某一个脚本对象，基本不使用，效率低下\n\n\nGameObject.instantiate()\n实例化对象，动态创建对象（名字后会增加clone）\n\n\nGameObject.Destroy()\n删除对象或者脚本，一般情况下会在下一帧移除对象并从内存中移除，第二个参数代表延迟删除的时间\n\n\nGameObject.DestroyImmediate()\n立即删除，不会等到下一帧，没有特殊需求不使用，可能存在卡顿\n\n\nGameObject.DontDestroyOnLoad()\n对象过场景不被移除（Unity默认过场景时场景中的对象都会自动删除掉）\n\n\nGameObject常用的成员方法\n\n\nAPI\n描述\n\n\n\nnew GameObject()\n创建一个空物体，存在重载，可以创建的同时添加脚本\n\n\nObj.AddComponent&lt;脚本类型&gt;()\n为对象添加脚本\n\n\nObj.SetActive()\n设置对象的激活和失活\n\n\nthis.CompareTag()\n标签比较\n\n\nthis.gameObject.SendMessage(“函数名”)\n执行挂载自身所有同名函数的行为 效率低下，不建议使用\n\n\nthis.gameObject.BroadcastMessage(“函数名”)\n广播行为，让自己和自己子对象执行相同函数名的函数\n\n\nthis.gameObject.SendMessageUpwards(“函数名”)\n向父对象和自己发送消息并执行相同函数名的函数\n\n\nUnity中的Object不是指的万物之父的objectTime\n主要用于游戏中参与位移，计时，时间暂停等\n\n时间缩放比例\n//时间停止\nTime.timeScale=0;\n\n//恢复正常\nTime.timeScale=1;\n\n//2倍速\nTime.timeScale=2;\n帧间隔时间：最近的一帧用了多长时间，主要用来计算位移\n//受Scale影响\nTime.deltaTime;\n\n//不受Scale影响的帧间隔时间\nTime.unscaledDeltaTime;\n游戏开始到现在的时间\n//受Scale影响\nTime.time;\n\n//受Scale影响\nTime.unscaledTime;\n物理帧间隔时间 FixedUpdate\n//受Scale影响\nTime.fixedDeltaTime;\n\n//不受Scale影响\nTime.fixedUnscaledDeltaTime;\n帧数\n//从开始到现在游戏跑了多少帧\nTime.frameCount;\n\nTransform\nVector3\n\n主要用来表示三维坐标系中的一个点或者向量\n\n常用\n\n\n\nAPI\n描述\n\n\n\nVector3.zero\n(0,0,0)\n\n\nVector3.right\n(1,0,0) X轴正方向\n\n\nVector3.left\n(-1,0,0)\n\n\nVector3.forward\n(0,0,1) Z轴正方向为面朝向\n\n\nVector3.back\n(0,0,-1)\n\n\nVector3.up\n（0,1,0）Y轴正方向\n\n\nVector3.down\n（0,-1,0）\n\n\nVector3.Distance\n计算两个点之间的距离\n\n\n\n\n\n位置和位移\n\n相对世界坐标系\nthis.transform.position;\n相对父对象\nthis.transform.localPosition;\n世界坐标和相对坐标相同时的两种情况\n\n父对象的坐标是世界坐标原点(0,0,0)\n对象没有父对象\n\n\n位置的赋值不能单独改变x,y,z的值，只能整体改变\n\n对象当前的各朝向\n\n\n\nAPI\n描述\n\n\n\nthis.transform.forward\n当前对象正方向\n\n\nthis.transform.back\n当前对象后方向\n\n\nthis.transform.up\n当前对象上方向\n\n\nthis.transform.down\n当前对象下方向\n\n\nthis.transform.right\n当前对象右方向\n\n\nthis.transform.left\n当前对象右左方向\n\n\n\n位移\n\n公式：路程 = 方向 * 速度 * 时间 \n//朝自身前方向移动\nthis.transform.position += this.transform.forward * Time.deltaTime * 10;\nAPI 一般使用该方式位移\n//参数一：表示位移多少  路程=方向*速度*时间\n//参数二：表示相对坐标系 默认是localPosition\nthis.transform.Translate();\n\n//朝自己的正方向移动\nthis.transform.Translate(this.transform.forward * 1*Time.deltaTime, Space.World);\n\n//朝世界的正方向移动\nthis.transform.Translate(Vector3.forward * 1 * Time.deltaTime, Space.World);\n\n//朝自己的正方向移动\nthis.transform.Translate(Vector3.forward * 1 * Time.deltaTime, Space.Self);\n\n\n\n\n角度和旋转\n\n自转 API\n//第一个参数：每一帧旋转的角度\n//第二个参数：相对坐标系 默认是自己的坐标系\nthis.transform.Rotate(new Vector3(0, 5, 0) * Time.deltaTime);\n\n//重载方式\n//第一个参数：相对于哪个轴进行运动\n//第二个参数：转动的角度是多少\n//第三个参数：相对坐标系 默认是自己的坐标系\nthis.transform.Rotate(Vector3.up, Time.deltaTime * 10,Space.Self);\n相对于某个点进行旋转\n//第一个参数：相对于哪个点\n//第二个参数：相对于点的轴\n//第三个参数：转的度数 旋转速度*时间\nthis.transform.RotateAround(Vector3.zero, Vector3.up, 10 * Time.deltaTime);\n\n\n\n\n\n\n\n\n特别注意\n通过欧拉角(Obj.transform.eulerAngles)获得的角度，在代码上始终只能在0~360范围内\n\n\n\n缩放和看向\n\n相对于世界坐标系，只能get不能set\nthis.transform.lossyScale;\n相对于本地坐标系（父对象）\nthis.transform.localScale;\n看向：让一个对象面朝向某一个点或者对象\nthis.transform.LookAt();\n\n\n父子关系\n\n获取和设置父对象\n//获取父对象\nthis.transform.parent;\n\n//设置父对象\nthis.transform.parent=null;//将父对象设置成空\nthis.transform.SetParent();//与上方效果相同，该方法重载中可以保留世界坐标位置\n\n//抛妻弃子\nthis.transform.DetachChildren();\n获得子对象\n//通过查找获得子对象\nthis.transform.Find(\"Cube (5)\");//该方法找不到孙子，失活对象也能找到\n\n//通过索引获得子对象\nthis.transform.GetChild(0)\n儿子的操作\n//一个对象判断自己是不是另一个对象的儿子\nIsChildOf();\n\n//得到自己作为儿子的编号\nGetSiblingIndex();\n\n//把自己设置为第一个儿子\nSetAsFirstSibling();\n\n//把自己设置为最后一个儿子\nSetAsLastSibling();\n\n//设置自己为指定为第几个儿子 超出范围会直接设置成最后一个子对象\nSetSiblingIndex(Index);\n\n\n\n坐标转换\n世界坐标系的点 转换 为相对本地坐标系的点（受缩放影响）\nthis.transform.InverseTransformPoint(Vector3.forward);\n世界坐标系的方向 转换 为相对本地坐标系的方向（不受缩放影响）\nthis.transform.InverseTransformDirection(Vector3.forward);\n世界坐标系的方向 转换 为相对本地坐标系的方向（受缩放影响）\nthis.transform.InverseTransformVector(Vector3.forward);\n\n\n\n\n\n\n\n提示\n世界坐标系 转 本地坐标系 可以帮助我们大概判断一个相对位置\n\n\n\n本地坐标系的点 转换 为相对世界坐标系的点（受缩放影响）\nthis.transform.TransformPoint(Vector3.forward);\n本地坐标系的方向 转换 为相对世界坐标系的方向（不受缩放影响）\nthis.transform.TransformDirection(Vector3.forward);\n本地坐标系的方向 转换 为相对世界坐标系的方向（受缩放影响）\nthis.transform.TransformVector(Vector3.forward);\n\n输入Input\n输入相关内容肯定是写在Update中\n\n鼠标在屏幕位置\nInput.mousePosition\n\n\n屏幕坐标的原点在屏幕左下角，往右是x轴正方向，往上是Y轴正方向\n返回值是Vector3 只有x和y有效 z一直是0\n\n\n检测鼠标输入\n\n鼠标按下\nif (Input.GetMouseButtonDown(0))\n&#123;\n    print(\"鼠标左键按下\");\n&#125;\nelse if (Input.GetMouseButtonDown(1))\n&#123;\n    print(\"鼠标右键按下\");\n&#125;\nelse if (Input.GetMouseButtonDown(2))\n&#123;\n    print(\"鼠标中键按下\");\n&#125;\n鼠标抬起\nif (Input.GetMouseButtonUp(0))\n&#123;\n    print(\"鼠标左键抬起\");\n&#125;\nelse if (Input.GetMouseButtonUp(1))\n&#123;\n    print(\"鼠标右键抬起\");\n&#125;\nelse if (Input.GetMouseButtonUp(2))\n&#123;\n    print(\"鼠标中键抬起\");\n&#125;\n鼠标长按\nif (Input.GetMouseButton(0))\n&#123;\n    print(\"鼠标左键长按下\");\n&#125;\nelse if (Input.GetMouseButton(1))\n&#123;\n    print(\"鼠标右键长按下\");\n&#125;\nelse if (Input.GetMouseButton(2))\n&#123;\n    print(\"鼠标中键长按下\");\n&#125;\n鼠标中键滚动\nInput.mouseScrollDelta;\n//-1往下滚动\n//0没有滚动\n//1往上滚动\n\n\n检测键盘输入\n\n键盘按下\nif (Input.GetKeyDown(KeyCode.W))\n&#123;\n    print(\"W按下\");\n&#125;\n\n//必须是小写\nif (Input.GetKeyDown(\"q\"))\n&#123;\n    print(\"Q按下\");\n&#125;\n键盘抬起\nif (Input.GetKeyUp(KeyCode.W))\n&#123;\n    print(\"W抬起\");\n&#125;\n\n//必须是小写\nif (Input.GetKeyUp(\"q\"))\n&#123;\n    print(\"Q抬起\");\n&#125;\n键盘长按\nif (Input.GetKey(KeyCode.Space))\n&#123;\n    print(\"空格长按\");\n&#125;\n\n//是否有任意键或鼠标长按\nif (Input.anyKey)\n&#123;\n    print(\"有键长按\");\n&#125;\n\n//是否有任意键或鼠标按下\nif (Input.anyKeyDown)\n&#123;\n    print(\"有键按下\");\n&#125;\n\n//这一帧的键盘输入\nprint(Input.inputString);\n\n\n\n检测默认轴输入\nInput.GetAxis(\"Horizontal\");//返回float\n\n\n在以下可以配置对应轴输入\n\n\n\n屏幕相关\n当前屏幕分辨率\nScreen.currentResolution;\n屏幕窗口当前宽高\nScreen.width;\nScreen.height;\n屏幕休眠模式\nScreen.sleepTimeout = SleepTimeout.NeverSleep;//永不熄屏\nScreen.sleepTimeout = SleepTimeout.SystemSetting;//系统设置\n运行时是否全屏模式\nScreen.fullScreen = true;\n窗口模式\n//独占全屏\n Screen.fullScreenMode = FullScreenMode.ExclusiveFullScreen;\n//全屏窗口\nScreen.fullScreenMode = FullScreenMode.FullScreenWindow;\n//最大化窗口\nScreen.fullScreenMode = FullScreenMode.MaximizedWindow;\n//窗口模式\nScreen.fullScreenMode = FullScreenMode.Windowed;\n移动设备屏幕转向相关\n//允许自动旋转为左横向 Home键在左\nScreen.autorotateToLandscapeLeft = true;\n//允许自动旋转为右横向 Home键在右\nScreen.autorotateToLandscapeRight = true;\n//允许自动旋转为纵向 Home键在下\nScreen.autorotateToPortrait = true;\n//允许自动旋转到纵向倒着看 Home键在上\nScreen.autorotateToPortraitUpsideDown = true;\n//指定屏幕显示方向\nScreen.orientation = ScreenOrientation.LandscapeLeft;//等等\n\n\n\n设置分辨率（移动设备上一般不使用）\nScreen.SetResolution(1920, 1080, true);\n\n摄像机组件\nClear Flags（如何清除背景）\n\n\n\n类型\n描述\n\n\n\nSkybox\n天空盒\n\n\nSolid Color\n颜色填充\n\n\nDepth only\n只画该层，背景透明\n\n\nDon’t Clear\n不移除，覆盖渲染\n\n\n\nCulling Mask（选择性渲染部分层级）\n\nProjection（透视模式）\n\nClipping Planes（裁剪平面距离 ）\n\nViewport Rect（视口范围，屏幕上将绘制该摄像机视图的位置，主要用于双摄像机游戏）\n\nDepth（渲染顺序上的深度）\n\nTarget Texture（渲染纹理）\n\n把摄像机画面渲染到一张图上，主要用于制作小地图\n在Project右键创建Render Texture\n\n\nOcclusion Culling（是否启用剔除遮挡）\n\n\n获取摄像机\n获取主摄像机\n//场景上必须有一个tag为MainCamera的摄像机\nCamera.main;\n获得摄像机的数量\nCamera.allCamerasCount;\n获得所有摄像机\nCamera[] cameras = Camera.allCameras;\n渲染委托相关函数\n//摄像机剔除前处理的委托函数\nCamera.onPreCull += (c) =>\n&#123;\n\n&#125;;\n\n//摄像机渲染前处理的委托\nCamera.onPreRender += (c) =>\n&#123;\n\n&#125;;\n\n//摄像机渲染后处理的委托\nCamera.onPostRender += (c) =>\n&#123;\n\n&#125;;\n界面上的参数 都可以在Camera中获取到\n\n世界坐标转到屏幕坐标（x和y对应屏幕坐标，z对应摄像机与该点的距离）\nCamera.main.WorldToScreenPoint(this.transform.position);\n屏幕坐标转世界坐标\n//z轴很重要\nVector3 v = Input.mousePosition;\nv.z = 10;\nprint(Camera.main.ScreenToWorldPoint(v));\n\n光源组件\nType：光源类型\n\n\n\n类型\n描述\n\n\n\nSpot\n聚光灯\n\n\nDirectional\n平行光\n\n\nPoint\n点光源\n\n\nArea\n面光源（烘焙状态下有效）\n\n\n\nColor：颜色\n\nMode：光源模式\n\n\n\n模式\n描述\n\n\n\nRealtime\n实时光源，每帧实时计算，效果好，性能消耗大\n\n\nBaked\n红背光源，预先计算好，无法动态改变\n\n\nMixed\n混合光源，预先计算+实时运算\n\n\n\nIntensity：光源强度\n\nIndirect Multiplier：间接光  改变间接光的强度，低于1每次反弹会使光更暗，大于1每次反弹会使光更亮\n\nShadow Type：阴影类型\n\n\n\n类型\n描述\n\n\n\nNoShadows\n关闭阴影\n\n\nHardShadows\n硬阴影\n\n\nSoftShadows\n柔阴影\n\n\n\nRealtimeShadows\n\n\n\n类型\n描述\n\n\n\nStrength\n阴影暗度0~1之间，越大越黑\n\n\nResolution\n阴影贴图渲染分辨率，越大越逼真，消耗也越高\n\n\nBias\n阴影推离光源的距离\n\n\nNormal Bias\n阴影投射面沿法线收缩距离\n\n\nNear Panel\n渲染阴影的近裁截面\n\n\n\nCookie：投影遮罩\n\nCookie Size：投影遮罩大小\n\nDraw Halo：光晕开关\n\nFlare：耀斑（摄像机上需要加上Flare Layer脚本才能在Game窗口显示耀斑）\n\nRenderMode：渲染模式\n\n\n\n模式\n描述\n\n\n\nAuto\n运行时确定\n\n\nImportant\n以像素质量单位进行渲染，效果好，消耗大\n\n\nNot Important\n以快速模式进行渲染\n\n\n\nCulling Mask：剔除遮罩层，决定哪些层的对象受到该光源影响\n\n\n光面板\n打开方式：Windows-&gt;Rendering-&gt;Lighting\n\n物理系统之碰撞检测\n刚体组件：RigidBody\n产生碰撞的必要条件：两个物体必须要有 碰撞器 ，其中至少有一个带有刚体\n\n\n\n\n\n\n碰撞函数\n//开始碰撞时执行的函数\nprivate void OnCollisionEnter(Collision collision)\n&#123;\n    \n&#125;\n  \n//碰撞结束时执行的函数\nprivate void OnCollisionExit(Collision collision)\n&#123;\n    \n&#125;\n  \n//两个物体互相接触时，会一直调用\nprivate void OnCollisionStay(Collision collision)\n&#123;\n    \n&#125;\n触发函数\n//触发开始时执行的函数\nprivate void OnTriggerEnter(Collider other)\n&#123;\n    \n&#125;\n  \n//触发结束时执行的函数\nprivate void OnTriggerExit(Collider other)\n&#123;\n    \n&#125;\n  \n//重叠时，会一直调用\nprivate void OnTriggerStay(Collider other)\n&#123;\n    \n&#125;\n\n","slug":"Unity3D引擎","date":"2022-09-22T15:48:50.000Z","categories_index":"Unity3D引擎","tags_index":"Unity3D引擎","author_index":"cBao"},{"id":"321e20a64de3485e0958a3f7db00142f","title":"UE中的网络同步RPC","content":"UE网络中的服务器在哪！\n在UE中存在服务器和客户端重合，创建房间的客户端同时具备服务器特性\n\nUE中服务器和客户端中对象的关系\n在服务器端，所有的角色（Actor）都是Authority（权威的）\n在客户端眼，除了自己控制的角色外，其他的所有角色都是Simulated proxy（模拟代理）\n在UE网络框架中，Actor是促成网络同步的重要对象\n\nActor的更新方式\n属性更新（针对成员变量）具有及时性，随属性变换而进行通知。属性更新不变化不消耗带宽，但会消耗CPU进行监听\nRPC（针对函数），由用户进行调用\n\nUE网络框架对象归属分类\n\n\nServer Only（仅存在于服务器上）\nServer &amp; Clients（存在于服务器和所有客户端）\nServer &amp; Owning Client（仅存在于服务器和自身客户端）\nOwning Client Only（仅存在于自己客户端）\n\n\n\nAGameMode\nAGameState\nAPlayerController\nAHUD\n\n\n\nAPlayerState\n\nUMG Widget\n\n\n\nAPawn\n\n\n\n\n角色类型标记\n每个Actor中都存在两个属性用来裁定当前Actor在服务器/客户端上的身份类型，分为Role和RemoteRole\n在蓝图中为LocalRole和RemoteRole\nGet Local Role：判断当前角色在本地端身份类型\nGet Remote Role：判断当前角色在远端身份类型（当是客户端时，远端为服务端，当是服务端时，远端是客户端）\n\n网络角色三种类型\nSimulated：由服务器进行数据发送，当前终端进行操控模拟。操控来源于服务器，Simulate对象无法执行RPC函数\nAutonomous：由当前终端实例进行操控。操控来源于真人\nAuthority：服务器端存在标记，表明当前Actor存在于服务器\n\nRPC远端调用，在本机上调用函数，但在其他机器上远程执行的函数。\nRPC执行的三种形式\n服务端执行（Server） ：由客户端调用，在服务器端执行\n客户端执行（Client）： 由服务器端调用，在客户端执行\n所有终端执行（Multicast）  ：由服务器端调用，在所有终端执行\n\nRPC调用注意事项\n必须从 Actor 上调用\n\nActor 必须能被复制（Replicates=true）\n\n如果 RPC 是从服务器调用并在客户端上执行，则只有实际拥有这个 Actor 的客户端才会执行函数\n\n如果 RPC 是从客户端调用并在服务器上执行，客户端就必须拥有调用 RPC 的 Actor。\n\n从服务器上调用RPC\n\n\n\nActor所有权\n未复制\nNetMulticast\nServer\nClient\n\n\n\nClient-Owned Actor\n在服务器上运行\n在服务器和所有客户端上运行\n在服务器上运行\n在 actor  的所属客户端上运行\n\n\nServer-owned actor\n在服务器上运行\n在服务器和所有客户端上运行\n在服务器上运行\n在服务器上运行\n\n\nUnowned actor\n在服务器上运行\n在服务器和所有客户端上运行\n在服务器上运行\n在服务器上运行\n\n\n\n从客户端上调用RPC\n\n\n\nActor所有权\n未复制\nNetMulticast\nServer\nClient\n\n\n\nOwned by invoking client（当前终端所有权）\n在执行调用的客户端上运行\n在执行调用的客户端上运行\n在服务器上运行\n在执行调用的客户端上运行\n\n\nOwned by a different client  （其他终端所有权）\n在执行调用的客户端上运行\n在执行调用的客户端上运行\n丢弃\n在执行调用的客户端上运行\n\n\nServer-owned actor\n在执行调用的客户端上运行\n在执行调用的客户端上运行\n丢弃\n在执行调用的客户端上运行\n\n\nUnowned actor\n在执行调用的客户端上运行\n在执行调用的客户端上运行\n丢弃\n在执行调用的客户端上运行\n\n\n\n\n蓝图中判断服务器和客户端\n\nAuthority：服务器\nRemote：客户端\n\nRPC执行的三种形式\n服务端执行（Server）：在客户端调用，在服务端执行\n客户端执行（Client）:在服务端调用，在客户端执行\n所有终端执行（Multicast）：只能在服务端调用，在所有终端执行\n\n设置Actor所有权\n蓝图中使用Set Owner节点在服务器上获得Actor所有权\n\n\n\n数据同步\nActor必须满足在网络上被复制,设置的参数需要开启复制\n参数的修正必须在服务器端修改,才可以在网络上同步\n蓝图参数同步的两种方式：\nReplicated，同步数据，但没有通知，无法直接通过参数修改驱动逻辑\n•RepNotify，同步数据，并生成通知函数，进行更新通知（向所有终端通知，满足相关性）\n\n\n\n","slug":"UE中的网络同步RPC","date":"2022-08-15T07:32:03.000Z","categories_index":"UnrealEngine","tags_index":"网络同步RPC","author_index":"cBao"},{"id":"fa2dad943cb3925ed47cb72cd3308d02","title":"UE中的文件API","content":"检查文件夹是否存在//文件路径\nFString Dir=FPaths::ProjectDir()/TEXT(\"cBao\");\n//检查文件是否存在\nIFileManager::Get().DirectoryExists(*Dir)\n\n创建文件夹IFileManager::Get().MakeDirectory(*Dir);\n\n检查文件是否存在//注意是/=\nFString Dir=FPaths::ProjectDir()/TEXT(\"cBao\");\nDir /=TEXT(\"cBao.txt\");\n\n//检查文件是否存在\nIFileManager::Get().FileExists(*Dir);\n//创建文件\n\nFFileHelper::SaveStringToFile(TEXT(\"cBao\"),*Dir);\n\n删除文件FString Dir=FPaths::ProjectDir()/TEXT(\"cBao/cc/cc2/cBao.txt\");\n//一般用于删除单个特定文件\nIFileManager::Get().Delete(*Dir);\n\nFString Dir2=FPaths::ProjectDir()/TEXT(\"cBao\");\n//一般用于删除整个文件夹\nIFileManager::Get().DeleteDirectory(*Dir2,true,true);\n\n拷贝文件//不带拷贝进度的拷贝\nFString Src=FPaths::ProjectDir()/TEXT(\"cBao/cc.pdf\");\nFString Dest=FPaths::ProjectDir()/TEXT(\"cBao/cc2.pdf\");\nIFileManager::Get().Copy(*Dest,*Src);\n\n//带拷贝进度的拷贝\n//继承FCopyProgress抽象类,用来显示拷贝进度\nstruct MyProgress:public FCopyProgress\n&#123;\n    //Fraction为拷贝进度百分比\n\tFORCEINLINE virtual bool Poll( float Fraction ) override\n\t&#123;\n\t\tGEngine->AddOnScreenDebugMessage(-1,10.f,FColor::Blue,FString::SanitizeFloat(Fraction));\n\t\treturn true;\n\t&#125;\n&#125;;\nFString Src2=FPaths::ProjectDir()/TEXT(\"cBao/cc.pdf\");\nFString Dest2=FPaths::ProjectDir()/TEXT(\"cBao/cc2.pdf\");\n//创建进度结构\nMyProgress cBaoProgress;\nIFileManager::Get().Copy(*Dest2,*Src2,true,false,false,&amp;cBaoProgress);\n\n文件信息//文件信息(创建日期，访问日期，修改日期，文件大小，是否是文件夹，是否只读，是否有效)\nFFileStatData FileState=IFileManager::Get().GetStatData(*Src);\n\n查找文件//文件路径\nFString Dir=FPaths::ProjectDir()/TEXT(\"cBao\");\n//检查路径是否存在\nif (IFileManager::Get().DirectoryExists(*Dir))\n&#123;\n    //保存文件名称\n\tTArray&lt;FString> NameArray;\n    //查找文件操作 *代表通配符\n\tIFileManager::Get().FindFiles(NameArray,*Dir,TEXT(\"*\"));\n\tfor(auto &amp;Temp:NameArray)\n\t&#123;\n\t\tGEngine->AddOnScreenDebugMessage(-1,10.f,FColor::Blue,Temp);\n\t&#125;\n&#125;\n\n递归查找指定目录下的文件路径//文件路径\nFString Dir=FPaths::ProjectDir()/TEXT(\"cBao\");\n//检查路径是否存在\nif (IFileManager::Get().DirectoryExists(*Dir))\n&#123;\n    //保存文件路径\n\tTArray&lt;FString> PathNameArray;\n    //查找文件操作 *代表通配符 第一个true代表查找文件,第二个false代表忽略文件夹\n\tIFileManager::Get().FindFilesRecursive(PathNameArray,*Dir,TEXT(\"*\"),true,false);\n\tfor (auto&amp; Name:PathNameArray)\n\t&#123;\n\t\tGEngine->AddOnScreenDebugMessage(-1,10.f,FColor::Red,Name);\n\t&#125;\n\n&#125;\n\n","slug":"UE中的文件操作","date":"2022-08-05T05:58:47.000Z","categories_index":"UnrealEngine","tags_index":"文件操作","author_index":"cBao"},{"id":"62bbf97645975b25a08d1c093027a65e","title":"UE中内存操作","content":"分配内存// C\nuint8* Ptr_C=(uint8*)malloc(sizeof(uint8)*1024);\n\t\n// C++\nuint8* Ptr_CPlus=new uint8[1024];\n\n// UEC++\nuint8* Ptr_UnrealCPlus=(uint8*)FMemory::Malloc(sizeof(uint8)*1024);\n\n\n重新分配内存// C/C++\nPtr_C=(uint8*)realloc(Ptr_C,sizeof(uint8)*2048);\n\t\n// UEC++\nFMemory::Realloc(Ptr_UnrealCPlus,sizeof(uint8)*2048);\n\n获得分配的内存大小int32 i = FMemory::GetAllocSize(Ptr_UnrealCPlus);\n\n\n\n\n\n\n\n\n特别注意\n只能获得 FMemory::Malloc() 分配的内存大小，否则会产生崩溃\n\n拷贝char Date1[1024]=\"Hello,World\";\nchar Date2[1024];\n// C/C++\nmemcpy(Date2,Date1,strlen(Date1));\n\n// UEC++\nFMemory::Memcpy(Date2,Date1,strlen(Date1));\n\n移动内存char Date1[1024]=\"Hello,World\";\nchar Date2[1024];\n// C/C++\nmemmove(Date2,Date1,strlen(Date1));\n\n// UEC++\nFMemory::Memmove(Date2,Date1,strlen(Date1));\n\n比较// C/C++\nchar DateComp[1024]=\"cBao2\";\nchar DateComp_2[1024]=\"cBao\";\nint32 Size=memcmp(DateComp,DateComp_2,sizeof(uint8)*5);\n\n// UEC++\nint32 Size2 = FMemory::Memcmp(DateComp,DateComp_2,sizeof(uint8)*5);\n\n\n\n\n\n\n\n\n注意\n当 DateComp&lt;DateComp_2 时返回值&lt;0\n当 DateComp=DateComp_2 时返回值=0\n当 DateComp&gt;DateComp_2 时返回值&gt;0\n\n\n交换char DateComp[1024]=\"cBao2\";\nchar DateComp_2[1024]=\"cBao\";\nFMemory::Memswap(DateComp,DateComp_2,sizeof(uint8)*5)\n\n\n\n\n\n\n\n\n注意\n仅UEC++中存在该API\n\n\n初始化方式//原生C\nmemset(Ptr_C,0,sizeof(uint8)*1024);\nmemset(Ptr_CPlus,0,sizeof(uint8)*1024);\n\n//C++中\nuint8* Ptr_CPlus2=new uint8[]&#123;1,23,4,5,5&#125;;\n\t\n//UEC++\nZeroMemory(Ptr_C,sizeof(uint8)*1024);\nZeroMemory(Ptr_CPlus,sizeof(uint8)*1024);\nFMemory::Memset(Ptr_UnrealCPlus,0,sizeof(uint8)*1024);\nFMemory::Memzero(Ptr_UnrealCPlus,sizeof(uint8)*1024);\n//在申请时就进行初始化\nuint8* Ptr_UnrealC=(uint8*)FMemory::MallocZeroed(sizeof(uint8)*1024);\n\n清除//C\nfree(Ptr_C);\n\t\n//C++中\ndelete[](Ptr_CPlus);\ndelete[](Ptr_CPlus2);\n\n//UEC++中\nFMemory::Free(Ptr_UnrealCPlus);\n\n\n\n\n\n\n\n\n特别注意\nFMemory::Free() 容易造成引擎崩溃\n\n\n","slug":"UE内存操作","date":"2022-08-04T07:41:08.000Z","categories_index":"UnrealEngine","tags_index":"内存操作","author_index":"cBao"},{"id":"ae911ea8c615446cd5e6fd02771c3f77","title":"Json","content":"JSON 语法规则\n数据在键/值对中\n数据由逗号 , 分隔\n使用斜杆来转义 \\ 字符\n大括号 {} 保存对象\n中括号 [] 保存数组，数组可以包含多个对象\n\nJSON 键值对JSON 数据的书写格式是：\n\"name\" : \"cBao\"\n\nJSON 值可以是\n数字（整数或浮点数）\n\"age\":30\n字符串（在双引号中）\n\"name\":\"cBao\"\n逻辑值（true 或 false）\n\"IsDeath\":false\n数组（在中括号中）\n&#123;\n    \"Info\": [\n    &#123; \"age1\":30 , \"name1\":\"cBao\" &#125;, \n    &#123; \"age2\":30 , \"name2\":\"cBao\" &#125;, \n    &#123; \"age3\":30 , \"name3\":\"cBao\" &#125;,\n    ]\n&#125;\n对象（在大括号中）\n&#123;\n  \"Object\":&#123;\n      \"age\":30, \n    \"name\":\"cBao\" \n  &#125;  \n&#125;\nnull\n\"runoob\":null\n\nUE5中将结构体转换成Json示例\n.Build.cs文件需要加入\nPrivateDependencyModuleNames.Add(\"Json\");\n.h文件\n// Fill out your copyright notice in the Description page of Project Settings.\n\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"Kismet/BlueprintFunctionLibrary.h\"\n#include \"StructToJson.generated.h\"\n\nUSTRUCT(BlueprintType)\nstruct FMyInfo\n&#123;\n\tGENERATED_BODY()\n\n\tUPROPERTY(EditAnywhere,BlueprintReadWrite)\n\tFString Name;\n\tUPROPERTY(EditAnywhere,BlueprintReadWrite)\n\tint32 Age;\n&#125;;\n\n\nUSTRUCT(BlueprintType)\nstruct FMyStruct\n&#123;\n\tGENERATED_BODY()\n\t\n\tUPROPERTY(EditAnywhere,BlueprintReadWrite)\n\tFString Name;\n\t\n\tUPROPERTY(EditAnywhere,BlueprintReadWrite)\n\tint32 Age;\n\t\n\tUPROPERTY(EditAnywhere,BlueprintReadWrite)\n\tbool Gender;\n\t\n\tUPROPERTY(EditAnywhere,BlueprintReadWrite)\n\tfloat Weight;\n\n\tUPROPERTY(EditAnywhere,BlueprintReadWrite)\n\tFMyInfo Info;\n\t\n\tUPROPERTY(EditAnywhere,BlueprintReadWrite)\n\tTArray&lt;FMyInfo> Array;\n&#125;;\n\n/**\n * \n */\nUCLASS()\nclass UE_ADVANCE_API UStructToJson : public UBlueprintFunctionLibrary\n&#123;\n\tGENERATED_BODY()\n\n\tUFUNCTION(BlueprintCallable,Category=cBao)\n\tstatic FString StructToString(const FMyStruct&amp; s1);\n\n&#125;;\n\n.cpp文件\n// Fill out your copyright notice in the Description page of Project Settings.\n\n\n#include \"StructToJson.h\"\n\nFString UStructToJson::StructToString(const FMyStruct&amp; s1)\n&#123;\n\t\tFString JsonString;\n\t\t//UE中的Json工程模式\n\t\tTSharedPtr&lt;TJsonWriter&lt;TCHAR,TCondensedJsonPrintPolicy&lt;TCHAR>>> JsonWriter=TJsonWriterFactory&lt;TCHAR,TCondensedJsonPrintPolicy&lt;TCHAR>>::Create(&amp;JsonString);\n\t\tJsonWriter->WriteObjectStart();\n\t\t&#123;\n\t\t\tJsonWriter->WriteValue(TEXT(\"Name\"),s1.Name);\n\t\t\tJsonWriter->WriteValue(TEXT(\"Age\"),s1.Age);\n\t\t\tJsonWriter->WriteValue(TEXT(\"Gender\"),s1.Gender);\n\t\t\tJsonWriter->WriteValue(TEXT(\"Weight\"),s1.Weight);\n\t\t\tJsonWriter->WriteObjectStart(TEXT(\"Info\"));\n\t\t\t&#123;\n\t\t\t\tJsonWriter->WriteValue(TEXT(\"Name\"),s1.Info.Name);\n\t\t\t\tJsonWriter->WriteValue(TEXT(\"Age\"),s1.Info.Age);\n\t\t\t&#125;\n\t\t\tJsonWriter->WriteObjectEnd();\n\t\t\tJsonWriter->WriteArrayStart(TEXT(\"Array\"));\n\t\t\t&#123;\n\t\t\t\tfor (auto &amp; s:s1.Array)\n\t\t\t\t&#123;\n\t\t\t\t\tJsonWriter->WriteObjectStart();\n\t\t\t\t\t&#123;\n\t\t\t\t\t\tJsonWriter->WriteValue(TEXT(\"Name\"),s.Name);\n\t\t\t\t\t\tJsonWriter->WriteValue(TEXT(\"Age\"),s.Age);\n\t\t\t\t\t&#125;\n\t\t\t\t\tJsonWriter->WriteObjectEnd();\n\t\t\t\t&#125;\n\t\t\t&#125;\n\t\t\tJsonWriter->WriteArrayEnd();\n\t\t&#125;\n\t\tJsonWriter->WriteObjectEnd();\n\t\tJsonWriter->Close();\n\t\treturn JsonString;\n&#125;\n\n蓝图中配置输出\n&#123;\"Name\":\"cBao\",\"Age\":24,\"Gender\":true,\"Weight\":2222,\"Info\":&#123;\"Name\":\"ccc\",\"Age\":32324&#125;,\"Array\":[&#123;\"Name\":\"cdd\",\"Age\":22131&#125;,&#123;\"Name\":\"dsaf\",\"Age\":232&#125;]&#125;\n\nUE5中将Json转换成结构体示例\n.h文件\n//FString反序列化成结构体\nUFUNCTION(BlueprintCallable,Category=cBao)\nstatic bool StructFromFString(const FString&amp; s1,FMyStruct&amp; MyStruct);\n.cpp文件\nbool UStructToJson::StructFromFString(const FString&amp; s1, FMyStruct&amp; MyStruct)\n&#123;\n\tTSharedRef&lt;TJsonReader&lt;>> JsonReader=TJsonReaderFactory&lt;>::Create(s1);\n\tTSharedPtr&lt;FJsonObject> ReadRoot;\n\n\tif (FJsonSerializer::Deserialize(JsonReader,ReadRoot))\n\t&#123;\n\t\t//获得String数据\n\t\tMyStruct.Name=ReadRoot->GetStringField(TEXT(\"Name\"));\n\t\t\n\t\t//获得int数据\n\t\tMyStruct.Age=ReadRoot->GetIntegerField(TEXT(\"Age\"));\n\t\t\n\t\t//获得bool数据\n\t\tMyStruct.Gender=ReadRoot->GetBoolField(TEXT(\"Gender\"));\n\t\t\n\t\t//获得浮点数据\n\t\tMyStruct.Weight=ReadRoot->GetNumberField(TEXT(\"Weight\"));\n\t\t\n\t\t//获得对象数据\n\t\tTSharedPtr&lt;FJsonObject> TestRoot=ReadRoot->GetObjectField(TEXT(\"Info\"));\n\t\t&#123;\n\t\t\tMyStruct.Info.Name=TestRoot->GetStringField(TEXT(\"Name\"));\n\t\t\tMyStruct.Info.Age=TestRoot->GetIntegerField(TEXT(\"Age\"));\n\t\t&#125;\n\n\t\t//获得数组数据\n\t\tTArray&lt;TSharedPtr&lt;FJsonValue>>TempArray=ReadRoot->GetArrayField(TEXT(\"Array\"));\n\t\tfor (auto &amp;i:TempArray)\n\t\t&#123;\n\t\t\tTSharedPtr&lt;FJsonObject> JsonObj = i->AsObject();\n\t\t\tFMyInfo TempInfo;\n\t\t\tTempInfo.Name=JsonObj->GetStringField(TEXT(\"Name\"));\n\t\t\tTempInfo.Age=JsonObj->GetIntegerField(TEXT(\"Age\"));\n\t\t\tMyStruct.Array.Add(TempInfo);\n\t\t&#125;\n\t\treturn true;\n\t&#125;\n\t\n\treturn false;\n&#125;\n\n","slug":"Json","date":"2022-08-02T06:17:49.000Z","categories_index":"Json","tags_index":"Json","author_index":"cBao"},{"id":"32edd7bc4a69fac72c5e2e1809026b07","title":"UE串口通信","content":"sdasfsa\nUE串口通信\n.h文件\n#pragma once\n\n#define FC_DTRDSR       0x01\n#define FC_RTSCTS       0x02\n#define FC_XONXOFF      0x04\n#define ASCII_BEL       0x07\n#define ASCII_BS        0x08\n#define ASCII_LF        0x0A\n#define ASCII_CR        0x0D\n#define ASCII_XON       0x11\n#define ASCII_XOFF      0x13\n\n\n#include \"CoreMinimal.h\"\n#include \"UObject/NoExportTypes.h\"\n#include \"Serial.generated.h\"\n\n/**\n * \n */\n\n // Forward declaration\ntypedef struct _OVERLAPPED OVERLAPPED;\n\nUENUM(BlueprintType, Category = \"UE4Duino\")\nenum class ELineEnd : uint8\n&#123;\n\trn\tUMETA(DisplayName = \"\\r\\n\"),\n\tn\tUMETA(DisplayName = \"\\n\"),\n\tr\tUMETA(DisplayName = \"\\r\"),\n\tnr\tUMETA(DisplayName = \"\\n\\r\")\n&#125;;\n\nUCLASS(BlueprintType, Category = \"UE4Duino\", meta = (Keywords = \"com arduino serial\"))\nclass INKPROJECTION_API USerial : public UObject\n&#123;\n\tGENERATED_BODY()\npublic:\n\t/** Determines the line ending used when writing lines to serial port with PrintLine. */\n\tUPROPERTY(BlueprintReadWrite, Category = \"UE4Duino | String\")\n\t\tELineEnd WriteLineEnd;\n\npublic:\n\tUSerial();\n\t~USerial();\n\n\t/**\n\t * Open a serial port and return the created Serial instance.\n\t * Don't forget to close the port before exiting the game.\n\t *\n\t * @param bOpened If the serial port was successfully opened.\n\t * @param Port The serial port to open.\n\t * @param BaudRate BaudRate to open the serial port with.\n\t * @return A Serial instance to work with the opened port.\n\t */\n\tUFUNCTION(BlueprintCallable, meta = (DisplayName = \"Open Serial Port\"), Category = \"UE4Duino\", meta = (Keywords = \"com arduino serial start\"))\n\t\tstatic USerial* OpenComPort(bool&amp; bOpened, int32 Port = 1, int32 BaudRate = 9600);\n\n\t/**\n\t * Utility function to convert 4 bytes into an Integer. If the input array's length is not 4, returns 0.\n\t *\n\t * @param Bytes A byte array with 4 values representing the integer in little-endian format.\n\t * @return The final integer value or 0 for an invalid array.\n\t */\n\tUFUNCTION(BlueprintPure, meta = (DisplayName = \"Bytes to Int\"), Category = \"UE4Duino\", meta = (Keywords = \"cast concatenate group bit bitwise\"))\n\t\tstatic int32 BytesToInt(TArray&lt;uint8> Bytes);\n\n\t/**\n\t * Utility function to get the 4 bytes that make an integer.\n\t *\n\t * @param Int The integer value to be converted.\n\t * @return A byte array containing the 4 bytes that make the integer, starting from the least significant one (little endian).\n\t */\n\tUFUNCTION(BlueprintPure, meta = (DisplayName = \"Int to Bytes\"), Category = \"UE4Duino\", meta = (Keywords = \"cast separate bit bitwise\"))\n\t\tstatic TArray&lt;uint8> IntToBytes(const int32&amp; Int);\n\n\t/**\n\t * Utility function to convert 4 bytes into a float. If the input array's length is not 4, returns 0.0.\n\t *\n\t * @param Bytes A byte array with 4 values representing the float in IEEE 754 standard format.\n\t * @return The final float value or 0.0 for an invalid array.\n\t */\n\tUFUNCTION(BlueprintPure, meta = (DisplayName = \"Bytes to Float\"), Category = \"UE4Duino\", meta = (Keywords = \"cast concatenate group bit bitwise\"))\n\t\tstatic float BytesToFloat(TArray&lt;uint8> Bytes);\n\n\t/**\n\t * Utility function to get the 4 bytes that make a float.\n\t *\n\t * @param Float The float value to be converted.\n\t * @return A byte array containing the 4 bytes that make the float, in IEEE 754 standard format.\n\t */\n\tUFUNCTION(BlueprintPure, meta = (DisplayName = \"Float to Bytes\"), Category = \"UE4Duino\", meta = (Keywords = \"cast separate bit bitwise\"))\n\t\tstatic TArray&lt;uint8> FloatToBytes(const float&amp; Float);\n\n\t/**\n\t * Open a serial port. Don't forget to close the port before exiting the game.\n\t * If this Serial instance has already an opened port,\n\t * return false and doesn't change the opened port number.\n\t *\n\t * @param Port The serial port to open.\n\t * @param BaudRate BaudRate to open the serial port with.\n\t * @return If the serial port was successfully opened.\n\t */\n\tUFUNCTION(BlueprintCallable, meta = (DisplayName = \"Open Port\"), Category = \"UE4Duino\", meta = (Keywords = \"com start init\"))\n\t\tbool Open(int32 Port = 2, int32 BaudRate = 9600);\n\t/**\n\t * Close and end the communication with the serial port. If not open, do nothing.\n\t */\n\tUFUNCTION(BlueprintCallable, meta = (DisplayName = \"Close Port\"), Category = \"UE4Duino\", meta = (Keywords = \"com end finish release\"))\n\t\tvoid Close();\n\n\t/**\n\t * Will read characters from Serial port until \\0 (null char) is found or there are no\n\t * characters left to read.\n\t *\n\t * @param bSuccess If there was anything to read.\n\t * @return The read string\n\t */\n\tUFUNCTION(BlueprintCallable, meta = (DisplayName = \"Read String\", keywords = \"get read receive string words text characters\"), Category = \"UE4Duino\")\n\t\tFString ReadString(bool&amp; bSuccess);\n\t/**\n\t * Will read characters from Serial port until \\r\\n (Arduino println line end) is found.\n\t *\n\t * @param bSuccess If there was anything to read.\n\t * @return The read string\n\t */\n\tUFUNCTION(BlueprintCallable, meta = (DisplayName = \"Read Line\", keywords = \"get read receive string words text characters\"), Category = \"UE4Duino\")\n\t\tFString Readln(bool&amp; bSuccess);\n\t/**\n\t * Reads the string until a specific char is met.\n\t * The Terminator char won't be included in the result string.\n\t */\n\t //UFUNCTION(BlueprintCallable, meta = (DisplayName = \"Read String Until\", keywords = \"get read receive string words text characters\"), Category = \"UE4Duino\")\n\tFString ReadStringUntil(bool&amp; bSuccess, uint8 Terminator);\n\t/**\n\t * Reads a float from the serial port (sent as 4 bytes).\n\t * @param bSuccess True if there were 4 bytes to read.\n\t * @return The read value\n\t */\n\tUFUNCTION(BlueprintCallable, meta = (DisplayName = \"Read a Float\", keywords = \"get read receive\"), Category = \"UE4Duino\")\n\t\tfloat ReadFloat(bool&amp; bSuccess);\n\t/**\n\t * Reads an integer from the serial port (sent as 4 bytes).\n\t * @param bSuccess True if there were 4 bytes to read.\n\t * @return The read value\n\t */\n\tUFUNCTION(BlueprintCallable, meta = (DisplayName = \"Read an Int\", keywords = \"get read receive integer\"), Category = \"UE4Duino\")\n\t\tint32 ReadInt(bool&amp; bSuccess);\n\t/**\n\t * Reads a byte from the serial port.\n\t * @param bSuccess True if there were 4 bytes to read.\n\t * @return The read value\n\t */\n\tUFUNCTION(BlueprintCallable, meta = (DisplayName = \"Read a Byte\", keywords = \"get read receive\"), Category = \"UE4Duino\")\n\t\tuint8 ReadByte(bool&amp; bSuccess);\n\t/**\n\t * Reads up to Limit bytes from the serial port. If there are less than Limit,\n\t * reads all of them and return True.\n\t * @param bSuccess True if there was at least 1 byte to read.\n\t * @return An array containing the read bytes\n\t */\n\tUFUNCTION(BlueprintCallable, meta = (DisplayName = \"Read Bytes\", keywords = \"get read receive\"), Category = \"UE4Duino\")\n\t\tTArray&lt;uint8> ReadBytes(int32 Limit = 256);\n\n\t/**\n\t * Writes a string without newline to the serial port.\n\t * @param String The string to be sent to the serial port.\n\t * @return True if the string was sent.\n\t */\n\tUFUNCTION(BlueprintCallable, meta = (DisplayName = \"Print\", keywords = \"send write string words text characters\"), Category = \"UE4Duino\")\n\t\tbool Print(FString String);\n\t/**\n\t * Writes a string with newline (\\n) appended at the end to the serial port.\n\t * @param String The string to be sent to the serial port.\n\t * @return True if the string was sent.\n\t */\n\tUFUNCTION(BlueprintCallable, meta = (DisplayName = \"Print Line\", keywords = \"send write string words text characters\"), Category = \"UE4Duino\")\n\t\tbool Println(FString String);\n\t/**\n\t * Writes a float value to the serial port as 4 bytes.\n\t * @param Value The value to be sent to the serial port.\n\t * @return True if the bytes were sent.\n\t */\n\tUFUNCTION(BlueprintCallable, meta = (DisplayName = \"Write a Float\", keywords = \"send\"), Category = \"UE4Duino\")\n\t\tbool WriteFloat(float Value);\n\t/**\n\t * Writes an integer value to the serial port as 4 bytes.\n\t * @param Value The value to be sent to the serial port.\n\t * @return True if the bytes were sent.\n\t */\n\tUFUNCTION(BlueprintCallable, meta = (DisplayName = \"Write an Int\", keywords = \"integer send\"), Category = \"UE4Duino\")\n\t\tbool WriteInt(int32 Value);\n\t/**\n\t * Writes a byte value to the serial port.\n\t * @param Value The value to be sent to the serial port.\n\t * @return True if the byte was sent.\n\t */\n\tUFUNCTION(BlueprintCallable, meta = (DisplayName = \"Write a Byte\", keywords = \"send\"), Category = \"UE4Duino\")\n\t\tbool WriteByte(uint8 Value);\n\t/**\n\t * Writes a byte array as a sequence of bytes to the serial port.\n\t * @param Buffer The byte array to be sent to the serial port.\n\t * @return True if the bytes were sent.\n\t */\n\tUFUNCTION(BlueprintCallable, meta = (DisplayName = \"Write Bytes\", keywords = \"send\"), Category = \"UE4Duino\")\n\t\tbool WriteBytes(TArray&lt;uint8> Buffer);\n\n\t/** Clean the serial port by reading everything left to be read. */\n\tUFUNCTION(BlueprintCallable, meta = (DisplayName = \"Flush Port\"), Category = \"UE4Duino\")\n\t\tvoid Flush();\n\n\t/**\n\t * Check if the serial port is open.\n\t * @return True if the serial port is open.\n\t */\n\tUFUNCTION(BlueprintPure, meta = (DisplayName = \"Is Port Open\"), Category = \"UE4Duino\")\n\t\tbool IsOpened() &#123; return m_hIDComDev != NULL; &#125;\n\n\t/**\n\t * Read the number of the serial port selected for this Serial instance.\n\t * @return The number of the serial port.\n\t */\n\tUFUNCTION(BlueprintPure, meta = (DisplayName = \"Get Port Number\"), Category = \"UE4Duino\")\n\t\tint32 GetPort() &#123; return m_Port; &#125;\n\n\t/**\n\t * Read the selected BaudRate for this Serial instance.\n\t * @return The baud rate.\n\t */\n\tUFUNCTION(BlueprintPure, meta = (DisplayName = \"Get Baud Rate\"), Category = \"UE4Duino\")\n\t\tint32 GetBaud() &#123; return m_Baud; &#125;\n\n\t/**\n\t * Converts a LineEnd enum value to String.\n\t * @param LineEnd LineEnd enum value.\n\t * @return The LineEnd value in string format.\n\t */\n\tUFUNCTION(BlueprintCallable, meta = (DisplayName = \"Line End to String\", keywords = \"cast convert\"), Category = \"UE4Duino\")\n\t\tFString LineEndToStr(ELineEnd LineEnd);\n\nprotected:\n\tvoid* m_hIDComDev;\n\n\t// These are pointers to be able to use OVERLAPPED with forward declaration\n\tOVERLAPPED* m_OverlappedRead;\n\tOVERLAPPED* m_OverlappedWrite;\n\n\tint32 m_Port;\n\tint32 m_Baud;\n&#125;;\n\n.cpp文件\n// Fill out your copyright notice in the Description page of Project Settings.\n\n\n#include \"Serial.h\"\n\n#include \"Windows/AllowWindowsPlatformTypes.h\"\n#include \"Windows/MinWindows.h\"\n#include \"Windows/HideWindowsPlatformTypes.h\"\n#include&lt;iostream>\n#include&lt;cmath>\n#include&lt;cstring>\n\nusing namespace std;\n#define BOOL2bool(B) B == 0 ? false : true\n\nUSerial* USerial::OpenComPort(bool&amp; bOpened, int32 Port, int32 BaudRate)\n&#123;\n\tUSerial* Serial = NewObject&lt;USerial>();\n\tbOpened = Serial->Open(Port, BaudRate);\n\treturn Serial;\n&#125;\n\nint32 USerial::BytesToInt(TArray&lt;uint8> Bytes)\n&#123;\n\tif (Bytes.Num() != 4)\n\t&#123;\n\t\treturn 0;\n\t&#125;\n\n\treturn *reinterpret_cast&lt;int32*>(Bytes.GetData());\n&#125;\n\nTArray&lt;uint8> USerial::IntToBytes(const int32&amp; Int)\n&#123;\n\tTArray&lt;uint8> Bytes;\n\tBytes.Append(reinterpret_cast&lt;const uint8*>(&amp;Int), 4);\n\treturn Bytes;\n&#125;\n\nfloat USerial::BytesToFloat(TArray&lt;uint8> Bytes)\n&#123;\n\tif (Bytes.Num() != 4)\n\t&#123;\n\t\treturn 0;\n\t&#125;\n\n\treturn *reinterpret_cast&lt;float*>(Bytes.GetData());\n&#125;\n\nTArray&lt;uint8> USerial::FloatToBytes(const float&amp; Float)\n&#123;\n\tTArray&lt;uint8> Bytes;\n\tBytes.Append(reinterpret_cast&lt;const uint8*>(&amp;Float), 4);\n\treturn Bytes;\n&#125;\n\nUSerial::USerial()\n\t: WriteLineEnd(ELineEnd::n)\n\t, m_hIDComDev(nullptr)\n\t, m_OverlappedRead(nullptr)\n\t, m_OverlappedWrite(nullptr)\n\t, m_Port(-1)\n\t, m_Baud(-1)\n&#123;\n\t// Allocate the OVERLAPPED structs\n\tm_OverlappedRead = new OVERLAPPED();\n\tm_OverlappedWrite = new OVERLAPPED();\n\n\tFMemory::Memset(m_OverlappedRead, 0, sizeof(OVERLAPPED));\n\tFMemory::Memset(m_OverlappedWrite, 0, sizeof(OVERLAPPED));\n&#125;\n\nUSerial::~USerial()\n&#123;\n\tClose();\n\n\t// Delete allocated OVERLAPPED structs\n\tdelete m_OverlappedRead;\n\tdelete m_OverlappedWrite;\n&#125;\n\nbool USerial::Open(int32 nPort, int32 nBaud)\n&#123;\n\tif (nPort &lt; 0)\n\t&#123;\n\t\tUE_LOG(LogTemp, Error, TEXT(\"Invalid port number: %d\"), nPort);\n\t\treturn false;\n\t&#125;\n\tif (m_hIDComDev)\n\t&#123;\n\t\tUE_LOG(LogTemp, Warning, TEXT(\"Trying to use opened Serial instance to open a new one. \"\n\t\t\t\"Current open instance port: %d | Port tried: %d\"), m_Port, nPort);\n\t\treturn false;\n\t&#125;\n\n\tFString szPort;\n\tif (nPort &lt; 10)\n\t\tszPort = FString::Printf(TEXT(\"COM%d\"), nPort);\n\telse\n\t\tszPort = FString::Printf(TEXT(\"\\\\\\\\.\\\\COM%d\"), nPort);\n\tDCB dcb;\n\n\tm_hIDComDev = CreateFile(*szPort, GENERIC_READ | GENERIC_WRITE, 0, NULL, OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL | FILE_FLAG_OVERLAPPED, NULL);\n\tif (m_hIDComDev == NULL)\n\t&#123;\n\t\tunsigned long dwError = GetLastError();\n\t\tUE_LOG(LogTemp, Error, TEXT(\"Failed to open port COM%d (%s). Error: %08X\"), nPort, *szPort, dwError);\n\t\treturn false;\n\t&#125;\n\n\tFMemory::Memset(m_OverlappedRead, 0, sizeof(OVERLAPPED));\n\tFMemory::Memset(m_OverlappedWrite, 0, sizeof(OVERLAPPED));\n\n\tCOMMTIMEOUTS CommTimeOuts;\n\t//CommTimeOuts.ReadIntervalTimeout = 10;\n\tCommTimeOuts.ReadIntervalTimeout = 0xFFFFFFFF;\n\tCommTimeOuts.ReadTotalTimeoutMultiplier = 0;\n\tCommTimeOuts.ReadTotalTimeoutConstant = 0;\n\tCommTimeOuts.WriteTotalTimeoutMultiplier = 0;\n\tCommTimeOuts.WriteTotalTimeoutConstant = 10;\n\tSetCommTimeouts(m_hIDComDev, &amp;CommTimeOuts);\n\n\tm_OverlappedRead->hEvent = CreateEvent(NULL, true, false, NULL);\n\tm_OverlappedWrite->hEvent = CreateEvent(NULL, true, false, NULL);\n\n\tdcb.DCBlength = sizeof(DCB);\n\tGetCommState(m_hIDComDev, &amp;dcb);\n\tdcb.BaudRate = nBaud;\n\tdcb.ByteSize = 8;\n\n\tif (!SetCommState(m_hIDComDev, &amp;dcb) ||\n\t\t!SetupComm(m_hIDComDev, 10000, 10000) ||\n\t\tm_OverlappedRead->hEvent == NULL ||\n\t\tm_OverlappedWrite->hEvent == NULL)\n\t&#123;\n\t\tunsigned long dwError = GetLastError();\n\t\tif (m_OverlappedRead->hEvent != NULL) CloseHandle(m_OverlappedRead->hEvent);\n\t\tif (m_OverlappedWrite->hEvent != NULL) CloseHandle(m_OverlappedWrite->hEvent);\n\t\tCloseHandle(m_hIDComDev);\n\t\tm_hIDComDev = NULL;\n\t\tUE_LOG(LogTemp, Error, TEXT(\"Failed to setup port COM%d. Error: %08X\"), nPort, dwError);\n\t\treturn false;\n\t&#125;\n\n\t//FPlatformProcess::Sleep(0.05f);\n\tAddToRoot();\n\tm_Port = nPort;\n\tm_Baud = nBaud;\n\treturn true;\n&#125;\n\nvoid USerial::Close()\n&#123;\n\tif (!m_hIDComDev) return;\n\n\tif (m_OverlappedRead->hEvent != NULL) CloseHandle(m_OverlappedRead->hEvent);\n\tif (m_OverlappedWrite->hEvent != NULL) CloseHandle(m_OverlappedWrite->hEvent);\n\tCloseHandle(m_hIDComDev);\n\tm_hIDComDev = NULL;\n\n\tRemoveFromRoot();\n&#125;\n\nFString USerial::ReadString(bool&amp; bSuccess)\n&#123;\n\treturn ReadStringUntil(bSuccess, '\\0');\n&#125;\n\nFString USerial::Readln(bool&amp; bSuccess)\n&#123;\n\treturn ReadStringUntil(bSuccess, '\\n');\n&#125;\n\nFString USerial::ReadStringUntil(bool&amp; bSuccess, uint8 Terminator)\n&#123;\n\tbSuccess = false;\n\tif (!m_hIDComDev) return TEXT(\"\");\n\n\tTArray&lt;uint8> Chars;\n\tuint8 Byte = 0x0;\n\tbool bReadStatus;\n\tunsigned long dwBytesRead, dwErrorFlags;\n\tCOMSTAT ComStat;\n\n\tClearCommError(m_hIDComDev, &amp;dwErrorFlags, &amp;ComStat);\n\tif (!ComStat.cbInQue) return TEXT(\"\");\n\n\tdo &#123;\n\t\tbReadStatus = BOOL2bool(ReadFile(\n\t\t\tm_hIDComDev,\n\t\t\t&amp;Byte,\n\t\t\t1,\n\t\t\t&amp;dwBytesRead,\n\t\t\tm_OverlappedRead));\n\n\t\tif (!bReadStatus)\n\t\t&#123;\n\t\t\tif (GetLastError() == ERROR_IO_PENDING)\n\t\t\t&#123;\n\t\t\t\tWaitForSingleObject(m_OverlappedRead->hEvent, 2000);\n\t\t\t&#125;\n\t\t\telse\n\t\t\t&#123;\n\t\t\t\tChars.Add(0x0);\n\t\t\t\tbreak;\n\t\t\t&#125;\n\t\t&#125;\n\n\t\tif (Byte == Terminator || dwBytesRead == 0)\n\t\t&#123;\n\t\t\t// when Terminator is \\n, we know we're expecting lines from Arduino. But those\n\t\t\t// are ended in \\r\\n. That means that if we found the line Terminator (\\n), our previous\n\t\t\t// character could be \\r. If it is, we remove that from the array.\n\t\t\tif (Chars.Num() > 0 &amp;&amp; Terminator == '\\n' &amp;&amp; Chars.Top() == '\\r') Chars.Pop(false);\n\n\t\t\tChars.Add(0x0);\n\t\t\tbreak;\n\t\t&#125;\n\t\telse Chars.Add(Byte);\n\n\t&#125; while (Byte != 0x0 &amp;&amp; Byte != Terminator);\n\n\tbSuccess = true;\n\tauto Convert = FUTF8ToTCHAR((ANSICHAR*)Chars.GetData());\n\treturn FString(Convert.Get());\n&#125;\n\nfloat USerial::ReadFloat(bool&amp; bSuccess)\n&#123;\n\tbSuccess = false;\n\n\tTArray&lt;uint8> Bytes = ReadBytes(4);\n\tif (Bytes.Num() == 0) return 0;\n\n\tbSuccess = true;\n\treturn *(reinterpret_cast&lt;float*>(Bytes.GetData()));\n&#125;\n\nint32 USerial::ReadInt(bool&amp; bSuccess)\n&#123;\n\tbSuccess = false;\n\n\tTArray&lt;uint8> Bytes = ReadBytes(4);\n\tif (Bytes.Num() == 0) return 0;\n\n\tbSuccess = true;\n\treturn *(reinterpret_cast&lt;int32*>(Bytes.GetData()));\n&#125;\n\nuint8 USerial::ReadByte(bool&amp; bSuccess)\n&#123;\n\tbSuccess = false;\n\tif (!m_hIDComDev) return 0x0;\n\n\tuint8 Byte = 0x0;\n\tbool bReadStatus;\n\tunsigned long dwBytesRead, dwErrorFlags;\n\tCOMSTAT ComStat;\n\n\tClearCommError(m_hIDComDev, &amp;dwErrorFlags, &amp;ComStat);\n\tif (!ComStat.cbInQue) return 0x0;\n\n\tbReadStatus = BOOL2bool(ReadFile(\n\t\tm_hIDComDev,\n\t\t&amp;Byte,\n\t\t1,\n\t\t&amp;dwBytesRead,\n\t\tm_OverlappedRead));\n\n\tif (!bReadStatus)\n\t&#123;\n\t\tif (GetLastError() == ERROR_IO_PENDING)\n\t\t&#123;\n\t\t\tWaitForSingleObject(m_OverlappedRead->hEvent, 2000);\n\t\t&#125;\n\t\telse\n\t\t&#123;\n\t\t\treturn 0x0;\n\t\t&#125;\n\t&#125;\n\n\tbSuccess = dwBytesRead > 0;\n\treturn Byte;\n&#125;\n\nTArray&lt;uint8> USerial::ReadBytes(int32 Limit)\n&#123;\n\tTArray&lt;uint8> Data;\n\n\tif (!m_hIDComDev) return Data;\n\n\tData.Empty(Limit);\n\n\tuint8* Buffer = new uint8[Limit];\n\tbool bReadStatus;\n\tunsigned long dwBytesRead, dwErrorFlags;\n\tCOMSTAT ComStat;\n\n\tClearCommError(m_hIDComDev, &amp;dwErrorFlags, &amp;ComStat);\n\tif (!ComStat.cbInQue) return Data;\n\n\tbReadStatus = BOOL2bool(ReadFile(\n\t\tm_hIDComDev,\n\t\tBuffer,\n\t\tLimit,\n\t\t&amp;dwBytesRead,\n\t\tm_OverlappedRead));\n\n\tif (!bReadStatus)\n\t&#123;\n\t\tif (GetLastError() == ERROR_IO_PENDING)\n\t\t&#123;\n\t\t\tWaitForSingleObject(m_OverlappedRead->hEvent, 2000);\n\t\t&#125;\n\t\telse\n\t\t&#123;\n\t\t\treturn Data;\n\t\t&#125;\n\t&#125;\n\n\tData.Append(Buffer, dwBytesRead);\n\treturn Data;\n&#125;\n\nbool USerial::Print(FString String)\n&#123;\n\tauto Convert = FTCHARToUTF8(*String);\n\tTArray&lt;uint8> Data;\n\tData.Append((uint8*)Convert.Get(), Convert.Length());\n\n\treturn WriteBytes(Data);\n&#125;\n\nbool USerial::Println(FString String)\n&#123;\n\treturn Print(String + LineEndToStr(WriteLineEnd));\n&#125;\n\nbool USerial::WriteFloat(float Value)\n&#123;\n\tTArray&lt;uint8> Buffer;\n\tBuffer.Append(reinterpret_cast&lt;uint8*>(&amp;Value), 4);\n\treturn WriteBytes(Buffer);\n&#125;\n\nbool USerial::WriteInt(int32 Value)\n&#123;\n\tTArray&lt;uint8> Buffer;\n\tBuffer.Append(reinterpret_cast&lt;uint8*>(&amp;Value), 4);\n\treturn WriteBytes(Buffer);\n&#125;\n\nbool USerial::WriteByte(uint8 Value)\n&#123;\n\tTArray&lt;uint8> Buffer(&#123; Value &#125;);\n\treturn WriteBytes(Buffer);\n&#125;\n\nbool USerial::WriteBytes(TArray&lt;uint8> Buffer)\n&#123;\n\tif (!m_hIDComDev) false;\n\n\tbool bWriteStat;\n\tunsigned long dwBytesWritten;\n\n\tbWriteStat = BOOL2bool(WriteFile(m_hIDComDev, Buffer.GetData(), Buffer.Num(), &amp;dwBytesWritten, m_OverlappedWrite));\n\tif (!bWriteStat &amp;&amp; (GetLastError() == ERROR_IO_PENDING))\n\t&#123;\n\t\tif (WaitForSingleObject(m_OverlappedWrite->hEvent, 1000))\n\t\t&#123;\n\t\t\tdwBytesWritten = 0;\n\t\t\treturn false;\n\t\t&#125;\n\t\telse\n\t\t&#123;\n\t\t\tGetOverlappedResult(m_hIDComDev, m_OverlappedWrite, &amp;dwBytesWritten, false);\n\t\t\tm_OverlappedWrite->Offset += dwBytesWritten;\n\t\t\treturn true;\n\t\t&#125;\n\t&#125;\n\n\treturn true;\n&#125;\n\nvoid USerial::Flush()\n&#123;\n\tif (!m_hIDComDev) return;\n\n\tTArray&lt;uint8> Data;\n\n\tdo &#123;\n\t\tData = ReadBytes(8192);\n\t&#125; while (Data.Num() > 0);\n&#125;\n\nFString USerial::LineEndToStr(ELineEnd LineEnd)\n&#123;\n\tswitch (LineEnd)\n\t&#123;\n\tcase ELineEnd::rn:\n\t\treturn TEXT(\"\\r\\n\");\n\tcase ELineEnd::n:\n\t\treturn TEXT(\"\\n\");\n\tcase ELineEnd::r:\n\t\treturn TEXT(\"\\r\");\n\tcase ELineEnd::nr:\n\t\treturn TEXT(\"\\n\\r\");\n\tdefault:\n\t\treturn TEXT(\"null\");\n\t&#125;\n&#125;\n蓝图使用\n\n蓝图代码连接https://blueprintue.com/blueprint/ss-s-s83/\n\n\n","slug":"UE串口通信","date":"2022-07-22T08:14:36.000Z","categories_index":"UnrealEngine","tags_index":"串口通信","author_index":"cBao"},{"id":"650e8b54c427468049a9eded7ddf3373","title":"C++仿函数和代理","content":"仿函数\n\n\n\n\n\n提示\n需要头文件#include &lt; functional &gt;\n\n仿函数与普通函数#include &lt;iostream>\n#include &lt;functional>\n\nint Test(int A, int B)\n&#123;\n\tstd::cout&lt;&lt;A+B&lt;&lt;std::endl;\n\treturn A+B;\n&#125;\n\nint main()\n&#123;\n\tstd::function&lt;int(int,int)> Func_Test=Test;\n\tFunc_Test(2,3);\n&#125;\n\n\nint(int,int)：返回类型(形参列表)\n\n仿函数与Lambda#include &lt;iostream>\n#include &lt;functional>\n\nauto Lam=[&amp;](int A,int B)\n&#123;\n\tstd::cout&lt;&lt;A+B&lt;&lt;std::endl;\n\treturn A+B;\n&#125;;\n\nint main()\n&#123;\n\tstd::function&lt;int(int,int)> Fun_Test=Lam;\n\tFun_Test(3,4);\n&#125;\n\n","slug":"C++仿函数和代理","date":"2022-07-17T07:19:09.000Z","categories_index":"C++","tags_index":"仿函数和代理","author_index":"cBao"},{"id":"f58daaa95359f10d1d47b72330587f5d","title":"VisualStudio常用操作","content":"Visual Studio中常用的快捷键\n\n\n快捷键\n功能\n\n\n\nCtrl + K, O\n在头文件与源文件之间切换\n\n\nCtrl + K, C\n注释选择行\n\n\nCtrl + K, U\n取消选择行的注释\n\n\nCtrl + K, D\n对齐所有代码\n\n\nCtrl+Shift+U\n全部变为大写\n\n\nCtrl+U\n全部变为小写\n\n\nAlt+鼠标左按钮\n选择矩形文本\n\n\nCtrl+F\n在当前文件中查找\n\n\nCtrl+Shift+F\n在当前的解决方案中查找\n\n\n","slug":"Visual Studio常用操作","date":"2022-07-07T03:18:50.000Z","categories_index":"IDE","tags_index":"Visual Studio","author_index":"cBao"}]