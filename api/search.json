[{"id":"32edd7bc4a69fac72c5e2e1809026b07","title":"UE串口通信","content":"sdasfsa\nUE串口通信\n.h文件\n#pragma once\n\n#define FC_DTRDSR       0x01\n#define FC_RTSCTS       0x02\n#define FC_XONXOFF      0x04\n#define ASCII_BEL       0x07\n#define ASCII_BS        0x08\n#define ASCII_LF        0x0A\n#define ASCII_CR        0x0D\n#define ASCII_XON       0x11\n#define ASCII_XOFF      0x13\n\n\n#include \"CoreMinimal.h\"\n#include \"UObject/NoExportTypes.h\"\n#include \"Serial.generated.h\"\n\n/**\n * \n */\n\n // Forward declaration\ntypedef struct _OVERLAPPED OVERLAPPED;\n\nUENUM(BlueprintType, Category = \"UE4Duino\")\nenum class ELineEnd : uint8\n&#123;\n\trn\tUMETA(DisplayName = \"\\r\\n\"),\n\tn\tUMETA(DisplayName = \"\\n\"),\n\tr\tUMETA(DisplayName = \"\\r\"),\n\tnr\tUMETA(DisplayName = \"\\n\\r\")\n&#125;;\n\nUCLASS(BlueprintType, Category = \"UE4Duino\", meta = (Keywords = \"com arduino serial\"))\nclass INKPROJECTION_API USerial : public UObject\n&#123;\n\tGENERATED_BODY()\npublic:\n\t/** Determines the line ending used when writing lines to serial port with PrintLine. */\n\tUPROPERTY(BlueprintReadWrite, Category = \"UE4Duino | String\")\n\t\tELineEnd WriteLineEnd;\n\npublic:\n\tUSerial();\n\t~USerial();\n\n\t/**\n\t * Open a serial port and return the created Serial instance.\n\t * Don't forget to close the port before exiting the game.\n\t *\n\t * @param bOpened If the serial port was successfully opened.\n\t * @param Port The serial port to open.\n\t * @param BaudRate BaudRate to open the serial port with.\n\t * @return A Serial instance to work with the opened port.\n\t */\n\tUFUNCTION(BlueprintCallable, meta = (DisplayName = \"Open Serial Port\"), Category = \"UE4Duino\", meta = (Keywords = \"com arduino serial start\"))\n\t\tstatic USerial* OpenComPort(bool&amp; bOpened, int32 Port = 1, int32 BaudRate = 9600);\n\n\t/**\n\t * Utility function to convert 4 bytes into an Integer. If the input array's length is not 4, returns 0.\n\t *\n\t * @param Bytes A byte array with 4 values representing the integer in little-endian format.\n\t * @return The final integer value or 0 for an invalid array.\n\t */\n\tUFUNCTION(BlueprintPure, meta = (DisplayName = \"Bytes to Int\"), Category = \"UE4Duino\", meta = (Keywords = \"cast concatenate group bit bitwise\"))\n\t\tstatic int32 BytesToInt(TArray&lt;uint8> Bytes);\n\n\t/**\n\t * Utility function to get the 4 bytes that make an integer.\n\t *\n\t * @param Int The integer value to be converted.\n\t * @return A byte array containing the 4 bytes that make the integer, starting from the least significant one (little endian).\n\t */\n\tUFUNCTION(BlueprintPure, meta = (DisplayName = \"Int to Bytes\"), Category = \"UE4Duino\", meta = (Keywords = \"cast separate bit bitwise\"))\n\t\tstatic TArray&lt;uint8> IntToBytes(const int32&amp; Int);\n\n\t/**\n\t * Utility function to convert 4 bytes into a float. If the input array's length is not 4, returns 0.0.\n\t *\n\t * @param Bytes A byte array with 4 values representing the float in IEEE 754 standard format.\n\t * @return The final float value or 0.0 for an invalid array.\n\t */\n\tUFUNCTION(BlueprintPure, meta = (DisplayName = \"Bytes to Float\"), Category = \"UE4Duino\", meta = (Keywords = \"cast concatenate group bit bitwise\"))\n\t\tstatic float BytesToFloat(TArray&lt;uint8> Bytes);\n\n\t/**\n\t * Utility function to get the 4 bytes that make a float.\n\t *\n\t * @param Float The float value to be converted.\n\t * @return A byte array containing the 4 bytes that make the float, in IEEE 754 standard format.\n\t */\n\tUFUNCTION(BlueprintPure, meta = (DisplayName = \"Float to Bytes\"), Category = \"UE4Duino\", meta = (Keywords = \"cast separate bit bitwise\"))\n\t\tstatic TArray&lt;uint8> FloatToBytes(const float&amp; Float);\n\n\t/**\n\t * Open a serial port. Don't forget to close the port before exiting the game.\n\t * If this Serial instance has already an opened port,\n\t * return false and doesn't change the opened port number.\n\t *\n\t * @param Port The serial port to open.\n\t * @param BaudRate BaudRate to open the serial port with.\n\t * @return If the serial port was successfully opened.\n\t */\n\tUFUNCTION(BlueprintCallable, meta = (DisplayName = \"Open Port\"), Category = \"UE4Duino\", meta = (Keywords = \"com start init\"))\n\t\tbool Open(int32 Port = 2, int32 BaudRate = 9600);\n\t/**\n\t * Close and end the communication with the serial port. If not open, do nothing.\n\t */\n\tUFUNCTION(BlueprintCallable, meta = (DisplayName = \"Close Port\"), Category = \"UE4Duino\", meta = (Keywords = \"com end finish release\"))\n\t\tvoid Close();\n\n\t/**\n\t * Will read characters from Serial port until \\0 (null char) is found or there are no\n\t * characters left to read.\n\t *\n\t * @param bSuccess If there was anything to read.\n\t * @return The read string\n\t */\n\tUFUNCTION(BlueprintCallable, meta = (DisplayName = \"Read String\", keywords = \"get read receive string words text characters\"), Category = \"UE4Duino\")\n\t\tFString ReadString(bool&amp; bSuccess);\n\t/**\n\t * Will read characters from Serial port until \\r\\n (Arduino println line end) is found.\n\t *\n\t * @param bSuccess If there was anything to read.\n\t * @return The read string\n\t */\n\tUFUNCTION(BlueprintCallable, meta = (DisplayName = \"Read Line\", keywords = \"get read receive string words text characters\"), Category = \"UE4Duino\")\n\t\tFString Readln(bool&amp; bSuccess);\n\t/**\n\t * Reads the string until a specific char is met.\n\t * The Terminator char won't be included in the result string.\n\t */\n\t //UFUNCTION(BlueprintCallable, meta = (DisplayName = \"Read String Until\", keywords = \"get read receive string words text characters\"), Category = \"UE4Duino\")\n\tFString ReadStringUntil(bool&amp; bSuccess, uint8 Terminator);\n\t/**\n\t * Reads a float from the serial port (sent as 4 bytes).\n\t * @param bSuccess True if there were 4 bytes to read.\n\t * @return The read value\n\t */\n\tUFUNCTION(BlueprintCallable, meta = (DisplayName = \"Read a Float\", keywords = \"get read receive\"), Category = \"UE4Duino\")\n\t\tfloat ReadFloat(bool&amp; bSuccess);\n\t/**\n\t * Reads an integer from the serial port (sent as 4 bytes).\n\t * @param bSuccess True if there were 4 bytes to read.\n\t * @return The read value\n\t */\n\tUFUNCTION(BlueprintCallable, meta = (DisplayName = \"Read an Int\", keywords = \"get read receive integer\"), Category = \"UE4Duino\")\n\t\tint32 ReadInt(bool&amp; bSuccess);\n\t/**\n\t * Reads a byte from the serial port.\n\t * @param bSuccess True if there were 4 bytes to read.\n\t * @return The read value\n\t */\n\tUFUNCTION(BlueprintCallable, meta = (DisplayName = \"Read a Byte\", keywords = \"get read receive\"), Category = \"UE4Duino\")\n\t\tuint8 ReadByte(bool&amp; bSuccess);\n\t/**\n\t * Reads up to Limit bytes from the serial port. If there are less than Limit,\n\t * reads all of them and return True.\n\t * @param bSuccess True if there was at least 1 byte to read.\n\t * @return An array containing the read bytes\n\t */\n\tUFUNCTION(BlueprintCallable, meta = (DisplayName = \"Read Bytes\", keywords = \"get read receive\"), Category = \"UE4Duino\")\n\t\tTArray&lt;uint8> ReadBytes(int32 Limit = 256);\n\n\t/**\n\t * Writes a string without newline to the serial port.\n\t * @param String The string to be sent to the serial port.\n\t * @return True if the string was sent.\n\t */\n\tUFUNCTION(BlueprintCallable, meta = (DisplayName = \"Print\", keywords = \"send write string words text characters\"), Category = \"UE4Duino\")\n\t\tbool Print(FString String);\n\t/**\n\t * Writes a string with newline (\\n) appended at the end to the serial port.\n\t * @param String The string to be sent to the serial port.\n\t * @return True if the string was sent.\n\t */\n\tUFUNCTION(BlueprintCallable, meta = (DisplayName = \"Print Line\", keywords = \"send write string words text characters\"), Category = \"UE4Duino\")\n\t\tbool Println(FString String);\n\t/**\n\t * Writes a float value to the serial port as 4 bytes.\n\t * @param Value The value to be sent to the serial port.\n\t * @return True if the bytes were sent.\n\t */\n\tUFUNCTION(BlueprintCallable, meta = (DisplayName = \"Write a Float\", keywords = \"send\"), Category = \"UE4Duino\")\n\t\tbool WriteFloat(float Value);\n\t/**\n\t * Writes an integer value to the serial port as 4 bytes.\n\t * @param Value The value to be sent to the serial port.\n\t * @return True if the bytes were sent.\n\t */\n\tUFUNCTION(BlueprintCallable, meta = (DisplayName = \"Write an Int\", keywords = \"integer send\"), Category = \"UE4Duino\")\n\t\tbool WriteInt(int32 Value);\n\t/**\n\t * Writes a byte value to the serial port.\n\t * @param Value The value to be sent to the serial port.\n\t * @return True if the byte was sent.\n\t */\n\tUFUNCTION(BlueprintCallable, meta = (DisplayName = \"Write a Byte\", keywords = \"send\"), Category = \"UE4Duino\")\n\t\tbool WriteByte(uint8 Value);\n\t/**\n\t * Writes a byte array as a sequence of bytes to the serial port.\n\t * @param Buffer The byte array to be sent to the serial port.\n\t * @return True if the bytes were sent.\n\t */\n\tUFUNCTION(BlueprintCallable, meta = (DisplayName = \"Write Bytes\", keywords = \"send\"), Category = \"UE4Duino\")\n\t\tbool WriteBytes(TArray&lt;uint8> Buffer);\n\n\t/** Clean the serial port by reading everything left to be read. */\n\tUFUNCTION(BlueprintCallable, meta = (DisplayName = \"Flush Port\"), Category = \"UE4Duino\")\n\t\tvoid Flush();\n\n\t/**\n\t * Check if the serial port is open.\n\t * @return True if the serial port is open.\n\t */\n\tUFUNCTION(BlueprintPure, meta = (DisplayName = \"Is Port Open\"), Category = \"UE4Duino\")\n\t\tbool IsOpened() &#123; return m_hIDComDev != NULL; &#125;\n\n\t/**\n\t * Read the number of the serial port selected for this Serial instance.\n\t * @return The number of the serial port.\n\t */\n\tUFUNCTION(BlueprintPure, meta = (DisplayName = \"Get Port Number\"), Category = \"UE4Duino\")\n\t\tint32 GetPort() &#123; return m_Port; &#125;\n\n\t/**\n\t * Read the selected BaudRate for this Serial instance.\n\t * @return The baud rate.\n\t */\n\tUFUNCTION(BlueprintPure, meta = (DisplayName = \"Get Baud Rate\"), Category = \"UE4Duino\")\n\t\tint32 GetBaud() &#123; return m_Baud; &#125;\n\n\t/**\n\t * Converts a LineEnd enum value to String.\n\t * @param LineEnd LineEnd enum value.\n\t * @return The LineEnd value in string format.\n\t */\n\tUFUNCTION(BlueprintCallable, meta = (DisplayName = \"Line End to String\", keywords = \"cast convert\"), Category = \"UE4Duino\")\n\t\tFString LineEndToStr(ELineEnd LineEnd);\n\nprotected:\n\tvoid* m_hIDComDev;\n\n\t// These are pointers to be able to use OVERLAPPED with forward declaration\n\tOVERLAPPED* m_OverlappedRead;\n\tOVERLAPPED* m_OverlappedWrite;\n\n\tint32 m_Port;\n\tint32 m_Baud;\n&#125;;\n\n.cpp文件\n// Fill out your copyright notice in the Description page of Project Settings.\n\n\n#include \"Serial.h\"\n\n#include \"Windows/AllowWindowsPlatformTypes.h\"\n#include \"Windows/MinWindows.h\"\n#include \"Windows/HideWindowsPlatformTypes.h\"\n#include&lt;iostream>\n#include&lt;cmath>\n#include&lt;cstring>\n\nusing namespace std;\n#define BOOL2bool(B) B == 0 ? false : true\n\nUSerial* USerial::OpenComPort(bool&amp; bOpened, int32 Port, int32 BaudRate)\n&#123;\n\tUSerial* Serial = NewObject&lt;USerial>();\n\tbOpened = Serial->Open(Port, BaudRate);\n\treturn Serial;\n&#125;\n\nint32 USerial::BytesToInt(TArray&lt;uint8> Bytes)\n&#123;\n\tif (Bytes.Num() != 4)\n\t&#123;\n\t\treturn 0;\n\t&#125;\n\n\treturn *reinterpret_cast&lt;int32*>(Bytes.GetData());\n&#125;\n\nTArray&lt;uint8> USerial::IntToBytes(const int32&amp; Int)\n&#123;\n\tTArray&lt;uint8> Bytes;\n\tBytes.Append(reinterpret_cast&lt;const uint8*>(&amp;Int), 4);\n\treturn Bytes;\n&#125;\n\nfloat USerial::BytesToFloat(TArray&lt;uint8> Bytes)\n&#123;\n\tif (Bytes.Num() != 4)\n\t&#123;\n\t\treturn 0;\n\t&#125;\n\n\treturn *reinterpret_cast&lt;float*>(Bytes.GetData());\n&#125;\n\nTArray&lt;uint8> USerial::FloatToBytes(const float&amp; Float)\n&#123;\n\tTArray&lt;uint8> Bytes;\n\tBytes.Append(reinterpret_cast&lt;const uint8*>(&amp;Float), 4);\n\treturn Bytes;\n&#125;\n\nUSerial::USerial()\n\t: WriteLineEnd(ELineEnd::n)\n\t, m_hIDComDev(nullptr)\n\t, m_OverlappedRead(nullptr)\n\t, m_OverlappedWrite(nullptr)\n\t, m_Port(-1)\n\t, m_Baud(-1)\n&#123;\n\t// Allocate the OVERLAPPED structs\n\tm_OverlappedRead = new OVERLAPPED();\n\tm_OverlappedWrite = new OVERLAPPED();\n\n\tFMemory::Memset(m_OverlappedRead, 0, sizeof(OVERLAPPED));\n\tFMemory::Memset(m_OverlappedWrite, 0, sizeof(OVERLAPPED));\n&#125;\n\nUSerial::~USerial()\n&#123;\n\tClose();\n\n\t// Delete allocated OVERLAPPED structs\n\tdelete m_OverlappedRead;\n\tdelete m_OverlappedWrite;\n&#125;\n\nbool USerial::Open(int32 nPort, int32 nBaud)\n&#123;\n\tif (nPort &lt; 0)\n\t&#123;\n\t\tUE_LOG(LogTemp, Error, TEXT(\"Invalid port number: %d\"), nPort);\n\t\treturn false;\n\t&#125;\n\tif (m_hIDComDev)\n\t&#123;\n\t\tUE_LOG(LogTemp, Warning, TEXT(\"Trying to use opened Serial instance to open a new one. \"\n\t\t\t\"Current open instance port: %d | Port tried: %d\"), m_Port, nPort);\n\t\treturn false;\n\t&#125;\n\n\tFString szPort;\n\tif (nPort &lt; 10)\n\t\tszPort = FString::Printf(TEXT(\"COM%d\"), nPort);\n\telse\n\t\tszPort = FString::Printf(TEXT(\"\\\\\\\\.\\\\COM%d\"), nPort);\n\tDCB dcb;\n\n\tm_hIDComDev = CreateFile(*szPort, GENERIC_READ | GENERIC_WRITE, 0, NULL, OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL | FILE_FLAG_OVERLAPPED, NULL);\n\tif (m_hIDComDev == NULL)\n\t&#123;\n\t\tunsigned long dwError = GetLastError();\n\t\tUE_LOG(LogTemp, Error, TEXT(\"Failed to open port COM%d (%s). Error: %08X\"), nPort, *szPort, dwError);\n\t\treturn false;\n\t&#125;\n\n\tFMemory::Memset(m_OverlappedRead, 0, sizeof(OVERLAPPED));\n\tFMemory::Memset(m_OverlappedWrite, 0, sizeof(OVERLAPPED));\n\n\tCOMMTIMEOUTS CommTimeOuts;\n\t//CommTimeOuts.ReadIntervalTimeout = 10;\n\tCommTimeOuts.ReadIntervalTimeout = 0xFFFFFFFF;\n\tCommTimeOuts.ReadTotalTimeoutMultiplier = 0;\n\tCommTimeOuts.ReadTotalTimeoutConstant = 0;\n\tCommTimeOuts.WriteTotalTimeoutMultiplier = 0;\n\tCommTimeOuts.WriteTotalTimeoutConstant = 10;\n\tSetCommTimeouts(m_hIDComDev, &amp;CommTimeOuts);\n\n\tm_OverlappedRead->hEvent = CreateEvent(NULL, true, false, NULL);\n\tm_OverlappedWrite->hEvent = CreateEvent(NULL, true, false, NULL);\n\n\tdcb.DCBlength = sizeof(DCB);\n\tGetCommState(m_hIDComDev, &amp;dcb);\n\tdcb.BaudRate = nBaud;\n\tdcb.ByteSize = 8;\n\n\tif (!SetCommState(m_hIDComDev, &amp;dcb) ||\n\t\t!SetupComm(m_hIDComDev, 10000, 10000) ||\n\t\tm_OverlappedRead->hEvent == NULL ||\n\t\tm_OverlappedWrite->hEvent == NULL)\n\t&#123;\n\t\tunsigned long dwError = GetLastError();\n\t\tif (m_OverlappedRead->hEvent != NULL) CloseHandle(m_OverlappedRead->hEvent);\n\t\tif (m_OverlappedWrite->hEvent != NULL) CloseHandle(m_OverlappedWrite->hEvent);\n\t\tCloseHandle(m_hIDComDev);\n\t\tm_hIDComDev = NULL;\n\t\tUE_LOG(LogTemp, Error, TEXT(\"Failed to setup port COM%d. Error: %08X\"), nPort, dwError);\n\t\treturn false;\n\t&#125;\n\n\t//FPlatformProcess::Sleep(0.05f);\n\tAddToRoot();\n\tm_Port = nPort;\n\tm_Baud = nBaud;\n\treturn true;\n&#125;\n\nvoid USerial::Close()\n&#123;\n\tif (!m_hIDComDev) return;\n\n\tif (m_OverlappedRead->hEvent != NULL) CloseHandle(m_OverlappedRead->hEvent);\n\tif (m_OverlappedWrite->hEvent != NULL) CloseHandle(m_OverlappedWrite->hEvent);\n\tCloseHandle(m_hIDComDev);\n\tm_hIDComDev = NULL;\n\n\tRemoveFromRoot();\n&#125;\n\nFString USerial::ReadString(bool&amp; bSuccess)\n&#123;\n\treturn ReadStringUntil(bSuccess, '\\0');\n&#125;\n\nFString USerial::Readln(bool&amp; bSuccess)\n&#123;\n\treturn ReadStringUntil(bSuccess, '\\n');\n&#125;\n\nFString USerial::ReadStringUntil(bool&amp; bSuccess, uint8 Terminator)\n&#123;\n\tbSuccess = false;\n\tif (!m_hIDComDev) return TEXT(\"\");\n\n\tTArray&lt;uint8> Chars;\n\tuint8 Byte = 0x0;\n\tbool bReadStatus;\n\tunsigned long dwBytesRead, dwErrorFlags;\n\tCOMSTAT ComStat;\n\n\tClearCommError(m_hIDComDev, &amp;dwErrorFlags, &amp;ComStat);\n\tif (!ComStat.cbInQue) return TEXT(\"\");\n\n\tdo &#123;\n\t\tbReadStatus = BOOL2bool(ReadFile(\n\t\t\tm_hIDComDev,\n\t\t\t&amp;Byte,\n\t\t\t1,\n\t\t\t&amp;dwBytesRead,\n\t\t\tm_OverlappedRead));\n\n\t\tif (!bReadStatus)\n\t\t&#123;\n\t\t\tif (GetLastError() == ERROR_IO_PENDING)\n\t\t\t&#123;\n\t\t\t\tWaitForSingleObject(m_OverlappedRead->hEvent, 2000);\n\t\t\t&#125;\n\t\t\telse\n\t\t\t&#123;\n\t\t\t\tChars.Add(0x0);\n\t\t\t\tbreak;\n\t\t\t&#125;\n\t\t&#125;\n\n\t\tif (Byte == Terminator || dwBytesRead == 0)\n\t\t&#123;\n\t\t\t// when Terminator is \\n, we know we're expecting lines from Arduino. But those\n\t\t\t// are ended in \\r\\n. That means that if we found the line Terminator (\\n), our previous\n\t\t\t// character could be \\r. If it is, we remove that from the array.\n\t\t\tif (Chars.Num() > 0 &amp;&amp; Terminator == '\\n' &amp;&amp; Chars.Top() == '\\r') Chars.Pop(false);\n\n\t\t\tChars.Add(0x0);\n\t\t\tbreak;\n\t\t&#125;\n\t\telse Chars.Add(Byte);\n\n\t&#125; while (Byte != 0x0 &amp;&amp; Byte != Terminator);\n\n\tbSuccess = true;\n\tauto Convert = FUTF8ToTCHAR((ANSICHAR*)Chars.GetData());\n\treturn FString(Convert.Get());\n&#125;\n\nfloat USerial::ReadFloat(bool&amp; bSuccess)\n&#123;\n\tbSuccess = false;\n\n\tTArray&lt;uint8> Bytes = ReadBytes(4);\n\tif (Bytes.Num() == 0) return 0;\n\n\tbSuccess = true;\n\treturn *(reinterpret_cast&lt;float*>(Bytes.GetData()));\n&#125;\n\nint32 USerial::ReadInt(bool&amp; bSuccess)\n&#123;\n\tbSuccess = false;\n\n\tTArray&lt;uint8> Bytes = ReadBytes(4);\n\tif (Bytes.Num() == 0) return 0;\n\n\tbSuccess = true;\n\treturn *(reinterpret_cast&lt;int32*>(Bytes.GetData()));\n&#125;\n\nuint8 USerial::ReadByte(bool&amp; bSuccess)\n&#123;\n\tbSuccess = false;\n\tif (!m_hIDComDev) return 0x0;\n\n\tuint8 Byte = 0x0;\n\tbool bReadStatus;\n\tunsigned long dwBytesRead, dwErrorFlags;\n\tCOMSTAT ComStat;\n\n\tClearCommError(m_hIDComDev, &amp;dwErrorFlags, &amp;ComStat);\n\tif (!ComStat.cbInQue) return 0x0;\n\n\tbReadStatus = BOOL2bool(ReadFile(\n\t\tm_hIDComDev,\n\t\t&amp;Byte,\n\t\t1,\n\t\t&amp;dwBytesRead,\n\t\tm_OverlappedRead));\n\n\tif (!bReadStatus)\n\t&#123;\n\t\tif (GetLastError() == ERROR_IO_PENDING)\n\t\t&#123;\n\t\t\tWaitForSingleObject(m_OverlappedRead->hEvent, 2000);\n\t\t&#125;\n\t\telse\n\t\t&#123;\n\t\t\treturn 0x0;\n\t\t&#125;\n\t&#125;\n\n\tbSuccess = dwBytesRead > 0;\n\treturn Byte;\n&#125;\n\nTArray&lt;uint8> USerial::ReadBytes(int32 Limit)\n&#123;\n\tTArray&lt;uint8> Data;\n\n\tif (!m_hIDComDev) return Data;\n\n\tData.Empty(Limit);\n\n\tuint8* Buffer = new uint8[Limit];\n\tbool bReadStatus;\n\tunsigned long dwBytesRead, dwErrorFlags;\n\tCOMSTAT ComStat;\n\n\tClearCommError(m_hIDComDev, &amp;dwErrorFlags, &amp;ComStat);\n\tif (!ComStat.cbInQue) return Data;\n\n\tbReadStatus = BOOL2bool(ReadFile(\n\t\tm_hIDComDev,\n\t\tBuffer,\n\t\tLimit,\n\t\t&amp;dwBytesRead,\n\t\tm_OverlappedRead));\n\n\tif (!bReadStatus)\n\t&#123;\n\t\tif (GetLastError() == ERROR_IO_PENDING)\n\t\t&#123;\n\t\t\tWaitForSingleObject(m_OverlappedRead->hEvent, 2000);\n\t\t&#125;\n\t\telse\n\t\t&#123;\n\t\t\treturn Data;\n\t\t&#125;\n\t&#125;\n\n\tData.Append(Buffer, dwBytesRead);\n\treturn Data;\n&#125;\n\nbool USerial::Print(FString String)\n&#123;\n\tauto Convert = FTCHARToUTF8(*String);\n\tTArray&lt;uint8> Data;\n\tData.Append((uint8*)Convert.Get(), Convert.Length());\n\n\treturn WriteBytes(Data);\n&#125;\n\nbool USerial::Println(FString String)\n&#123;\n\treturn Print(String + LineEndToStr(WriteLineEnd));\n&#125;\n\nbool USerial::WriteFloat(float Value)\n&#123;\n\tTArray&lt;uint8> Buffer;\n\tBuffer.Append(reinterpret_cast&lt;uint8*>(&amp;Value), 4);\n\treturn WriteBytes(Buffer);\n&#125;\n\nbool USerial::WriteInt(int32 Value)\n&#123;\n\tTArray&lt;uint8> Buffer;\n\tBuffer.Append(reinterpret_cast&lt;uint8*>(&amp;Value), 4);\n\treturn WriteBytes(Buffer);\n&#125;\n\nbool USerial::WriteByte(uint8 Value)\n&#123;\n\tTArray&lt;uint8> Buffer(&#123; Value &#125;);\n\treturn WriteBytes(Buffer);\n&#125;\n\nbool USerial::WriteBytes(TArray&lt;uint8> Buffer)\n&#123;\n\tif (!m_hIDComDev) false;\n\n\tbool bWriteStat;\n\tunsigned long dwBytesWritten;\n\n\tbWriteStat = BOOL2bool(WriteFile(m_hIDComDev, Buffer.GetData(), Buffer.Num(), &amp;dwBytesWritten, m_OverlappedWrite));\n\tif (!bWriteStat &amp;&amp; (GetLastError() == ERROR_IO_PENDING))\n\t&#123;\n\t\tif (WaitForSingleObject(m_OverlappedWrite->hEvent, 1000))\n\t\t&#123;\n\t\t\tdwBytesWritten = 0;\n\t\t\treturn false;\n\t\t&#125;\n\t\telse\n\t\t&#123;\n\t\t\tGetOverlappedResult(m_hIDComDev, m_OverlappedWrite, &amp;dwBytesWritten, false);\n\t\t\tm_OverlappedWrite->Offset += dwBytesWritten;\n\t\t\treturn true;\n\t\t&#125;\n\t&#125;\n\n\treturn true;\n&#125;\n\nvoid USerial::Flush()\n&#123;\n\tif (!m_hIDComDev) return;\n\n\tTArray&lt;uint8> Data;\n\n\tdo &#123;\n\t\tData = ReadBytes(8192);\n\t&#125; while (Data.Num() > 0);\n&#125;\n\nFString USerial::LineEndToStr(ELineEnd LineEnd)\n&#123;\n\tswitch (LineEnd)\n\t&#123;\n\tcase ELineEnd::rn:\n\t\treturn TEXT(\"\\r\\n\");\n\tcase ELineEnd::n:\n\t\treturn TEXT(\"\\n\");\n\tcase ELineEnd::r:\n\t\treturn TEXT(\"\\r\");\n\tcase ELineEnd::nr:\n\t\treturn TEXT(\"\\n\\r\");\n\tdefault:\n\t\treturn TEXT(\"null\");\n\t&#125;\n&#125;\n蓝图使用\n\n蓝图代码连接https://blueprintue.com/blueprint/ss-s-s83/\n\n\n","slug":"UE串口通信","date":"2022-07-22T08:14:36.000Z","categories_index":"UnrealEngine","tags_index":"串口通信","author_index":"cBao"},{"id":"650e8b54c427468049a9eded7ddf3373","title":"C++仿函数和代理","content":"sjdks\n仿函数\n\n\n\n\n\n提示\n需要头文件#include &lt; functional &gt;\n\n仿函数与普通函数#include &lt;iostream>\n#include &lt;functional>\n\nint Test(int A, int B)\n&#123;\n\tstd::cout&lt;&lt;A+B&lt;&lt;std::endl;\n\treturn A+B;\n&#125;\n\nint main()\n&#123;\n\tstd::function&lt;int(int,int)> Func_Test=Test;\n\tFunc_Test(2,3);\n&#125;\n\n\nint(int,int)：返回类型(形参列表)\n\n仿函数与Lambda#include &lt;iostream>\n#include &lt;functional>\n\nauto Lam=[&amp;](int A,int B)\n&#123;\n\tstd::cout&lt;&lt;A+B&lt;&lt;std::endl;\n\treturn A+B;\n&#125;;\n\nint main()\n&#123;\n\tstd::function&lt;int(int,int)> Fun_Test=Lam;\n\tFun_Test(3,4);\n&#125;\n\n","slug":"C++仿函数和代理","date":"2022-07-17T07:19:09.000Z","categories_index":"C++","tags_index":"仿函数和代理","author_index":"cBao"},{"id":"8655ec3b78f346469051ac63e86fd947","title":"C存储类","content":"C存储类\n\n\n\n\n\n\n注意\n存储类定义 C 程序中变量/函数的范围（可见性）和生命周期。这些说明符放置在它们所修饰的类型之前\nC中四种存储类：\n\nauto\nregister\nstatic\nextern\n\n\n\nauto 存储类auto 存储类是所有局部变量默认的存储类\n//注意是在花括号里的局部变量,Age1和Age2是相同存储类\n&#123;\n\tint Age1\n\tauto int Age2;\n&#125;\n\n\n\n\n\n\n\n\n注意\nauto只能修饰在函数内的局部变量\n\n\nregister 存储类register 存储类用于定义存储在寄存器中而不是 RAM 中的局部变量\n&#123;\n\tregister int Miles;\n&#125;\n\n\n\n\n\n\n\n\n注意\n寄存器只用于需要快速访问的变量，比如计数器\n不能对register修饰的变量使用取地址符”&amp;”，因为不在RAM中，所以没有内存地址\n定义 ‘register’ 并不意味着变量将被存储在寄存器中，它意味着变量可能存储在寄存器中，这取决于硬件和实现的限制\n\n\nstatic 存储类作用于局部变量：\n\nstatic 存储类指示编译器在程序的生命周期内保持局部变量的存在\n使用 static 修饰局部变量可以在函数调用之间保持局部变量的值\n\n作用于全局变量：\n\n当 static 修饰全局变量时，会使变量的作用域限制在声明它的文件内\n全局声明的一个 static 变量或方法可以被任何函数或方法调用，只要这些方法出现在跟 static 变量或方法同一个文件\n\nextern 存储类\nextern 存储类用于提供一个全局变量的引用，全局变量对所有的程序文件都是可见的\n对于无法初始化的变量，会把变量名指向一个之前定义过的存储位置\nextern 修饰符通常用于当有两个或多个文件共享相同的全局变量或函数的时候\n\n","slug":"C存储类","date":"2022-07-10T08:12:03.000Z","categories_index":"C","tags_index":"C","author_index":"cBao"},{"id":"91073ca00ced3eaf093ce066e8170e85","title":"C数据类型","content":"C数据类型\n","slug":"C数据类型","date":"2022-07-09T07:51:09.000Z","categories_index":"C","tags_index":"C","author_index":"cBao"},{"id":"8b894e11fa6b8b7cfc1195c4546ad7f2","title":"C基本语法","content":"C中两种注释方法\n双斜杠”//“：适合单行注释\n//本行是注释代码\n/**/“：适合多行注释\n/*\n多行注释\n多行注释\n*/\n\n\n\n\n\n\n\n提示\n在Visual Studio中可用\n快捷键Ctrl + K + C快速注释\nCtrl + K + U快速取消注释\n\n分号 ;在C程序中分号”;“（英文输入法下）代表一条语句的结束\n标识符C语言中用来命名变量和函数名称等统称为标识符，C语言是区分大小写的\n\n\n\n\n\n\n\n注意\nC中标识符必须以字母 A-Z 或 a-z 或下划线 _ 开始，不能以数字作为开头，不允许出现标点字符，且不能与下表中关键字同名\n\n关键字\n\n\n关键字\n说明\n\n\n\nauto\n声明自动变量\n\n\nbreak\n跳出当前循环\n\n\ncase\n开关语句分支\n\n\nchar\n声明字符型变量或函数返回值类型\n\n\nconst\n定义常量，如果一个变量被 const 修饰，那么它的值就不能再被改变\n\n\ncontinue\n结束当前循环，开始下一轮循环\n\n\ndefault\n开关语句中的”其它”分支\n\n\ndo\n循环语句的循环体\n\n\ndouble\n声明双精度浮点型变量或函数返回值类型\n\n\nelse\n条件语句否定分支（与 if 连用）\n\n\nenum\n声明枚举类型\n\n\nextern\n声明变量或函数是在其它文件或本文件的其他位置定义\n\n\nfloat\n声明浮点型变量或函数返回值类型\n\n\nfor\n一种循环语句\n\n\ngoto\n无条件跳转语句\n\n\nif\n条件语句\n\n\nint\n声明整型变量或函数\n\n\nlong\n声明长整型变量或函数返回值类型\n\n\nregister\n声明寄存器变量\n\n\nreturn\n子程序返回语句（可以带参数，也可不带参数）\n\n\nshort\n声明短整型变量或函数\n\n\nsigned\n声明有符号类型变量或函数\n\n\nsizeof\n计算数据类型或变量长度（即所占字节数）\n\n\nstatic\n声明静态变量\n\n\nstruct\n声明结构体类型\n\n\nswitch\n用于开关语句\n\n\ntypedef\n用以给数据类型取别名\n\n\nunsigned\n声明无符号类型变量或函数\n\n\nunion\n声明共用体类型\n\n\nvoid\n声明函数无返回值或无参数，声明无类型指针\n\n\nvolatile\n说明变量在程序执行中可被隐含地改变\n\n\nwhile\n循环语句的循环条件\n\n\n\n\n\n\n\n\n\n特别注意\n关键字不能作为常量名、变量名或其他标识符名称\n\n\n\n","slug":"C基本语法","date":"2022-07-08T15:10:17.000Z","categories_index":"C","tags_index":"C","author_index":"cBao"},{"id":"f58daaa95359f10d1d47b72330587f5d","title":"VisualStudio常用操作","content":"Visual Studio中常用的快捷键\n\n\n快捷键\n功能\n\n\n\nCtrl + K, O\n在头文件与源文件之间切换\n\n\nCtrl + K, C\n注释选择行\n\n\nCtrl + K, U\n取消选择行的注释\n\n\nCtrl + K, D\n对齐所有代码\n\n\nCtrl+Shift+U\n全部变为大写\n\n\nCtrl+U\n全部变为小写\n\n\nAlt+鼠标左按钮\n选择矩形文本\n\n\nCtrl+F\n在当前文件中查找\n\n\nCtrl+Shift+F\n在当前的解决方案中查找\n\n\n","slug":"Visual Studio常用操作","date":"2022-07-07T03:18:50.000Z","categories_index":"IDE","tags_index":"Visual Studio","author_index":"cBao"}]