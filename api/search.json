[{"id":"2d7fcd3211374fac141da523879cb012","title":"Unity3D引擎","content":"场景中的对象\nGameObject类对象是Unity引擎提供作为场景中所有对象的根本\n\nUnity中脚本的基本规则\n创建规则\n不在VS中创建脚本\n可以放在Assets文件夹下的任意位置（建议同一文件夹下）\n类名和文件名必须一致，不然不能挂载（因为反射机制创建对象，会通过文件名去找Type） 重要\n不要使用中文命名\n没有特殊需求，不需要管命名空间\n创建的脚本默认继承MonoBehaviour\n\n\nMonoBehavior基类\n创建的脚本默认继承MonoBehaviour，继承该类才能挂载到GameObject上\n继承了MonoBehaviour的脚本不能new只能挂载！！！\n继承了MonoBehaviour的脚本不要写构造函数，因为不能new，构造函数无意义\n继承了MonoBehaviour的脚本可以在一个对象上挂多个（没有添加DisallowMultipleComponent特性时）\n继承MonoBehaviour的类也可以再次被继承，遵循面向对象继承多态原则\n\n\n不继承MonoBehaviour的类\n不继承MonoBehaviour的类不能挂载到GameObject对象上\n不继承MonoBehaviour的类 想怎么写就怎么写 如果要使用 需要自己new实例化一个对象\n不继承MonoBehaviour的类 一般是单例模式的类（用于管理模块）或者数据结构类（用于存储数据）\n不继承MonoBehaviour的类 不用保留默认出现的几个函数\n\n\n\n在Unity中打印信息的两种方式\n没有继承MonoBehaviour类\n\n\n\nAPI\n\n\n\nDebug.Log(“…”);\n\n\nDebug.LogError(“出错”);\n\n\nDebug.LogWarning(“警告”);\n\n\n\n继承了MonoBehaviour类\n\n\n\nAPI\n\n\n\nprint(“…”);\n\n\n\n\n生命周期函数\n所有继承MonoBehaviour的脚本，最终都会挂载到GameObject游戏对象上\n\n生命周期函数就是该脚本对象依附的GameObject对象从出生到消亡的整个生命周期上\n\n会通过反射自动调用的一些特殊函数，是Unity自己调用的\n\n生命周期函数的访问修饰符一般为private和protected，因为不需要在外部自己调用生命周期函数\n\n生命周期函数并不是基类中的成员\n\n常用的生命周期函数（从上到下的执行先后）\n\n\n\nAPI\n描述\n\n\n\nAwake\n当脚本对象创建时，自动调用，类似构造函数，一个对象只会调用一次\n\n\nOnEnable\n依附的GameObject对象每次激活时调用\n\n\nStart\n当脚本对象创建后，第一次帧更新之前调用，一个对象只会调用一次（比Awake要晚）\n\n\nFixedUpdate\n物理帧更新，固定间隔时间执行，间隔时间可以设置（project Setting -&gt; Time）\n\n\nUpdate\n逻辑帧更新每帧执行\n\n\nLateUpdate\n每帧执行，于Update之后执行（一般用来处理摄像机位置更新（防止渲染出错））\n\n\nOnDisable\n依附的GameObject对象每次失活时调用\n\n\nOnDestroy\n对象销毁时调用，依附的GameObject对象被删除时\n\n\n\n\n生命周期函数支持继承多态\n\n\nInspector窗口可编辑的变量\nInspector显示的可编辑内容就是脚本的公共成员变量，默认情况下私有和保护的无法显示编辑\n加上强制序列化字段特性[SerializeField]，可以让私有的和保护的也可以被显示编辑\n在公共成员变量前加上[HideInInspector]，可以让公共成员变量在Inspector隐藏，默认是显示的\n大部分类型都能显示编辑\n自定义类型和Dictionary类型不能显示编辑\n\n\n加上序列化特性[System.Serializable]可以让自定义类型和结构体可以被显示编辑\n一些辅助特性\n分组：[Header(“分组说明”)]\n悬停注释：[Tooltip(“说明内容”)]\n间隔特性：[Space()]\n修饰数值的滑条范围Range：[Range(最小值,最大值)]\n多行显示字符串，默认不写参数显示3行：[Multiline()]\n滚动条显示字符串，默认不写参数超过3行显示滚动条：[TextArea(3,4)]最少显示3行，最多显示4行，超过4行显示滚动条\n为变量添加快捷方法：[ContextMenuItem(“显示按钮名”,”方法名”)]，方法名不能有参数\n为方法添加特性能够在Inspector中执行：[ContextMenu(“测试函数”)]\n\n\n注意\nInspector窗口中的变量关联的就是对象的成员变量，运行时改变它们就是在改变成员变量\n拖拽到GameObject对象后，再改变脚本中的变量默认值 界面上不会改变\n运行中修改的信息不会被保存\n\n\n\nMonoBehaviour中的重要内容\n重要成员\n\n获取依附的GameObject\nthis.gameObject;\n//gameObject与上面一样\n获取依附的GameObject位置信息\nthis.transform.position;//获得位置信息\nthis.transform.eulerAngles;//获得欧拉角\nthis.transform.lossyScale;//获得缩放大小\nthis.gameObject.transform;//该方法与以上相同\n设置脚本是否激活\nthis.enable=false;//失活\nthis.enable=true;//激活\n\n\n重要方法\n\n得到依附对象上挂载的其它脚本\n\n根据脚本名获取，获取失败返回null\nthis.GetComponent(\"脚本名\");//使用时用as进行转换使用\n根据Type获取\nthis.GetComponent(typeof(脚本类型));\n根据泛型获取 建议使用泛型获取，不用二次转换  建议使用\nthis.GetComponent&lt;脚本类型>();\n\n\n得到自己挂载的多个脚本\nthis.GetComponents&lt;脚本类型>(也可以直接用List);\n得到子对象挂载的脚本（默认也会找自身是否挂载该脚本）\nthis.GetComponentInChildren&lt;脚本类型>(true/false);//得单个\n//true子对象失活时也会查找，false子对象失活时不会查找\n\nthis.GetComponentsInChildren&lt;脚本类型>(true/false);//得多个\n得到父对象挂载得脚本（默认也会查找自身是否挂载该脚本）\nthis.GetComponentInParent&lt;脚本类型>();//得单个\n//true子对象失活时也会查找，false子对象失活时不会查找\n\nthis.GetComponentsInParent&lt;脚本类型>();//得多个\n尝试获取脚本\nthis.TryGetComponent&lt;脚本类型&gt;(out type);\n\n\n\nGameObject常用成员变量\n\n\nAPI\n描述\n\n\n\nthis.gameObject.name\n名字\n\n\nthis.gameObject.activeSelf\n是否激活\n\n\nthis.gameObject.isStatic\n是否是静态\n\n\nthis.gameObject.layer\n层级\n\n\nthis.gameObject.tag\n标签\n\n\nthis.gameObject.transform / this.transform\ntransform\n\n\nGameObject常用静态方法\n\n\nAPI\n描述\n\n\n\nGameObject.CreatePrimitive()\n创建自带几何体，会返回一个GameObject对象\n\n\nGameObject.Find()\n通过名字查找对象，效率较低，找不到失活对象，有相同名字的对象时，随机查找其中一个\n\n\nGameObject.FindWithTag()\n通过标签查找对象，找不到失活对象，有相同标签的对象时，随机查找其中一个\n\n\nGameObject.FindGameObjectWithTag()\n通过标签查找对象,与上一个API功能相同\n\n\nGameObject.FindGameObjectsWithTag()\n查找多个对象只能tag去找，无法通过名字 ，找不到失活对象\n\n\nGameObject.FindObjectOfType&lt;脚本类型&gt;()\n找到场景中挂载的某一个脚本对象，基本不使用，效率低下\n\n\nGameObject.instantiate()\n实例化对象，动态创建对象（名字后会增加clone）\n\n\nGameObject.Destroy()\n删除对象或者脚本，一般情况下会在下一帧移除对象并从内存中移除，第二个参数代表延迟删除的时间\n\n\nGameObject.DestroyImmediate()\n立即删除，不会等到下一帧，没有特殊需求不使用，可能存在卡顿\n\n\nGameObject.DontDestroyOnLoad()\n对象过场景不被移除（Unity默认过场景时场景中的对象都会自动删除掉）\n\n\nGameObject常用的成员方法\n\n\nAPI\n描述\n\n\n\nnew GameObject()\n创建一个空物体，存在重载，可以创建的同时添加脚本\n\n\nObj.AddComponent&lt;脚本类型&gt;()\n为对象添加脚本\n\n\nObj.SetActive()\n设置对象的激活和失活\n\n\nthis.CompareTag()\n标签比较\n\n\nthis.gameObject.SendMessage(“函数名”)\n执行挂载自身所有同名函数的行为 效率低下，不建议使用\n\n\nthis.gameObject.BroadcastMessage(“函数名”)\n广播行为，让自己和自己子对象执行相同函数名的函数\n\n\nthis.gameObject.SendMessageUpwards(“函数名”)\n向父对象和自己发送消息并执行相同函数名的函数\n\n\nUnity中的Object不是指的万物之父的object","slug":"Unity3D引擎","date":"2022-09-22T15:48:50.000Z","categories_index":"Unity3D引擎","tags_index":"Unity3D引擎","author_index":"cBao"},{"id":"710e93f12251a070d08d271cb7816514","title":"C#语法","content":"三种注释方法\n双斜杠注释（//）：用于注释一行信息\n星号注释（/**/）：用于注释多行信息\n三斜杠注释（///）：用于注释类，命名空间等\n\n\n\n\n\n\n\n提示\n注释：Ctrl+K+C  取消注释：Ctrl+K+U\n\n控制台的输入和输出\n\n\nAPI\n功能描述\n\n\n\nConsole.Write();\n在控制台输出不会自动换行\n\n\nConsole.WriteLine();\n在控制台输出会自动换行\n\n\nConsole.ReadLine();\n等待用户输入一行，按回车键结束输入\n\n\nConsole.ReadKey();\n只要用户按下任意键就结束\n\n\n折叠代码块//用于整理代码，方便阅读，只在编辑时有效\n#region cBaoTest\nConsole.WriteLine(\"折叠代码块\\n\");\n#endregion\n\n变量类型\n\n\n类型\n描述\n范围\n默认值\n\n\n\nbool\n布尔值\nTrue 或 False\nFalse\n\n\nbyte\n8 位无符号整数\n0 到 255\n0\n\n\nchar\n16 位 Unicode 字符\nU +0000 到 U +ffff\n‘\\0’\n\n\ndecimal\n128 位精确的十进制值，28-29 有效位数\n(-7.9 x 1028 到 7.9 x 1028) / 100 到 28\n0.0M\n\n\ndouble\n64 位双精度浮点型\n(+/-)5.0 x 10-324 到 (+/-)1.7 x 10308\n0.0D\n\n\nfloat\n32 位单精度浮点型\n-3.4 x 1038 到 + 3.4 x 1038\n0.0F\n\n\nint\n32 位有符号整数类型\n-2,147,483,648 到 2,147,483,647\n0\n\n\nlong\n64 位有符号整数类型\n-9,223,372,036,854,775,808 到 9,223,372,036,854,775,807\n0L\n\n\nsbyte\n8 位有符号整数类型\n-128 到 127\n0\n\n\nshort\n16 位有符号整数类型\n-32,768 到 32,767\n0\n\n\nuint\n32 位无符号整数类型\n0 到 4,294,967,295\n0\n\n\nulong\n64 位无符号整数类型\n0 到 18,446,744,073,709,551,615\n0\n\n\nushort\n16 位无符号整数类型\n0 到 65,535\n0\n\n\n四种类型转换方式\n括号强转\n\n用于将大范围数转换成小范围数，不安全转换\nbool和string类型不支持该强转\n\nint i=10;\nsbyte s1=(sbyte)i;\nParse转换\n\n将字符串转换为对应类型，安全转换\n\nint TestInt = int.Parse(\"1234\");\nConvert转换\n\n各个类型之间的转换\n\nfloat f1 = 3.4f;\nint i = Convert.ToInt32(f1);\nConsole.WriteLine(i);\nToString转换\n\n其它类型转成string类型\n\nfloat f1 = 3.4f;\nstring s1 = f1.ToString();\n\n异常捕获string s1 = \"请输入语文成绩:\";\nwhile (true)\n&#123;\n    //try尝试捕获错误\n    try\n    &#123;\n        Console.Write(s1);\n        YuWen = int.Parse(Console.ReadLine());\n        break;\n    &#125;\n    //若try中有错误将执行catch中代码\n    catch\n    &#123;\n        s1 = \"输入不合法，请重新输入语文成绩:\";\n        continue;\n    &#125;\n&#125;\n\n字符串拼接方式\n使用+号\n//+号两边必须要有一个string类型\nstring s1=\"\";\ns1 +=1+2+3;//结果是6\ns1 +=\" \"+1+2+3;//结果是123，从第一个字符串类型之后都会自动调用ToString之后在进行拼接\n使用string.Format()\n//拼接的内容用占位符代替，数字0~n\n//内容不能少于占位符\nstring.Format(\"&#123;0&#125;,&#123;1&#125;\", \"cBao\", \"nice\")\n\n位运算\n二进制按位进行运算\n\n\n\n\n位运算符\n介绍\n\n\n\n按位与 &amp;\n有0则0\n\n\n按位或 |\n有1则1\n\n\n按位异或 ^\n相同为0，不同为1\n\n\n按位取反 ~\n0变1，1变0\n\n\n左移 &lt;&lt;\n左移几位，右边加几个0\n\n\n右移 &gt;&gt;\n右移几位，右侧去掉几个数\n\n\n控制台控制方法\n清空\nConsole.Clear();\n设置窗口大小，屏幕缓冲区大小\nConsole.SetWindowSize(100, 50);\nConsole.SetBufferSize(100, 50);\n\n\n\n\n\n\n\n提示\n\n先设置窗口大小，在设置屏幕缓冲区大小\n屏幕缓冲区大小不能小于窗口大小\n窗口大小不能大于控制台最大尺寸\n\n\n\n\n设置光标位置\nConsole.SetCursorPosition(10, 5);\n\n\n\n\n\n\n\n提示\nx和y的单位不同，1y=2x 视觉上\n\n\n\n控制台颜色\n//文字颜色\nConsole.ForegroundColor = ConsoleColor.Red;\n//背景颜色\n Console.BackgroundColor = ConsoleColor.Blue;\n Console.Clear();//设置背景颜色后必须用Clear一次\n光标显示隐藏\nConsole.CursorVisible = true;\nConsole.CursorVisible = false;\n关闭控制台\nEnvironment.Exit(0);//在调试状态下无效\n判断控制台当前有没有输入\nConsole.KeyAvailable//会减慢循环的执行速度\n\n随机数\n固定写法\n //创建随机数对象\n Random r = new Random();\n //0~99的随机数\n int i = r.Next(100);\n Console.WriteLine(i);\n\n //生成一个大于0的随机数\n int i2 = r.Next();\n Console.WriteLine(i2);\n\n//生成一个大于等于8小于13的一个随机数\n int i3 = r.Next(8, 13);\n Console.WriteLine(i3);\n\n数组\n数组的声明方式\n//第一种\nint[] Arr;\n\n//第二种\nint[] Arr_2 = new int[5];\n\n//第三种\nint[] Arr_3 = new int[5] &#123; 1, 2, 3, 4, 5 &#125;;\n\n//第四种\nint[] Arr_4 = new int[] &#123; 1, 2, 3, 4, 5, 6 &#125;;\n\n//第五种\nint[] Arr_5 = &#123; 1, 2, 3, 4, 5 &#125;;\n二维数组\n//声明一个2行3列的二维数组\nint[,] Arr = new int[2, 3];\n//获得行数\nint x=Arr.GetLength(0);\n//获得列数\nint y=Arr.GetLength(1);\n\n值类型和引用类型值类型：基本变量类型，结构体，存储在栈空间，由计算机管理（它变我不变）\n引用类型：string（特殊，更像值类型）,数组，类，存储在堆空间，由程序员进行管理（它变我也变(用new可解除)）\n函数\n写在class或者struct中\n\n表达式体方法\n执行一行代码的函数可以使用的一个功能\n//表达式体方法\nstatic void MyFun() => Console.WriteLine(\"ccc\");\n\nref和out\n用于函数重载时ref和out不能同时修饰同一变量\n\nref类似C++中的引用，传入的变量必须初始化，可以不在内部赋值\nstatic void Test(ref int A)\n&#123;\n    A = 30;\n&#125;\n\nint A = 10;//初始化\nTest(ref A);//A被改成30\nConsole.WriteLine(A);\nout与ref功能一样，但是传入的变量不必初始化，必须在内部赋值\nstatic void Test(out int A)\n&#123;\n    A = 30;\n&#125;\n\nint A;//不必初始化\nTest(out A);//A被改成30\nConsole.WriteLine(A);\n\n变长参数\n关键字：params\n\n一个函数中只能有一个变长参数，且必须在最后一个参数\n static int ParamSum(params int[] Arr)\n&#123;\n  int Sum = 0;\n  for (int i = 0; i &lt; Arr.Length; i++)\n  &#123;\n    Sum += Arr[i];\n  &#125;\n  return Sum;\n&#125;\n\n函数重载\n与C++函数重载类似\n\n递归函数\n自己调用自己的函数\n必须要有能结束函数调用的条件\n\n结构体\n一般写在namespace中\n\n结构体中声明的变量不能直接初始化\n\n在结构体中函数不需要添加static关键字\n\n结构体不存在继承关系，但是可以继承接口\n\n结构体构造函数\n\n没有返回值\n必须有参数\n函数名与结构体名相同\n必须在其中对所有变量数据初始化\n\n\nC#中struct默认访问修饰符是private\nstruct cBao\n&#123;\n\n    public string Name;\n\n    public int Age;\n\n    public int Number;\n\n\n    public void PrintfName()\n    &#123;\n        Console.WriteLine(Name);\n    &#125;\n\n&#125;\n\n排序\n冒泡排序\n//升序\nstatic void BubbleSortUp(int[] Arr)\n&#123;\n    for (int x = 0; x &lt; Arr.Length; x++)\n    &#123;\n        for (int y = 0; y &lt; Arr.Length - 1-x; y++)\n        &#123;\n            if (Arr[y] >= Arr[y + 1])\n            &#123;\n                int Temp = Arr[y];\n                Arr[y] = Arr[y + 1];\n                Arr[y + 1] = Temp;\n            &#125;\n        &#125;\n    &#125;\n&#125;\n//降序\nstatic void BubbleSortDown(int[] Arr)\n&#123;\n    for (int x = 0; x &lt; Arr.Length; x++)\n    &#123;\n        for (int y = 0; y &lt; Arr.Length - 1-x; y++)\n        &#123;\n            if (Arr[y] &lt;= Arr[y + 1])\n            &#123;\n                int Temp = Arr[y];\n                Arr[y] = Arr[y + 1];\n                Arr[y + 1] = Temp;\n            &#125;\n\n        &#125;\n\n    &#125;\n\n&#125;\n\n//优化版\nstatic void BubbleSortUp(int[] Arr)\n        &#123;\n\n            bool isSort = false;\n\n            for (int x = 0; x &lt; Arr.Length; x++)\n            &#123;\n                for (int y = 0; y &lt; Arr.Length - 1-x; y++)\n                &#123;\n                    if (Arr[y] >= Arr[y + 1])\n                    &#123;\n                        isSort = true;\n                        int Temp = Arr[y];\n                        Arr[y] = Arr[y + 1];\n                        Arr[y + 1] = Temp;\n                    &#125;\n\n                &#125;\n                if (!isSort)\n                    break;\n            &#125;\n\n        &#125;\n\n类和对象\n一般声明在namespace中\n类是一个引用类型\n不能在类中实例化一个相同类型的变量\n访问修饰符与C++类似\n构造函数规则与C++类似\n析构函数（Unity中基本不会使用），C#中存在自动垃圾回收机制GC一般也不使用\n\n垃圾回收机制\nGC只负责堆（Heap）内存的垃圾回收\n\n引用类型都是存在于堆（Heap）中\n\n手动触发垃圾回收方法\nGC.Collect();\n\n成员属性\n用于保护成员变量\n\n为成员属性的获取和赋值添加逻辑处理\n\nget和set的访问权限不能高于或者等于外部访问权限\n\n用帕斯卡命名法\n\nget和set可以只有一个\nclass TestInfo\n&#123;\n    private string name;\n  \n    public string Name\n    &#123;\n        get\n        &#123;\n            return name;\n        &#125;\n  \n        set\n        &#123;\n            name = value;\n        &#125;\n  \n    &#125;\n&#125;\n自动属性（特殊需求）\n\n用于外部能得不能改的变量\nclass TestInfo\n   &#123;\n       private string name;\n    \n       public string Name\n       &#123;\n           get\n           &#123;\n               return name;             \n           &#125;\n    \n           set\n           &#123;\n               name = value;\n               //可以直接在类内当成员变量直接使用\n               Age = 20;\n           &#125;\n       &#125;\n    \n       public int Age\n       &#123;\n           get;\n           private set;\n       \n       &#125;\n   &#125;\n\n\n\n索引器\n一般成员中有数组参数时可以简化使用\nclass MyArr\n    &#123;\n        private int[] arr;\n        private int currentIndex;\n        //查\n        //改\n        public int this[int index]\n        &#123;\n            get\n            &#123;\n                if (index >= 0 &amp;&amp; index &lt;= currentIndex)\n                &#123;\n                    return arr[index];\n                &#125;\n                return -1;\n            &#125;\n            set \n            &#123;\n                if (index >= 0 &amp;&amp; index &lt;= currentIndex)\n                &#123;\n                    arr[index] = value;\n                &#125;\n                else\n                &#123;\n                    Console.WriteLine(\"索引超过数组范围\");\n                &#125;\n\n            &#125;\n        \n       &#125;\n\n静态成员\n用static修饰的成员变量，方法，属性等称为静态成员，具有唯一性\n可以直接用类名 **. ** 出来使用\n静态成员与程序同生共死（程序运行就会在静态存储区分配内存）\n静态成员不能直接使用非静态成员（因为此时普通成员还没有被实例化）\n静态变量：1.常用于唯一变量的声明，2.方便别人获取的对象申明\n静态方法：常用的唯一方法申明\nconst常量是一种特殊的static成员，也可以直接用类名 . 出来使用\n\nclass Test\n&#123;\n    //将构造函数声明成私有保证外部不能创建对象\n    private Test()\n    &#123;\n\n\n    &#125;\n\n    //静态成员变量保证唯一性\n    private static Test t = new Test();\n\n    //成员属性方法保证只能外部得不能改\n    public static Test T\n    &#123;\n        get \n        &#123;\n            return t;\n        &#125;      \n    &#125;\n\n    public void Print()\n    &#123;\n        Console.WriteLine(\"我是一个单例\");        \n    &#125;\n&#125;\n\nclass Program\n&#123;\n    static void Main()\n    &#123;\n        Test.T.Print();\n    &#125; \n&#125;\n\n静态类\n用static修饰的类\n静态类不能被实例化\n只能存在静态成员\n一般用于唯一工具类（将常用的静态成员写在静态类中，方便使用）\n\n静态构造函数\n用static修饰的构造函数\n静态类和普通类都可以存在静态构造函数\n不能有参数\n只会自动调用一次\n用于在静态构造函数中初始化静态变量 \n\n拓展方法\n为现有非静态的变量类型添加新方法\n\n一定写在静态类中\n\n一定是静态函数\n\n基本语法\n//访问修饰符 static 返回值 函数名(this 拓展类型 参数名,参数类型 参数名...)\n    static class Tool\n    &#123;\n        public static void SpeadValue(this int Value)\n        &#123;\n            Console.WriteLine(\"int拓展方法\");\n        \n        &#125;\n    \n    &#125;\n\n运算符重载\n让自定义类和结构体对象可以进行运算\n\n条件运算符需要成对实现\n\n一个符号可以多个重载\n\n不能使用ref和out\n\n基本语法\nclass Point\n&#123;\n    public int x;\n    public int y;\n\n    public Point(int x, int y)\n    &#123;\n        this.x = x;\n        this.y = y;\n    &#125;\n    \n    //访问修饰符 static 返回类型 operator 运算符(参数列表)\n    public static bool operator == (Point A, Point B)\n    &#123;\n        if (A.x == B.x &amp;&amp; A.y == B.y)\n        &#123;\n            return true;\n        &#125;\n        return false;\n    &#125;\n    \n    //访问修饰符 static 返回类型 operator 运算符(参数列表)\n    public static bool operator !=(Point A, Point B)\n    &#123;\n        if (A.x != B.x || A.y != B.y)\n        &#123;\n            return true;\n        &#125;\n        return false;\n\n    &#125;\n&#125;\n\n继承\nC#中只有单继承\n\n传递性：子类继承父类的父类的所有内容\n\n子类的同名成员会隐藏父类的同名成员\n\n申明对象时会先执行父类构造函数再调用子类构造函数（默认自动调用的是父类的无参构造函数，可通过base指定待用父类构造）\n\n若要有意请用new标识\nclass Monster\n&#123;\n    public Monster(int A)\n    &#123;\n        \n    &#125;\n&#125;\n\nclass Goblin : Monster\n&#123;\n    public Goblin() : base(1)\n    &#123;\n        \n    &#125;\n    public void ATK()\n    &#123;\n        Console.WriteLine(\"攻击!\");       \n    &#125;\n&#125;\n\nclass Boss : Monster\n&#123;\n    public Boss() : base(1)\n    &#123;\n\n    &#125;\n    public void Skill()\n    &#123;\n        Console.WriteLine(\"释放技能\");\n    &#125;\n\n&#125;\n\n里氏替换原则\n概念：任何父类出现的地方，子类都可以代替\n\n父类容器可以装子类对象 ，(切记子类容器不能装父类对象)\n\n方便进行对象存储和管理\n\nis和as\n\nis：判断一个对象是否是指定类对象（是为true，不是false）\n//语法\n//类对象 is 类名\nas：将一个对象转换成指定类对象（成功返回指定类型，不是返回null）\n//语法\n//类对象 as 类名\n\n\n\nstatic void Main()\n&#123;\n    Random Rand = new Random();\n    Monster[] MonsterArr = new Monster[10];\n    for (int i = 0; i &lt; MonsterArr.Length; i++)\n    &#123;\n        if (Rand.Next(0, 2) == 0)\n        &#123;\n            MonsterArr[i] = new Boss();\n        &#125;\n        else\n        &#123;\n            MonsterArr[i] = new Goblin();               \n        &#125;           \n    &#125;\n    for (int i = 0; i &lt; MonsterArr.Length; i++)\n    &#123;\n        if (MonsterArr[i] is Boss)\n        &#123;\n            (MonsterArr[i] as Boss).Skill();\n        &#125;\n        else if (MonsterArr[i] is Goblin)\n        &#123;\n            (MonsterArr[i] as Goblin).ATK();                \n        &#125;          \n    &#125;\n&#125;\n\n万物之父\n关键字：object\n\nobject是所有类型的基类，是一个引用类型\n\n可以用里氏替换原则，用object容器装所有对象\n\n可以用来表示不确定类型，作为函数参数类型\n\n引用类型用is和as转换对应类型使用\n\n值类型使用强制转换使用\n\n万物之父中的方法\n\n静态方法\n\n\n\nAPI\n描述\n\n\n\nEquals\n判断两个对象是否相等，最终判断权，交给左侧对象的Equals方法（引用类型是否相等判定是否指向同一内存地址）\n\n\nReferenceEquals\n判断两个引用类型的对象是否相等，值类型始终为false\n\n\n\n成员方法\n\n\n\nAPI\n描述\n\n\n\nGetType\n获取对象运行时的类型Type\n\n\nMemberwiseClone\n获取对象的浅拷贝对象（返回一个新的对象），新对象中的引用类型变量和老对象中指向相同内存地址\n\n\n\n虚方法\n\n\n\nAPI\n描述\n\n\n\nEquals\n重写该方法定义比较相等的规则\n\n\nGetHashCode\n重写该方法定义自己的哈希算法\n\n\nToString\n重写该方法定义自己的对象转字符串规则\n\n\n\n\n\n\n装箱和拆箱\n装箱\n将值类型用引用类型存储\n栈内存会迁移到堆内存中\n\n\n拆箱\n将引用类型存储的值类型取出来\n堆内存会迁移到栈内存中\n\n\n\n密封类\n关键字：sealed\nsealed修饰的类无法被继承\n\n//密封类\nsealed class Animal\n&#123; \n\n&#125;\n\n密封方法\n关键字sealed修饰的重写函数\n让虚方法或者抽象方法之后不能再被重写\n\n abstract class Animal\n&#123;\n    public abstract void Speak();\n\n    public virtual void Eat()\n    &#123; \n    \n    &#125;\n&#125;\n\nclass Person : Animal\n&#123;\n    //密封方法 不能在被子类重写\n    public sealed override void Speak()\n    &#123;\n        \n    &#125;\n\n    //密封方法 不能在被子类重写\n    public sealed override void Eat()\n    &#123;\n        \n    &#125;\n&#125;\n\nclass WhitePerson : Person\n&#123;\n    //不能重写密封方法\n    //public override void Speak()\n    //&#123;\n\n    //&#125;\n\n    //不能重写密封方法\n    //public override void Eat()\n    //&#123;\n\n    //&#125;\n&#125;\n\n多态\n关键字：virtual修饰的虚函数  override修饰的重写函数（配对使用）\nclass BaseClass\n&#123;\n    //virtual虚函数可被子类重写\n    public virtual void Speak()\n    &#123;\n        Console.WriteLine(\"我是父类\");\n    &#125;\n&#125;\n\nclass SubClass:BaseClass\n&#123;\n\n    //override重写父类方法\n    public override void Speak()\n    &#123;\n        //调用父类中的方法\n        //base.Speak();\n        Console.WriteLine(\"我是子类\");\n    &#125;\n&#125;\n\nclass Program\n&#123;\n    static void Main()\n    &#123;\n        //父类对象调用子类行为\n        BaseClass b1 = new SubClass();\n        b1.Speak();       \n    &#125;    \n&#125;\n\n抽象类\nabstruct修饰的类\n不能被实例化的类，遵循里氏替换原则\n\n抽象方法\nabstruct修饰的方法\n只能在抽象类中声明，没有定义\n不能是私有的\n子类必须用override重写该方法（子类的子类可以选择进行重载）\n\n//抽象类\nabstract class  Animals\n&#123;\n    //抽象方法，子类必须重写此方法\n    public abstract void Speak();\n\n&#125;\n\nclass Person : Animals\n&#123;\n    public override void Speak()\n    &#123;\n        Console.WriteLine(\"嗨\");\n    &#125;\n&#125;\n\nclass Dog : Animals\n&#123;\n    public override void Speak()\n    &#123;\n        Console.WriteLine(\"汪汪汪\");\n    &#125;\n&#125;\n\nclass Cat : Animals\n&#123;\n    public override void Speak()\n    &#123;\n        Console.WriteLine(\"喵喵喵\");\n    &#125;\n&#125;\n\nclass Program\n&#123;\n    static void Main()\n    &#123;\n        //抽象类遵循里氏替换原则\n        Animals A1 = new Person();\n        A1.Speak();\n\n        Cat c1 = new Cat();\n        c1.Speak();\n\n        Dog d1 = new Dog();\n        d1.Speak();\n    &#125;\n&#125;\n\n接口\n是一种自定义类型，不能被实例化，可以作为容器存储对象\n关键字：interface\n成员可以不写访问修饰符（默认是public），不能是私有的（private）\n不能包含成员变量\n只包含方法，成员属性，索引器，事件\n成员不能被定义\n接口不能继承类，但可以继承另一个接口（继承的接口不需要实现，在继承该接口的类中一并实现）\n接口是用来继承的，类可以继承多个接口\n类继承接口后，必须实现接口中所有成员，且成员访问修饰符必须是public，可以加virtual关键字在其子类中重写该方法\n显示实现接口\n当一个类继承两个或以上接口时，这些接口中存在同名方法时需要显示事件接口\n显示实现接口时，不能写访问修饰符\n\n\n接口遵循里氏替换原则\n\n命名空间\n用来组织和重用代码\n类似工具包，类就是这个工具包中的一件工具，声明在命名空间中\n命名空间可以分开写（不同文件中也可以写）\n命名空间中不能有同名的类\n不同命名空间中有相同名称的类，必须使用指明出处方式确定使用哪个命名空间中的类\n不同命名空间中相互使用，需要引用命名空间或指明出处\n\nstring\n是一个特殊的引用类型（更像是一个值类型）\n每次重新赋值或者拼接都会分配新的内存空间（若经常改变会非常浪费空间）\n\nStringBuilder\nC#提供的一个用于处理字符串的公共类\n\n主要作用：修改字符串时不创建新的对象，需要频繁修改和拼接字符串时使用，提升性能\n\n使用需要引用命名空间\nusing System.Text;\n存在一个容量，添加内容超过容量时会自动扩容（当前容量x2倍）\n\n\nStringBuilder str = new StringBuilder(\"123\");\n\n//获得容量\nConsole.WriteLine(\"str容量：&#123;0&#125;\", str.Capacity);\n\n//获得长度\nConsole.WriteLine(\"str当前长度：&#123;0&#125;\", str.Length);\n\n//增\nstr.Append(\"123\");\nConsole.WriteLine(str);\n//删\nstr.Remove(0, 1);\nConsole.WriteLine(str);\n\n//等等方法\n\n面向对象七大原则目的：高内聚低耦合\n从类角度看，减少类内部，对其他类的调用\n从功能模块看，减少模块之间的交互复杂度\n\n单一职责原则：类被修改几率很大，应该专注于单一功能\n开闭原则：对拓展开发，对修改关闭\n拓展开发：模块的行为可以被拓展从而满足新需求\n修改关闭：不允许修改模块的源代码（或者尽量使修改最小化）继承就是最典型的开闭原则的体现\n\n\n里氏替换原则：任何父类出现的地方，子类都可以替代\n依赖倒转原则：要依赖于抽象，不依赖于具体实现\n迪米特原则：一个对象应当对其它对象尽可能的少的了解\n接口分离原则：一个接口不需要提供太多的行为，一个接口应该尽量只提供一个对外的功能，而不是把所有的行为都封装到一个接口中\n合成复用原则：\n尽量使用对象组合，而不是继承来达到复用的目的\n继承关系是强耦合，组合关系是低耦合\n不能盲目的使用合成复用原则，要在遵循迪米特的原则前提下 \n\n\n\nC#容器类\nArrayList\n\n是C#封装好的类\n本质是一个object（万物之父）类型的数组\n需要引用命名空间using System.Collections;\n装箱拆箱\nArrayList本质是一个可以自动扩容的object数组\nobject是万物之父的数据，所以存在装箱拆箱\n当进行值类型存储时就是在装箱，将值类型对象取出转换时就是在拆箱\nArrayList尽量少用\n\n\n\n\nStack(栈)\n\n是C#封装好的类\n需要引用命名空间using System.Collections;\n本质也是object数组，只是封装了特殊的存储规则\n是栈存储器，栈是一种先进后出的数据结构\npush是增加数据，pop是弹出数据\n用foreach方法遍历，顺序从栈顶到栈底\n用ToArray方法可以转换成object数组，顺序从栈顶到栈底\n无法更改元素元素，只能清空\n先存入的数据后获取，后存入的数据先获取（先进后出）\n\n\nQueue\n\n是C#封装好的类\n需要引用命名空间using System.Collections;\n本质也是object数组，只是封装了特殊的存储规则\n队列是一种先进先出的数据结构（先存入的数据先获取，后存入的数据后获取）\n无法更改元素元素，只能清空\n先进先出\n\n\n\n\n\n\n\nAPI\n描述\n\n\n\nEnqueue\n增加元素\n\n\nDequeue\n取出元素\n\n\nPeek\n查看头部元素但不会移除\n\n\nContains\n是否包含\n\n\nClear\n清空\n\n\nCount\n长度\n\n\nToArray\n转换成object数组\n\n\n\nHashtable\n\n又称散列表，是基于键的哈希代码组织起来的键值对（不能出现相同的键）\n需要引用命名空间using System.Collections;\n主要作用是提高数据查询的效率\n使用键来访问集合中的元素\n\n\n\n\nAPI\n描述\n\n\n\nAdd\n添加键值对\n\n\nRemove\n通过键移除对应元素\n\n\nClear\n清除\n\n\n[]\n通过键查找对应的值，找不到会返回空\n\n\nContains\n通过键查找是否包含\n\n\nContainsKey\n通过键查找是否包含\n\n\nContainsValue\n通过值查找是否包含\n\n\n\n\n泛型\n将类型参数化，达到代码重用的目的\n\n基本语法\n//泛型类\nclass 类名&lt;泛型占位字母>\n    \n//泛型接口\ninterface 接口名&lt;泛型占位字母>\n    \n//泛型函数\n返回类型 函数名&lt;泛型占位字母>(参数列表)\n泛型约束\n\n限制泛型所支持的类型\n\n关键字：where\n\n泛型的6中约束\n\n\n\n语法\n描述\n\n\n\nwhere 泛型字母 : struct\n值类型\n\n\nwhere 泛型字母 : class\n引用类型\n\n\nwhere 泛型字母 : new()\n存在无参公共构造函数\n\n\nwhere 泛型字母 : 类名\n某个类本身或者其派生类\n\n\nwhere 泛型字母 : 接口名\n某个接口的派生类型\n\n\nwhere 泛型字母 : 另一个泛型字母\n另一个泛型类型本身或者派生类型\n\n\n//案例\nclass Test&lt;T> where T : struct\n&#123; \n        \n&#125;\n\n\n\nList\n是C#封装好的类\n本质是一个可变类型的泛型数组\n需要引入命名空间using System.Collections.Generic\n\n\n\n\nAPI\n描述\n\n\n\nAdd\n添加\n\n\nAddRange\n批量添加\n\n\nRemove\n移除指定元素\n\n\nRemoveAt\n移除指定位置元素\n\n\nClear\n清空\n\n\nContains\n元素是否包含\n\n\nIndexOf\n从头查找元素位置\n\n\nLastIndexOf\n从末尾查找元素位置（返回的还是正向的索引值）\n\n\nCount\n长度\n\n\nCapacity\n容量\n\n\nDictionary\n可以理解为，拥有泛型的Hashtable\n是基于键的哈希代码组织起来的键/值对\n\nLinkedList\n是C#封装好的类\n本质是一个可变类型的泛型双向链表\nusing System.Collections.Generic\n\n\n\n\nAPI\n描述\n\n\n\nAddLast\n在链表尾部添加元素\n\n\nAddFirst\n在链表头部添加元素\n\n\nRemoveFirst\n移除头部节点\n\n\nRemoveLast\n移除尾部节点\n\n\nRemove\n移除指定节点\n\n\nClear\n清空\n\n\nFirst\n头节点\n\n\nLast\n尾节点\n\n\nFind\n找到指定值的节点（未找到返回null）\n\n\nAddAfter\n在一个节点后面添加一个节点\n\n\nAddBefore\n在一个节点前面添加一个节点\n\n\nContains\n查找是否包含\n\n\n节点.Value\n用来改值\n\n\n委托\n委托是函数（方法）的容器,可以理解为表示函数（方法）的变量类型\n\n用来存储，传递函数\n\n本质是一个用来定义函数的类型（返回值和参数的类型）\n\n不同的函数必须对应和各自格式一致的委托\n\n关键字：delegate\n//语法 函数名前加delegate\n访问修饰符 delegate 返回值 委托名(参数列表)//访问修饰符默认public\n可以申明在namespace和class语句块中，不能重名，通常写在namespace中\n\n常作为类的成员或者作为函数的参数\n\n\n\n\n\nAPI\n描述\n\n\n\nInvoke\n调用委托存储的函数\n\n\n委托名()\n调用委托存储的函数\n\n\n+=\n添加一个函数\n\n\n-=\n移除一个函数\n\n\n\n系统自带的委托\n\nAction:无参无返回值的委托\n\nAction&lt;&gt;:泛型委托 可以传1~16个参数的无返回值的委托\n\nFunc&lt;&gt;:泛型委托 可以传1~16个参数的返回值无参的委托\n\nFunc&lt;in T,out TResult&gt;：可以传1~16个参数的自定义返回值的委托\n\n\n\n\n事件\n事件是基于委托的存在\n\n事件是委托的安全包裹\n\n让委托的使用更具安全性\n\n事件 是一种特殊的变量类型\n\n关键字:event\n\n只能作为成员存在于类，接口，以及结构体中\n\n使用：委托怎么用 事件就怎么用\n//语法\n访问修饰符 event 委托类型 事件名\n//事件是作为 成员变量存在于类中\n//不能在类外部直接赋值和调用\n//可以在外部进行加减添加和移除记录的函数，只能用复合运算符+= -=\n\n匿名函数\n没有名字的函数\n\n匿名函数主要是配合委托和事件进行使用\n\n脱离委托和事件，是不会使用匿名函数的\n\n基本语法\ndelete (参数列表)\n&#123;\n\n\t//函数逻辑\n\n&#125;;//此处要加分号\n何时使用\n\n函数中传递委托参数时\n委托或者事件赋值时\n\nusing System;\nusing System.Collections;\nusing System.Collections.Generic;\n\nnamespace JinJie\n&#123;\n\n    class Program\n    &#123;\n        static void Main()\n        &#123;\n            //无参无返回值\n            Action a = delegate () &#123; Console.WriteLine(\"无参无返回值\"); &#125;;\n            a();\n\n            //有参\n            Action&lt;int, string> b = delegate (int a, string b)\n            &#123;\n                Console.WriteLine(a);\n                Console.WriteLine(b);\n            &#125;;\n            b(10,\"123\");\n\n            //有返回值，直接使用return返回\n            Func&lt;string> c = delegate () &#123; return \"1234\"; &#125;;\n            Console.WriteLine(c());\n\n            //一般情况会作为函数参数传递或者作为函数返回值\n            //作为函数参数\n            static void FuncTest(Action ac)\n            &#123;\n                ac();            \n            &#125;\n\n            FuncTest(delegate () \n            &#123;\n                Console.WriteLine(\"函数参数\");             \n            &#125;);\n\n            //作为函数返回值\n            static Action FuncTest2()\n            &#123;\n                return delegate ()\n                &#123;\n                    Console.WriteLine(\"函数返回值\");\n                &#125;;          \n            &#125;\n\n            FuncTest2()();\n        &#125;\n\n    &#125;\n\n&#125;\n注意事项：添加到委托或者事件容器中后无法单独移除\n\n\nLambad表达式\n理解为匿名函数的简写\n\n除了写法不同,使用上是和匿名函数一样的\n\n都是配合委托或事件使用的\n\n基本语法\n(参数列表)=>\n&#123;\n //函数体\n&#125;;//此处要加分号\n使用方法\nusing System;\nusing System.Collections;\nusing System.Collections.Generic;\n\nnamespace JinJie\n&#123;\n\n    class Program\n    &#123;\n        static void Main()\n        &#123;\n            //无参\n            Action a = () => &#123; Console.WriteLine(\"无参Lambad使用\"); &#125;;\n            a();\n\n            //有参无返回值不省略类型\n            Action&lt;int> b = (int Value) => &#123; Console.WriteLine(Value); &#125;;\n            b(20);\n\n            //有参无返回值省略类型\n            Action&lt;int> c = (Value) => &#123; Console.WriteLine(Value); &#125;;\n            c(33);\n\n            //无参有返回值\n            Func&lt;int> d = () => &#123; return 123; &#125;;\n            Console.WriteLine(d());\n\n            //有参有返回值\n            Func&lt;int, string> e = (Value) =>\n            &#123;\n                Console.WriteLine(Value);\n                return \"123\";\n            &#125;;\n\n            Console.WriteLine(e(333));\n        &#125;\n\n    &#125;\n\n&#125;\n闭包（重要知识点）\n\n内层的函数可以引用包含在它外层的函数的变量\n即使外层函数执行已经中止\n特别注意：该变量提供的值并非变量创建的值，而是在父函数范围内的最终值\n\n\n\nusing System;\nusing System.Collections;\nusing System.Collections.Generic;\n\nnamespace JinJie\n&#123;\n\n    class Program\n    &#123;\n\n        static void Test()\n        &#123;\n            int x = 10;\n            //闭包\n            Action a = () =>\n            &#123;\n                Console.WriteLine(x);\n            &#125;;\n            for (int i = 0; i &lt; 10; i++)\n            &#123;\n                x++;\n                a += () =>\n                &#123;\n                    Console.WriteLine(x);\n                &#125;;\n            &#125;\n\n            //会一直打印20，因为闭包中使用的变量提供的值并非变量创建的值，而是在父函数范围内的最终值\n            a();\n        &#125;\n\n        static void Main()\n        &#123;\n            Test();\n        &#125;\n\n    &#125;\n\n&#125;\n\n\n闭包中的注意事项\nusing System;\nusing System.Collections;\nusing System.Collections.Generic;\n\nnamespace JinJie\n&#123;\n\n    class Program\n    &#123;\n        static Action Test()\n        &#123;\n            Action a=null;\n\n            for (int i = 0; i &lt; 11; i++)\n            &#123;\n                //此Index非彼Index 每次循环都会创建一个新的Index，所以每次打印的都是当前Index的最终值\n                int Index = i;\n                a += () =>\n                &#123;\n                    Console.WriteLine(Index);\n                &#125;;\n            &#125;\n            return a;\n        &#125;\n      \n\n        static void Main()\n        &#123;\n            //会打印0~10\n            Test()();\n        &#125;\n\n    &#125;\n\n&#125;\n\nList排序\nSort:内置类型可以直接使用Sort排序\n\n自定义类排序需要继承接口IComparable&lt;&gt;\n\n该接口返回值的含义\n\n\n\n返回值\n含义\n\n\n\n小于0\n放在传入对象的前面\n\n\n等于0\n保持当前位置不变\n\n\n大于0\n放在传入对象的后面\n\n\nclass Test : IComparable&lt;Test>\n        &#123;\n            public int c;\n            public Test(int c)\n            &#123;\n                this.c = c;\n            &#125;\n\n            public int CompareTo(Test other)\n            &#123;\n                if (c > other.c)\n                &#123;\n                    return 1;\n                &#125;\n                else if (c == other.c)\n                &#123;\n                    return 0;\n                &#125;\n                else\n                &#123;\n                    return -1;\n                &#125;\n            &#125;\n        &#125;\n\n\n通过委托排序\nusing System;\nusing System.Collections.Generic;\n\nnamespace CSharp\n&#123;\n\n    class Test\n    &#123;\n        public int A;\n        public Test(int A)\n        &#123;\n            this.A = A;\n        &#125;\n    \n    &#125;\n\n    class Program\n    &#123;\n        static void Main(string[] args)\n        &#123;\n            List&lt;Test> L1 = new List&lt;Test>();\n            L1.Add(new Test(1));\n            L1.Add(new Test(3));\n            L1.Add(new Test(2));\n            L1.Add(new Test(4));\n            L1.Add(new Test(6));\n            L1.Add(new Test(5));\n            L1.Add(new Test(7));\n\t\t\t\n\t\t\t//使用委托\n\t\t\t//可以重载Sort传递一个函数\n            L1.Sort(SortTest);\n\n            foreach (Test item in L1)\n            &#123;\n                Console.WriteLine(item.A);\n            &#125;\n        &#125;\n\t\t\n\t\t\n        static int SortTest(Test A, Test B)\n        &#123;\n            if (A.A > B.A)\n            &#123;\n                return 1;\n            &#125;\n            else if (A.A == B.A)\n            &#123;\n                return 0;\n            &#125;\n            else\n            &#123;\n                return -1;\n            &#125;\n        \n        &#125;\n    &#125;\n&#125;\n通过匿名函数\nusing System;\nusing System.Collections.Generic;\n\nnamespace CSharp\n&#123;\n\n    class Test\n    &#123;\n        public int A;\n        public Test(int A)\n        &#123;\n            this.A = A;\n        &#125;\n    \n    &#125;\n\n    class Program\n    &#123;\n        static void Main(string[] args)\n        &#123;\n            List&lt;Test> L1 = new List&lt;Test>();\n            L1.Add(new Test(1));\n            L1.Add(new Test(3));\n            L1.Add(new Test(2));\n            L1.Add(new Test(4));\n            L1.Add(new Test(6));\n            L1.Add(new Test(5));\n            L1.Add(new Test(7));\n\n            //通过匿名函数\n            L1.Sort(delegate(Test A,Test B)\n            &#123;\n                if (A.A > B.A)\n                &#123;\n                    return 1;\n                &#125;\n                else if (A.A == B.A)\n                &#123;\n                    return 0;\n                &#125;\n                else\n                &#123;\n                    return -1;\n                &#125;\n            &#125; );\n\n            foreach (Test item in L1)\n            &#123;\n                Console.WriteLine(item.A);\n            &#125;\n        &#125;\n    &#125;\n&#125;\n通过Lambad表达式\nusing System;\nusing System.Collections.Generic;\n\nnamespace CSharp\n&#123;\n\n    class Test\n    &#123;\n        public int A;\n        public Test(int A)\n        &#123;\n            this.A = A;\n        &#125;\n    \n    &#125;\n\n    class Program\n    &#123;\n        static void Main(string[] args)\n        &#123;\n            List&lt;Test> L1 = new List&lt;Test>();\n            L1.Add(new Test(1));\n            L1.Add(new Test(3));\n            L1.Add(new Test(2));\n            L1.Add(new Test(4));\n            L1.Add(new Test(6));\n            L1.Add(new Test(5));\n            L1.Add(new Test(7));\n\n\t\t\t//通过Lambad表达式\n            L1.Sort((Test A, Test B)=>\n            &#123;\n                if (A.A > B.A)\n                &#123;\n                    return 1;\n                &#125;\n                else if (A.A == B.A)\n                &#123;\n                    return 0;\n                &#125;\n                else\n                &#123;\n                    return -1;\n                &#125;\n            \n            &#125;);\n\n            foreach (Test item in L1)\n            &#123;\n                Console.WriteLine(item.A);\n            &#125;\n        &#125;\n\n\n    &#125;\n&#125;\n\n协变(out)和逆变(in)\n用于在泛型中修饰泛型字母的\n只有泛型接口和泛型委托可以使用\n作用\n用out修饰的泛型，只能作为返回值\n用in修饰的泛型，只能作为参数\n\n\n\n协变\n里氏替换原则中父类可以装子类，子类变父类\n父类泛型委托装子类泛型委托\n\n逆变\n里氏替换原则中父类可以装子类 但是子类不能装父类，父类变子类 如object变成string\n子类泛型委托装父类泛型委托\n\n多线程进程\n进程(Process)是计算机中的程序关于某数据集合上的一次运行活动\n打开一个应用程序就是在操作系统上开启一个进程\n进程之间可以相互独立运行，互不干扰\n进程之间也可以相互访问，操作\n\n线程\n操作系统能够进行运算调度的最小单位\n\n包含在进程中，是进程的实际运作单位\n\n一条线程是进程中的一个单一顺序的控制流，一个进程中可以并发多个线程\n\n语法\n\n线程类Thread\n\n需要命名空间 using System.Threading;\n//申明一个新线程\n//线程执行的代码，需要封装到一个函数中\n\n//启动线程 Start\n\n//设置为后台线程 IsBackground\n//当前台线程都结束时，整个程序就结束了，即使还有后台线程在运行\n//后台线程不会防止应用程序的进程被终止\n//如果不设置为后台进程，可能会导致进程无法正常关闭\n\n//关闭释放一个线程\n//如果开启的线程中不是死循环，是能够结束的逻辑，那么不要刻意的去关闭它\n//如果是死循环 想要中止该线程 有两种方法\n//死循环中的bool标识\n//通过线程提供的方法（.Net core版本中无法中止 会报错） Abort; 之后置null\n\n//线程休眠 Sleep 让线程休眠多少毫秒 在哪个线程中执行就休眠哪个线程\n\n//线程之间共享数据\n//多个线程使用的内存是共享的，都属于该应用程序\n//当多线程同时操作同一片内存区域时可能会出现问题\n//可以通过加锁的形式避免问题 lock \n\n\n多线程一般用于处理一些复杂耗时的逻辑，比如寻路，网络通信等\n\n\n预处理器指令\n什么是编译器\n\n编译器是一种翻译程序\n将源语言程序翻译成目标语言程序\n源语言程序：C# C++ Java等语言写出的源程序\n目标语言程序：二进制数表示的伪机器代码的程序\n\n\n以#开头\n\n预处理器指令不是语句，所以不以分号;结束\n\n常用预处理器指令\n#define\n\n#undef\n\n#if\n#elif\n#else\n#endif\n//与if语句规则一样，一般配合#define定义的符号使用\n//用于告诉编译器进行编译代码的流程控制\n\n#warning\n#error\n//告诉编译器是报警告还是报错误\n//一般配合#if使用\n\n反射\n程序集：由编译器编译得到的，供进一步编译执行的那个中间产物\n\n在windows系统中一般表现为后缀为.dll(库文件)或者.exe(可执行文件)的格式\n\n\n元数据：用来描述数据的数据，有关程序以及类型的数据被称为元数据（类，类中的函数，变量等信息），被保存在程序集中\n\n反射的概念：程序在运行时，可以查看其它程序集或者自身的元数据\n\n一个运行的程序查看本身或者其它程序的元数据的行为叫做反射\n\n\n反射的作用\n\n程序运行时得到所有元数据，包括元数据的特性\n程序运行时，实例化对象，操作对象\n程序运行时创建新对象，用这些对象执行任务\n\n\n语法\n\nType\n\n类的信息类\n\n反射功能的基础\n\n访问元数据的主要方式\n\n使用Type的成员获取有关类型声明的信息\n\n有关类型的成员（构造函数，方法，字段，属性和类的事件等）\n\n获取Type的三种方式\n//万物之父object中的GetType()可以获取对象的Type\nint a = 42;\nType T1 = a.GetType();\nConsole.WriteLine(T1);\n\n//通过typeof关键字 传入类名 也可以得到对象的Type\nType T2 = typeof(int);\nConsole.WriteLine(T2);\n\n//通过类的名字（必须包含命名空间）也可以得到对象的Type\nType T3 = Type.GetType(\"System.Int32\");\nConsole.WriteLine(T3);\n得到类的程序集信息：Assembly\n\n获取类中的所有公共成员\n#define cccc\nusing System;\nusing System.Collections.Generic;\nusing System.Reflection;\nusing System.Threading;\n\nnamespace CSharp\n&#123;\n    class Test\n    &#123;\n        private int a;\n        public string b;\n        public float c;\n\n        public Test()\n        &#123;\n            \n        &#125;\n\n        public Test(int a, string b, float c)\n        &#123;\n            this.a = a;\n            this.b = b;\n            this.c = c;\n        &#125;\n    &#125;\n\n\n    class Program\n    &#123;\n        static void Main(string[] args)\n        &#123;\n            //首先得到Type\n            Type T1 = typeof(Test);\n\n            //GetMembers()获得所有公共成员,需要引入命名空间using System.Reflection;\n            MemberInfo[] M1 = T1.GetMembers();\n\n            for (int i = 0; i &lt; M1.Length; i++)\n            &#123;\n                Console.WriteLine(M1[i]);\n            &#125;\n\n            Console.WriteLine(\"************************************\");\n\n            //获得所有构造函数\n            ConstructorInfo[] ctors = T1.GetConstructors();\n            for (int i = 0; i &lt; ctors.Length; i++)\n            &#123;\n                Console.WriteLine(ctors[i]);\n            &#125;\n\n            //获得其中一个构造函数 并执行\n            //得构造函数 传入Type数组 数组中的内容按顺序是构造函数形参类型\n            //执行构造函数 传入object数组 数组中的内容按顺序传入参数\n\n            //获得无参构造\n            ConstructorInfo info = T1.GetConstructor(new Type[0]);\n\n            //执行无参构造 没有参数时传null\n            Test t1 = info.Invoke(null) as Test;\n\n            //得到有参构造\n            ConstructorInfo info2 = T1.GetConstructor(new Type[] &#123; typeof(int), typeof(string), typeof(float) &#125;);\n            Test t2 = info2.Invoke(new object[] &#123; 10, \"123\", 10.2f &#125;) as Test;\n            Console.WriteLine(t2.b);\n\n            //等等，剩余的可以去微软官网查看API\n        &#125;\n\n\n    &#125;\n&#125;\n\n\n\nAssembly\n\n用来加载外部的程序集\n三种加载程序集的函数\nAssembly.Load(“程序集名称”)：一般用来加载同一文件夹下的其它程序集\nAssembly.LoadFrom(“包含程序集清单的文件的名称或路径”)：一般用来加载不在同一文件下的其它程序集\nAssembly.LoadFile(“要加载的文件的完全限定路径”)：一般用来加载不在同一文件下的其它程序集\n\n\n\n\nActivator\n\n用于将Type对象快捷实例化为对象\n//首先得到Type\nType T2 = typeof(Test);\n      \n//用无参构造实例化一个对象\nTest t3 = Activator.CreateInstance(T2) as Test;\n      \n//用有参构造实例化一个对象\nTest t4 = Activator.CreateInstance(T2, 12, \"string\", 10.2f) as Test;\n\n\n\n\n\n特性\n系统自带的特性\n\n过时特性\n[Obsolete(\"...\",true/false)]//true使用时会直接报错，false使用时会出现警告\n调用者信息特性\n\n\n外部Dll包函数\n\n\n\n\n\n迭代器\n用yield return语法糖实现迭代器（本质是C#自动帮我们实现标准迭代器的复杂步骤）\n关键接口：IEnumerable\n\n\n\nusing System;\nusing System.Collections;\nusing System.Collections.Generic;\nusing System.Reflection;\n\nnamespace JinJie\n&#123;\n\n    class Program\n    &#123;\n\n        class Test:IEnumerable\n        &#123;\n            private List&lt;int> L1;\n            public Test ()\n            &#123;\n                L1 = new List&lt;int> &#123; 1, 2, 3, 45, 6, 78, 9 &#125;;\n            &#125;\n\t\t\t//yield return语法糖实现迭代器\n            public IEnumerator GetEnumerator()\n            &#123;\n                for (int i = 0; i &lt; L1.Count; i++)\n                &#123;\n                    yield return L1[i];\n                &#125;\n            &#125;\n        &#125;\n\n        static void Main()\n        &#123;\n            Test T1 = new Test();\n            foreach (int item in T1)\n            &#123;\n                Console.WriteLine(item);\n            &#125;\n        &#125;\n    &#125;\n&#125;\n\n","slug":"CSharp语法","date":"2022-09-13T15:16:35.000Z","categories_index":"C#","tags_index":"C#语法","author_index":"cBao"},{"id":"321e20a64de3485e0958a3f7db00142f","title":"UE中的网络同步RPC","content":"UE网络中的服务器在哪！\n在UE中存在服务器和客户端重合，创建房间的客户端同时具备服务器特性\n\nUE中服务器和客户端中对象的关系\n在服务器端，所有的角色（Actor）都是Authority（权威的）\n在客户端眼，除了自己控制的角色外，其他的所有角色都是Simulated proxy（模拟代理）\n在UE网络框架中，Actor是促成网络同步的重要对象\n\nActor的更新方式\n属性更新（针对成员变量）具有及时性，随属性变换而进行通知。属性更新不变化不消耗带宽，但会消耗CPU进行监听\nRPC（针对函数），由用户进行调用\n\nUE网络框架对象归属分类\n\n\nServer Only（仅存在于服务器上）\nServer &amp; Clients（存在于服务器和所有客户端）\nServer &amp; Owning Client（仅存在于服务器和自身客户端）\nOwning Client Only（仅存在于自己客户端）\n\n\n\nAGameMode\nAGameState\nAPlayerController\nAHUD\n\n\n\nAPlayerState\n\nUMG Widget\n\n\n\nAPawn\n\n\n\n\n角色类型标记\n每个Actor中都存在两个属性用来裁定当前Actor在服务器/客户端上的身份类型，分为Role和RemoteRole\n在蓝图中为LocalRole和RemoteRole\nGet Local Role：判断当前角色在本地端身份类型\nGet Remote Role：判断当前角色在远端身份类型（当是客户端时，远端为服务端，当是服务端时，远端是客户端）\n\n网络角色三种类型\nSimulated：由服务器进行数据发送，当前终端进行操控模拟。操控来源于服务器，Simulate对象无法执行RPC函数\nAutonomous：由当前终端实例进行操控。操控来源于真人\nAuthority：服务器端存在标记，表明当前Actor存在于服务器\n\nRPC远端调用，在本机上调用函数，但在其他机器上远程执行的函数。\nRPC执行的三种形式\n服务端执行（Server） ：由客户端调用，在服务器端执行\n客户端执行（Client）： 由服务器端调用，在客户端执行\n所有终端执行（Multicast）  ：由服务器端调用，在所有终端执行\n\nRPC调用注意事项\n必须从 Actor 上调用\n\nActor 必须能被复制（Replicates=true）\n\n如果 RPC 是从服务器调用并在客户端上执行，则只有实际拥有这个 Actor 的客户端才会执行函数\n\n如果 RPC 是从客户端调用并在服务器上执行，客户端就必须拥有调用 RPC 的 Actor。\n\n从服务器上调用RPC\n\n\n\nActor所有权\n未复制\nNetMulticast\nServer\nClient\n\n\n\nClient-Owned Actor\n在服务器上运行\n在服务器和所有客户端上运行\n在服务器上运行\n在 actor  的所属客户端上运行\n\n\nServer-owned actor\n在服务器上运行\n在服务器和所有客户端上运行\n在服务器上运行\n在服务器上运行\n\n\nUnowned actor\n在服务器上运行\n在服务器和所有客户端上运行\n在服务器上运行\n在服务器上运行\n\n\n\n从客户端上调用RPC\n\n\n\nActor所有权\n未复制\nNetMulticast\nServer\nClient\n\n\n\nOwned by invoking client（当前终端所有权）\n在执行调用的客户端上运行\n在执行调用的客户端上运行\n在服务器上运行\n在执行调用的客户端上运行\n\n\nOwned by a different client  （其他终端所有权）\n在执行调用的客户端上运行\n在执行调用的客户端上运行\n丢弃\n在执行调用的客户端上运行\n\n\nServer-owned actor\n在执行调用的客户端上运行\n在执行调用的客户端上运行\n丢弃\n在执行调用的客户端上运行\n\n\nUnowned actor\n在执行调用的客户端上运行\n在执行调用的客户端上运行\n丢弃\n在执行调用的客户端上运行\n\n\n\n\n蓝图中判断服务器和客户端\n\nAuthority：服务器\nRemote：客户端\n\nRPC执行的三种形式\n服务端执行（Server）：在客户端调用，在服务端执行\n客户端执行（Client）:在服务端调用，在客户端执行\n所有终端执行（Multicast）：只能在服务端调用，在所有终端执行\n\n设置Actor所有权\n蓝图中使用Set Owner节点在服务器上获得Actor所有权\n\n\n\n数据同步\nActor必须满足在网络上被复制,设置的参数需要开启复制\n参数的修正必须在服务器端修改,才可以在网络上同步\n蓝图参数同步的两种方式：\nReplicated，同步数据，但没有通知，无法直接通过参数修改驱动逻辑\n•RepNotify，同步数据，并生成通知函数，进行更新通知（向所有终端通知，满足相关性）\n\n\n\n","slug":"UE中的网络同步RPC","date":"2022-08-15T07:32:03.000Z","categories_index":"UnrealEngine","tags_index":"网络同步RPC","author_index":"cBao"},{"id":"fa2dad943cb3925ed47cb72cd3308d02","title":"UE中的文件API","content":"检查文件夹是否存在//文件路径\nFString Dir=FPaths::ProjectDir()/TEXT(\"cBao\");\n//检查文件是否存在\nIFileManager::Get().DirectoryExists(*Dir)\n\n创建文件夹IFileManager::Get().MakeDirectory(*Dir);\n\n检查文件是否存在//注意是/=\nFString Dir=FPaths::ProjectDir()/TEXT(\"cBao\");\nDir /=TEXT(\"cBao.txt\");\n\n//检查文件是否存在\nIFileManager::Get().FileExists(*Dir);\n//创建文件\n\nFFileHelper::SaveStringToFile(TEXT(\"cBao\"),*Dir);\n\n删除文件FString Dir=FPaths::ProjectDir()/TEXT(\"cBao/cc/cc2/cBao.txt\");\n//一般用于删除单个特定文件\nIFileManager::Get().Delete(*Dir);\n\nFString Dir2=FPaths::ProjectDir()/TEXT(\"cBao\");\n//一般用于删除整个文件夹\nIFileManager::Get().DeleteDirectory(*Dir2,true,true);\n\n拷贝文件//不带拷贝进度的拷贝\nFString Src=FPaths::ProjectDir()/TEXT(\"cBao/cc.pdf\");\nFString Dest=FPaths::ProjectDir()/TEXT(\"cBao/cc2.pdf\");\nIFileManager::Get().Copy(*Dest,*Src);\n\n//带拷贝进度的拷贝\n//继承FCopyProgress抽象类,用来显示拷贝进度\nstruct MyProgress:public FCopyProgress\n&#123;\n    //Fraction为拷贝进度百分比\n\tFORCEINLINE virtual bool Poll( float Fraction ) override\n\t&#123;\n\t\tGEngine->AddOnScreenDebugMessage(-1,10.f,FColor::Blue,FString::SanitizeFloat(Fraction));\n\t\treturn true;\n\t&#125;\n&#125;;\nFString Src2=FPaths::ProjectDir()/TEXT(\"cBao/cc.pdf\");\nFString Dest2=FPaths::ProjectDir()/TEXT(\"cBao/cc2.pdf\");\n//创建进度结构\nMyProgress cBaoProgress;\nIFileManager::Get().Copy(*Dest2,*Src2,true,false,false,&amp;cBaoProgress);\n\n文件信息//文件信息(创建日期，访问日期，修改日期，文件大小，是否是文件夹，是否只读，是否有效)\nFFileStatData FileState=IFileManager::Get().GetStatData(*Src);\n\n查找文件//文件路径\nFString Dir=FPaths::ProjectDir()/TEXT(\"cBao\");\n//检查路径是否存在\nif (IFileManager::Get().DirectoryExists(*Dir))\n&#123;\n    //保存文件名称\n\tTArray&lt;FString> NameArray;\n    //查找文件操作 *代表通配符\n\tIFileManager::Get().FindFiles(NameArray,*Dir,TEXT(\"*\"));\n\tfor(auto &amp;Temp:NameArray)\n\t&#123;\n\t\tGEngine->AddOnScreenDebugMessage(-1,10.f,FColor::Blue,Temp);\n\t&#125;\n&#125;\n\n递归查找指定目录下的文件路径//文件路径\nFString Dir=FPaths::ProjectDir()/TEXT(\"cBao\");\n//检查路径是否存在\nif (IFileManager::Get().DirectoryExists(*Dir))\n&#123;\n    //保存文件路径\n\tTArray&lt;FString> PathNameArray;\n    //查找文件操作 *代表通配符 第一个true代表查找文件,第二个false代表忽略文件夹\n\tIFileManager::Get().FindFilesRecursive(PathNameArray,*Dir,TEXT(\"*\"),true,false);\n\tfor (auto&amp; Name:PathNameArray)\n\t&#123;\n\t\tGEngine->AddOnScreenDebugMessage(-1,10.f,FColor::Red,Name);\n\t&#125;\n\n&#125;\n\n","slug":"UE中的文件操作","date":"2022-08-05T05:58:47.000Z","categories_index":"UnrealEngine","tags_index":"文件操作","author_index":"cBao"},{"id":"62bbf97645975b25a08d1c093027a65e","title":"UE中内存操作","content":"分配内存// C\nuint8* Ptr_C=(uint8*)malloc(sizeof(uint8)*1024);\n\t\n// C++\nuint8* Ptr_CPlus=new uint8[1024];\n\n// UEC++\nuint8* Ptr_UnrealCPlus=(uint8*)FMemory::Malloc(sizeof(uint8)*1024);\n\n\n重新分配内存// C/C++\nPtr_C=(uint8*)realloc(Ptr_C,sizeof(uint8)*2048);\n\t\n// UEC++\nFMemory::Realloc(Ptr_UnrealCPlus,sizeof(uint8)*2048);\n\n获得分配的内存大小int32 i = FMemory::GetAllocSize(Ptr_UnrealCPlus);\n\n\n\n\n\n\n\n\n特别注意\n只能获得 FMemory::Malloc() 分配的内存大小，否则会产生崩溃\n\n拷贝char Date1[1024]=\"Hello,World\";\nchar Date2[1024];\n// C/C++\nmemcpy(Date2,Date1,strlen(Date1));\n\n// UEC++\nFMemory::Memcpy(Date2,Date1,strlen(Date1));\n\n移动内存char Date1[1024]=\"Hello,World\";\nchar Date2[1024];\n// C/C++\nmemmove(Date2,Date1,strlen(Date1));\n\n// UEC++\nFMemory::Memmove(Date2,Date1,strlen(Date1));\n\n比较// C/C++\nchar DateComp[1024]=\"cBao2\";\nchar DateComp_2[1024]=\"cBao\";\nint32 Size=memcmp(DateComp,DateComp_2,sizeof(uint8)*5);\n\n// UEC++\nint32 Size2 = FMemory::Memcmp(DateComp,DateComp_2,sizeof(uint8)*5);\n\n\n\n\n\n\n\n\n注意\n当 DateComp&lt;DateComp_2 时返回值&lt;0\n当 DateComp=DateComp_2 时返回值=0\n当 DateComp&gt;DateComp_2 时返回值&gt;0\n\n\n交换char DateComp[1024]=\"cBao2\";\nchar DateComp_2[1024]=\"cBao\";\nFMemory::Memswap(DateComp,DateComp_2,sizeof(uint8)*5)\n\n\n\n\n\n\n\n\n注意\n仅UEC++中存在该API\n\n\n初始化方式//原生C\nmemset(Ptr_C,0,sizeof(uint8)*1024);\nmemset(Ptr_CPlus,0,sizeof(uint8)*1024);\n\n//C++中\nuint8* Ptr_CPlus2=new uint8[]&#123;1,23,4,5,5&#125;;\n\t\n//UEC++\nZeroMemory(Ptr_C,sizeof(uint8)*1024);\nZeroMemory(Ptr_CPlus,sizeof(uint8)*1024);\nFMemory::Memset(Ptr_UnrealCPlus,0,sizeof(uint8)*1024);\nFMemory::Memzero(Ptr_UnrealCPlus,sizeof(uint8)*1024);\n//在申请时就进行初始化\nuint8* Ptr_UnrealC=(uint8*)FMemory::MallocZeroed(sizeof(uint8)*1024);\n\n清除//C\nfree(Ptr_C);\n\t\n//C++中\ndelete[](Ptr_CPlus);\ndelete[](Ptr_CPlus2);\n\n//UEC++中\nFMemory::Free(Ptr_UnrealCPlus);\n\n\n\n\n\n\n\n\n特别注意\nFMemory::Free() 容易造成引擎崩溃\n\n\n","slug":"UE内存操作","date":"2022-08-04T07:41:08.000Z","categories_index":"UnrealEngine","tags_index":"内存操作","author_index":"cBao"},{"id":"ae911ea8c615446cd5e6fd02771c3f77","title":"Json","content":"JSON 语法规则\n数据在键/值对中\n数据由逗号 , 分隔\n使用斜杆来转义 \\ 字符\n大括号 {} 保存对象\n中括号 [] 保存数组，数组可以包含多个对象\n\nJSON 键值对JSON 数据的书写格式是：\n\"name\" : \"cBao\"\n\nJSON 值可以是\n数字（整数或浮点数）\n\"age\":30\n字符串（在双引号中）\n\"name\":\"cBao\"\n逻辑值（true 或 false）\n\"IsDeath\":false\n数组（在中括号中）\n&#123;\n    \"Info\": [\n    &#123; \"age1\":30 , \"name1\":\"cBao\" &#125;, \n    &#123; \"age2\":30 , \"name2\":\"cBao\" &#125;, \n    &#123; \"age3\":30 , \"name3\":\"cBao\" &#125;,\n    ]\n&#125;\n对象（在大括号中）\n&#123;\n  \"Object\":&#123;\n      \"age\":30, \n    \"name\":\"cBao\" \n  &#125;  \n&#125;\nnull\n\"runoob\":null\n\nUE5中将结构体转换成Json示例\n.Build.cs文件需要加入\nPrivateDependencyModuleNames.Add(\"Json\");\n.h文件\n// Fill out your copyright notice in the Description page of Project Settings.\n\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"Kismet/BlueprintFunctionLibrary.h\"\n#include \"StructToJson.generated.h\"\n\nUSTRUCT(BlueprintType)\nstruct FMyInfo\n&#123;\n\tGENERATED_BODY()\n\n\tUPROPERTY(EditAnywhere,BlueprintReadWrite)\n\tFString Name;\n\tUPROPERTY(EditAnywhere,BlueprintReadWrite)\n\tint32 Age;\n&#125;;\n\n\nUSTRUCT(BlueprintType)\nstruct FMyStruct\n&#123;\n\tGENERATED_BODY()\n\t\n\tUPROPERTY(EditAnywhere,BlueprintReadWrite)\n\tFString Name;\n\t\n\tUPROPERTY(EditAnywhere,BlueprintReadWrite)\n\tint32 Age;\n\t\n\tUPROPERTY(EditAnywhere,BlueprintReadWrite)\n\tbool Gender;\n\t\n\tUPROPERTY(EditAnywhere,BlueprintReadWrite)\n\tfloat Weight;\n\n\tUPROPERTY(EditAnywhere,BlueprintReadWrite)\n\tFMyInfo Info;\n\t\n\tUPROPERTY(EditAnywhere,BlueprintReadWrite)\n\tTArray&lt;FMyInfo> Array;\n&#125;;\n\n/**\n * \n */\nUCLASS()\nclass UE_ADVANCE_API UStructToJson : public UBlueprintFunctionLibrary\n&#123;\n\tGENERATED_BODY()\n\n\tUFUNCTION(BlueprintCallable,Category=cBao)\n\tstatic FString StructToString(const FMyStruct&amp; s1);\n\n&#125;;\n\n.cpp文件\n// Fill out your copyright notice in the Description page of Project Settings.\n\n\n#include \"StructToJson.h\"\n\nFString UStructToJson::StructToString(const FMyStruct&amp; s1)\n&#123;\n\t\tFString JsonString;\n\t\t//UE中的Json工程模式\n\t\tTSharedPtr&lt;TJsonWriter&lt;TCHAR,TCondensedJsonPrintPolicy&lt;TCHAR>>> JsonWriter=TJsonWriterFactory&lt;TCHAR,TCondensedJsonPrintPolicy&lt;TCHAR>>::Create(&amp;JsonString);\n\t\tJsonWriter->WriteObjectStart();\n\t\t&#123;\n\t\t\tJsonWriter->WriteValue(TEXT(\"Name\"),s1.Name);\n\t\t\tJsonWriter->WriteValue(TEXT(\"Age\"),s1.Age);\n\t\t\tJsonWriter->WriteValue(TEXT(\"Gender\"),s1.Gender);\n\t\t\tJsonWriter->WriteValue(TEXT(\"Weight\"),s1.Weight);\n\t\t\tJsonWriter->WriteObjectStart(TEXT(\"Info\"));\n\t\t\t&#123;\n\t\t\t\tJsonWriter->WriteValue(TEXT(\"Name\"),s1.Info.Name);\n\t\t\t\tJsonWriter->WriteValue(TEXT(\"Age\"),s1.Info.Age);\n\t\t\t&#125;\n\t\t\tJsonWriter->WriteObjectEnd();\n\t\t\tJsonWriter->WriteArrayStart(TEXT(\"Array\"));\n\t\t\t&#123;\n\t\t\t\tfor (auto &amp; s:s1.Array)\n\t\t\t\t&#123;\n\t\t\t\t\tJsonWriter->WriteObjectStart();\n\t\t\t\t\t&#123;\n\t\t\t\t\t\tJsonWriter->WriteValue(TEXT(\"Name\"),s.Name);\n\t\t\t\t\t\tJsonWriter->WriteValue(TEXT(\"Age\"),s.Age);\n\t\t\t\t\t&#125;\n\t\t\t\t\tJsonWriter->WriteObjectEnd();\n\t\t\t\t&#125;\n\t\t\t&#125;\n\t\t\tJsonWriter->WriteArrayEnd();\n\t\t&#125;\n\t\tJsonWriter->WriteObjectEnd();\n\t\tJsonWriter->Close();\n\t\treturn JsonString;\n&#125;\n\n蓝图中配置输出\n&#123;\"Name\":\"cBao\",\"Age\":24,\"Gender\":true,\"Weight\":2222,\"Info\":&#123;\"Name\":\"ccc\",\"Age\":32324&#125;,\"Array\":[&#123;\"Name\":\"cdd\",\"Age\":22131&#125;,&#123;\"Name\":\"dsaf\",\"Age\":232&#125;]&#125;\n\nUE5中将Json转换成结构体示例\n.h文件\n//FString反序列化成结构体\nUFUNCTION(BlueprintCallable,Category=cBao)\nstatic bool StructFromFString(const FString&amp; s1,FMyStruct&amp; MyStruct);\n.cpp文件\nbool UStructToJson::StructFromFString(const FString&amp; s1, FMyStruct&amp; MyStruct)\n&#123;\n\tTSharedRef&lt;TJsonReader&lt;>> JsonReader=TJsonReaderFactory&lt;>::Create(s1);\n\tTSharedPtr&lt;FJsonObject> ReadRoot;\n\n\tif (FJsonSerializer::Deserialize(JsonReader,ReadRoot))\n\t&#123;\n\t\t//获得String数据\n\t\tMyStruct.Name=ReadRoot->GetStringField(TEXT(\"Name\"));\n\t\t\n\t\t//获得int数据\n\t\tMyStruct.Age=ReadRoot->GetIntegerField(TEXT(\"Age\"));\n\t\t\n\t\t//获得bool数据\n\t\tMyStruct.Gender=ReadRoot->GetBoolField(TEXT(\"Gender\"));\n\t\t\n\t\t//获得浮点数据\n\t\tMyStruct.Weight=ReadRoot->GetNumberField(TEXT(\"Weight\"));\n\t\t\n\t\t//获得对象数据\n\t\tTSharedPtr&lt;FJsonObject> TestRoot=ReadRoot->GetObjectField(TEXT(\"Info\"));\n\t\t&#123;\n\t\t\tMyStruct.Info.Name=TestRoot->GetStringField(TEXT(\"Name\"));\n\t\t\tMyStruct.Info.Age=TestRoot->GetIntegerField(TEXT(\"Age\"));\n\t\t&#125;\n\n\t\t//获得数组数据\n\t\tTArray&lt;TSharedPtr&lt;FJsonValue>>TempArray=ReadRoot->GetArrayField(TEXT(\"Array\"));\n\t\tfor (auto &amp;i:TempArray)\n\t\t&#123;\n\t\t\tTSharedPtr&lt;FJsonObject> JsonObj = i->AsObject();\n\t\t\tFMyInfo TempInfo;\n\t\t\tTempInfo.Name=JsonObj->GetStringField(TEXT(\"Name\"));\n\t\t\tTempInfo.Age=JsonObj->GetIntegerField(TEXT(\"Age\"));\n\t\t\tMyStruct.Array.Add(TempInfo);\n\t\t&#125;\n\t\treturn true;\n\t&#125;\n\t\n\treturn false;\n&#125;\n\n","slug":"Json","date":"2022-08-02T06:17:49.000Z","categories_index":"Json","tags_index":"Json","author_index":"cBao"},{"id":"32edd7bc4a69fac72c5e2e1809026b07","title":"UE串口通信","content":"sdasfsa\nUE串口通信\n.h文件\n#pragma once\n\n#define FC_DTRDSR       0x01\n#define FC_RTSCTS       0x02\n#define FC_XONXOFF      0x04\n#define ASCII_BEL       0x07\n#define ASCII_BS        0x08\n#define ASCII_LF        0x0A\n#define ASCII_CR        0x0D\n#define ASCII_XON       0x11\n#define ASCII_XOFF      0x13\n\n\n#include \"CoreMinimal.h\"\n#include \"UObject/NoExportTypes.h\"\n#include \"Serial.generated.h\"\n\n/**\n * \n */\n\n // Forward declaration\ntypedef struct _OVERLAPPED OVERLAPPED;\n\nUENUM(BlueprintType, Category = \"UE4Duino\")\nenum class ELineEnd : uint8\n&#123;\n\trn\tUMETA(DisplayName = \"\\r\\n\"),\n\tn\tUMETA(DisplayName = \"\\n\"),\n\tr\tUMETA(DisplayName = \"\\r\"),\n\tnr\tUMETA(DisplayName = \"\\n\\r\")\n&#125;;\n\nUCLASS(BlueprintType, Category = \"UE4Duino\", meta = (Keywords = \"com arduino serial\"))\nclass INKPROJECTION_API USerial : public UObject\n&#123;\n\tGENERATED_BODY()\npublic:\n\t/** Determines the line ending used when writing lines to serial port with PrintLine. */\n\tUPROPERTY(BlueprintReadWrite, Category = \"UE4Duino | String\")\n\t\tELineEnd WriteLineEnd;\n\npublic:\n\tUSerial();\n\t~USerial();\n\n\t/**\n\t * Open a serial port and return the created Serial instance.\n\t * Don't forget to close the port before exiting the game.\n\t *\n\t * @param bOpened If the serial port was successfully opened.\n\t * @param Port The serial port to open.\n\t * @param BaudRate BaudRate to open the serial port with.\n\t * @return A Serial instance to work with the opened port.\n\t */\n\tUFUNCTION(BlueprintCallable, meta = (DisplayName = \"Open Serial Port\"), Category = \"UE4Duino\", meta = (Keywords = \"com arduino serial start\"))\n\t\tstatic USerial* OpenComPort(bool&amp; bOpened, int32 Port = 1, int32 BaudRate = 9600);\n\n\t/**\n\t * Utility function to convert 4 bytes into an Integer. If the input array's length is not 4, returns 0.\n\t *\n\t * @param Bytes A byte array with 4 values representing the integer in little-endian format.\n\t * @return The final integer value or 0 for an invalid array.\n\t */\n\tUFUNCTION(BlueprintPure, meta = (DisplayName = \"Bytes to Int\"), Category = \"UE4Duino\", meta = (Keywords = \"cast concatenate group bit bitwise\"))\n\t\tstatic int32 BytesToInt(TArray&lt;uint8> Bytes);\n\n\t/**\n\t * Utility function to get the 4 bytes that make an integer.\n\t *\n\t * @param Int The integer value to be converted.\n\t * @return A byte array containing the 4 bytes that make the integer, starting from the least significant one (little endian).\n\t */\n\tUFUNCTION(BlueprintPure, meta = (DisplayName = \"Int to Bytes\"), Category = \"UE4Duino\", meta = (Keywords = \"cast separate bit bitwise\"))\n\t\tstatic TArray&lt;uint8> IntToBytes(const int32&amp; Int);\n\n\t/**\n\t * Utility function to convert 4 bytes into a float. If the input array's length is not 4, returns 0.0.\n\t *\n\t * @param Bytes A byte array with 4 values representing the float in IEEE 754 standard format.\n\t * @return The final float value or 0.0 for an invalid array.\n\t */\n\tUFUNCTION(BlueprintPure, meta = (DisplayName = \"Bytes to Float\"), Category = \"UE4Duino\", meta = (Keywords = \"cast concatenate group bit bitwise\"))\n\t\tstatic float BytesToFloat(TArray&lt;uint8> Bytes);\n\n\t/**\n\t * Utility function to get the 4 bytes that make a float.\n\t *\n\t * @param Float The float value to be converted.\n\t * @return A byte array containing the 4 bytes that make the float, in IEEE 754 standard format.\n\t */\n\tUFUNCTION(BlueprintPure, meta = (DisplayName = \"Float to Bytes\"), Category = \"UE4Duino\", meta = (Keywords = \"cast separate bit bitwise\"))\n\t\tstatic TArray&lt;uint8> FloatToBytes(const float&amp; Float);\n\n\t/**\n\t * Open a serial port. Don't forget to close the port before exiting the game.\n\t * If this Serial instance has already an opened port,\n\t * return false and doesn't change the opened port number.\n\t *\n\t * @param Port The serial port to open.\n\t * @param BaudRate BaudRate to open the serial port with.\n\t * @return If the serial port was successfully opened.\n\t */\n\tUFUNCTION(BlueprintCallable, meta = (DisplayName = \"Open Port\"), Category = \"UE4Duino\", meta = (Keywords = \"com start init\"))\n\t\tbool Open(int32 Port = 2, int32 BaudRate = 9600);\n\t/**\n\t * Close and end the communication with the serial port. If not open, do nothing.\n\t */\n\tUFUNCTION(BlueprintCallable, meta = (DisplayName = \"Close Port\"), Category = \"UE4Duino\", meta = (Keywords = \"com end finish release\"))\n\t\tvoid Close();\n\n\t/**\n\t * Will read characters from Serial port until \\0 (null char) is found or there are no\n\t * characters left to read.\n\t *\n\t * @param bSuccess If there was anything to read.\n\t * @return The read string\n\t */\n\tUFUNCTION(BlueprintCallable, meta = (DisplayName = \"Read String\", keywords = \"get read receive string words text characters\"), Category = \"UE4Duino\")\n\t\tFString ReadString(bool&amp; bSuccess);\n\t/**\n\t * Will read characters from Serial port until \\r\\n (Arduino println line end) is found.\n\t *\n\t * @param bSuccess If there was anything to read.\n\t * @return The read string\n\t */\n\tUFUNCTION(BlueprintCallable, meta = (DisplayName = \"Read Line\", keywords = \"get read receive string words text characters\"), Category = \"UE4Duino\")\n\t\tFString Readln(bool&amp; bSuccess);\n\t/**\n\t * Reads the string until a specific char is met.\n\t * The Terminator char won't be included in the result string.\n\t */\n\t //UFUNCTION(BlueprintCallable, meta = (DisplayName = \"Read String Until\", keywords = \"get read receive string words text characters\"), Category = \"UE4Duino\")\n\tFString ReadStringUntil(bool&amp; bSuccess, uint8 Terminator);\n\t/**\n\t * Reads a float from the serial port (sent as 4 bytes).\n\t * @param bSuccess True if there were 4 bytes to read.\n\t * @return The read value\n\t */\n\tUFUNCTION(BlueprintCallable, meta = (DisplayName = \"Read a Float\", keywords = \"get read receive\"), Category = \"UE4Duino\")\n\t\tfloat ReadFloat(bool&amp; bSuccess);\n\t/**\n\t * Reads an integer from the serial port (sent as 4 bytes).\n\t * @param bSuccess True if there were 4 bytes to read.\n\t * @return The read value\n\t */\n\tUFUNCTION(BlueprintCallable, meta = (DisplayName = \"Read an Int\", keywords = \"get read receive integer\"), Category = \"UE4Duino\")\n\t\tint32 ReadInt(bool&amp; bSuccess);\n\t/**\n\t * Reads a byte from the serial port.\n\t * @param bSuccess True if there were 4 bytes to read.\n\t * @return The read value\n\t */\n\tUFUNCTION(BlueprintCallable, meta = (DisplayName = \"Read a Byte\", keywords = \"get read receive\"), Category = \"UE4Duino\")\n\t\tuint8 ReadByte(bool&amp; bSuccess);\n\t/**\n\t * Reads up to Limit bytes from the serial port. If there are less than Limit,\n\t * reads all of them and return True.\n\t * @param bSuccess True if there was at least 1 byte to read.\n\t * @return An array containing the read bytes\n\t */\n\tUFUNCTION(BlueprintCallable, meta = (DisplayName = \"Read Bytes\", keywords = \"get read receive\"), Category = \"UE4Duino\")\n\t\tTArray&lt;uint8> ReadBytes(int32 Limit = 256);\n\n\t/**\n\t * Writes a string without newline to the serial port.\n\t * @param String The string to be sent to the serial port.\n\t * @return True if the string was sent.\n\t */\n\tUFUNCTION(BlueprintCallable, meta = (DisplayName = \"Print\", keywords = \"send write string words text characters\"), Category = \"UE4Duino\")\n\t\tbool Print(FString String);\n\t/**\n\t * Writes a string with newline (\\n) appended at the end to the serial port.\n\t * @param String The string to be sent to the serial port.\n\t * @return True if the string was sent.\n\t */\n\tUFUNCTION(BlueprintCallable, meta = (DisplayName = \"Print Line\", keywords = \"send write string words text characters\"), Category = \"UE4Duino\")\n\t\tbool Println(FString String);\n\t/**\n\t * Writes a float value to the serial port as 4 bytes.\n\t * @param Value The value to be sent to the serial port.\n\t * @return True if the bytes were sent.\n\t */\n\tUFUNCTION(BlueprintCallable, meta = (DisplayName = \"Write a Float\", keywords = \"send\"), Category = \"UE4Duino\")\n\t\tbool WriteFloat(float Value);\n\t/**\n\t * Writes an integer value to the serial port as 4 bytes.\n\t * @param Value The value to be sent to the serial port.\n\t * @return True if the bytes were sent.\n\t */\n\tUFUNCTION(BlueprintCallable, meta = (DisplayName = \"Write an Int\", keywords = \"integer send\"), Category = \"UE4Duino\")\n\t\tbool WriteInt(int32 Value);\n\t/**\n\t * Writes a byte value to the serial port.\n\t * @param Value The value to be sent to the serial port.\n\t * @return True if the byte was sent.\n\t */\n\tUFUNCTION(BlueprintCallable, meta = (DisplayName = \"Write a Byte\", keywords = \"send\"), Category = \"UE4Duino\")\n\t\tbool WriteByte(uint8 Value);\n\t/**\n\t * Writes a byte array as a sequence of bytes to the serial port.\n\t * @param Buffer The byte array to be sent to the serial port.\n\t * @return True if the bytes were sent.\n\t */\n\tUFUNCTION(BlueprintCallable, meta = (DisplayName = \"Write Bytes\", keywords = \"send\"), Category = \"UE4Duino\")\n\t\tbool WriteBytes(TArray&lt;uint8> Buffer);\n\n\t/** Clean the serial port by reading everything left to be read. */\n\tUFUNCTION(BlueprintCallable, meta = (DisplayName = \"Flush Port\"), Category = \"UE4Duino\")\n\t\tvoid Flush();\n\n\t/**\n\t * Check if the serial port is open.\n\t * @return True if the serial port is open.\n\t */\n\tUFUNCTION(BlueprintPure, meta = (DisplayName = \"Is Port Open\"), Category = \"UE4Duino\")\n\t\tbool IsOpened() &#123; return m_hIDComDev != NULL; &#125;\n\n\t/**\n\t * Read the number of the serial port selected for this Serial instance.\n\t * @return The number of the serial port.\n\t */\n\tUFUNCTION(BlueprintPure, meta = (DisplayName = \"Get Port Number\"), Category = \"UE4Duino\")\n\t\tint32 GetPort() &#123; return m_Port; &#125;\n\n\t/**\n\t * Read the selected BaudRate for this Serial instance.\n\t * @return The baud rate.\n\t */\n\tUFUNCTION(BlueprintPure, meta = (DisplayName = \"Get Baud Rate\"), Category = \"UE4Duino\")\n\t\tint32 GetBaud() &#123; return m_Baud; &#125;\n\n\t/**\n\t * Converts a LineEnd enum value to String.\n\t * @param LineEnd LineEnd enum value.\n\t * @return The LineEnd value in string format.\n\t */\n\tUFUNCTION(BlueprintCallable, meta = (DisplayName = \"Line End to String\", keywords = \"cast convert\"), Category = \"UE4Duino\")\n\t\tFString LineEndToStr(ELineEnd LineEnd);\n\nprotected:\n\tvoid* m_hIDComDev;\n\n\t// These are pointers to be able to use OVERLAPPED with forward declaration\n\tOVERLAPPED* m_OverlappedRead;\n\tOVERLAPPED* m_OverlappedWrite;\n\n\tint32 m_Port;\n\tint32 m_Baud;\n&#125;;\n\n.cpp文件\n// Fill out your copyright notice in the Description page of Project Settings.\n\n\n#include \"Serial.h\"\n\n#include \"Windows/AllowWindowsPlatformTypes.h\"\n#include \"Windows/MinWindows.h\"\n#include \"Windows/HideWindowsPlatformTypes.h\"\n#include&lt;iostream>\n#include&lt;cmath>\n#include&lt;cstring>\n\nusing namespace std;\n#define BOOL2bool(B) B == 0 ? false : true\n\nUSerial* USerial::OpenComPort(bool&amp; bOpened, int32 Port, int32 BaudRate)\n&#123;\n\tUSerial* Serial = NewObject&lt;USerial>();\n\tbOpened = Serial->Open(Port, BaudRate);\n\treturn Serial;\n&#125;\n\nint32 USerial::BytesToInt(TArray&lt;uint8> Bytes)\n&#123;\n\tif (Bytes.Num() != 4)\n\t&#123;\n\t\treturn 0;\n\t&#125;\n\n\treturn *reinterpret_cast&lt;int32*>(Bytes.GetData());\n&#125;\n\nTArray&lt;uint8> USerial::IntToBytes(const int32&amp; Int)\n&#123;\n\tTArray&lt;uint8> Bytes;\n\tBytes.Append(reinterpret_cast&lt;const uint8*>(&amp;Int), 4);\n\treturn Bytes;\n&#125;\n\nfloat USerial::BytesToFloat(TArray&lt;uint8> Bytes)\n&#123;\n\tif (Bytes.Num() != 4)\n\t&#123;\n\t\treturn 0;\n\t&#125;\n\n\treturn *reinterpret_cast&lt;float*>(Bytes.GetData());\n&#125;\n\nTArray&lt;uint8> USerial::FloatToBytes(const float&amp; Float)\n&#123;\n\tTArray&lt;uint8> Bytes;\n\tBytes.Append(reinterpret_cast&lt;const uint8*>(&amp;Float), 4);\n\treturn Bytes;\n&#125;\n\nUSerial::USerial()\n\t: WriteLineEnd(ELineEnd::n)\n\t, m_hIDComDev(nullptr)\n\t, m_OverlappedRead(nullptr)\n\t, m_OverlappedWrite(nullptr)\n\t, m_Port(-1)\n\t, m_Baud(-1)\n&#123;\n\t// Allocate the OVERLAPPED structs\n\tm_OverlappedRead = new OVERLAPPED();\n\tm_OverlappedWrite = new OVERLAPPED();\n\n\tFMemory::Memset(m_OverlappedRead, 0, sizeof(OVERLAPPED));\n\tFMemory::Memset(m_OverlappedWrite, 0, sizeof(OVERLAPPED));\n&#125;\n\nUSerial::~USerial()\n&#123;\n\tClose();\n\n\t// Delete allocated OVERLAPPED structs\n\tdelete m_OverlappedRead;\n\tdelete m_OverlappedWrite;\n&#125;\n\nbool USerial::Open(int32 nPort, int32 nBaud)\n&#123;\n\tif (nPort &lt; 0)\n\t&#123;\n\t\tUE_LOG(LogTemp, Error, TEXT(\"Invalid port number: %d\"), nPort);\n\t\treturn false;\n\t&#125;\n\tif (m_hIDComDev)\n\t&#123;\n\t\tUE_LOG(LogTemp, Warning, TEXT(\"Trying to use opened Serial instance to open a new one. \"\n\t\t\t\"Current open instance port: %d | Port tried: %d\"), m_Port, nPort);\n\t\treturn false;\n\t&#125;\n\n\tFString szPort;\n\tif (nPort &lt; 10)\n\t\tszPort = FString::Printf(TEXT(\"COM%d\"), nPort);\n\telse\n\t\tszPort = FString::Printf(TEXT(\"\\\\\\\\.\\\\COM%d\"), nPort);\n\tDCB dcb;\n\n\tm_hIDComDev = CreateFile(*szPort, GENERIC_READ | GENERIC_WRITE, 0, NULL, OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL | FILE_FLAG_OVERLAPPED, NULL);\n\tif (m_hIDComDev == NULL)\n\t&#123;\n\t\tunsigned long dwError = GetLastError();\n\t\tUE_LOG(LogTemp, Error, TEXT(\"Failed to open port COM%d (%s). Error: %08X\"), nPort, *szPort, dwError);\n\t\treturn false;\n\t&#125;\n\n\tFMemory::Memset(m_OverlappedRead, 0, sizeof(OVERLAPPED));\n\tFMemory::Memset(m_OverlappedWrite, 0, sizeof(OVERLAPPED));\n\n\tCOMMTIMEOUTS CommTimeOuts;\n\t//CommTimeOuts.ReadIntervalTimeout = 10;\n\tCommTimeOuts.ReadIntervalTimeout = 0xFFFFFFFF;\n\tCommTimeOuts.ReadTotalTimeoutMultiplier = 0;\n\tCommTimeOuts.ReadTotalTimeoutConstant = 0;\n\tCommTimeOuts.WriteTotalTimeoutMultiplier = 0;\n\tCommTimeOuts.WriteTotalTimeoutConstant = 10;\n\tSetCommTimeouts(m_hIDComDev, &amp;CommTimeOuts);\n\n\tm_OverlappedRead->hEvent = CreateEvent(NULL, true, false, NULL);\n\tm_OverlappedWrite->hEvent = CreateEvent(NULL, true, false, NULL);\n\n\tdcb.DCBlength = sizeof(DCB);\n\tGetCommState(m_hIDComDev, &amp;dcb);\n\tdcb.BaudRate = nBaud;\n\tdcb.ByteSize = 8;\n\n\tif (!SetCommState(m_hIDComDev, &amp;dcb) ||\n\t\t!SetupComm(m_hIDComDev, 10000, 10000) ||\n\t\tm_OverlappedRead->hEvent == NULL ||\n\t\tm_OverlappedWrite->hEvent == NULL)\n\t&#123;\n\t\tunsigned long dwError = GetLastError();\n\t\tif (m_OverlappedRead->hEvent != NULL) CloseHandle(m_OverlappedRead->hEvent);\n\t\tif (m_OverlappedWrite->hEvent != NULL) CloseHandle(m_OverlappedWrite->hEvent);\n\t\tCloseHandle(m_hIDComDev);\n\t\tm_hIDComDev = NULL;\n\t\tUE_LOG(LogTemp, Error, TEXT(\"Failed to setup port COM%d. Error: %08X\"), nPort, dwError);\n\t\treturn false;\n\t&#125;\n\n\t//FPlatformProcess::Sleep(0.05f);\n\tAddToRoot();\n\tm_Port = nPort;\n\tm_Baud = nBaud;\n\treturn true;\n&#125;\n\nvoid USerial::Close()\n&#123;\n\tif (!m_hIDComDev) return;\n\n\tif (m_OverlappedRead->hEvent != NULL) CloseHandle(m_OverlappedRead->hEvent);\n\tif (m_OverlappedWrite->hEvent != NULL) CloseHandle(m_OverlappedWrite->hEvent);\n\tCloseHandle(m_hIDComDev);\n\tm_hIDComDev = NULL;\n\n\tRemoveFromRoot();\n&#125;\n\nFString USerial::ReadString(bool&amp; bSuccess)\n&#123;\n\treturn ReadStringUntil(bSuccess, '\\0');\n&#125;\n\nFString USerial::Readln(bool&amp; bSuccess)\n&#123;\n\treturn ReadStringUntil(bSuccess, '\\n');\n&#125;\n\nFString USerial::ReadStringUntil(bool&amp; bSuccess, uint8 Terminator)\n&#123;\n\tbSuccess = false;\n\tif (!m_hIDComDev) return TEXT(\"\");\n\n\tTArray&lt;uint8> Chars;\n\tuint8 Byte = 0x0;\n\tbool bReadStatus;\n\tunsigned long dwBytesRead, dwErrorFlags;\n\tCOMSTAT ComStat;\n\n\tClearCommError(m_hIDComDev, &amp;dwErrorFlags, &amp;ComStat);\n\tif (!ComStat.cbInQue) return TEXT(\"\");\n\n\tdo &#123;\n\t\tbReadStatus = BOOL2bool(ReadFile(\n\t\t\tm_hIDComDev,\n\t\t\t&amp;Byte,\n\t\t\t1,\n\t\t\t&amp;dwBytesRead,\n\t\t\tm_OverlappedRead));\n\n\t\tif (!bReadStatus)\n\t\t&#123;\n\t\t\tif (GetLastError() == ERROR_IO_PENDING)\n\t\t\t&#123;\n\t\t\t\tWaitForSingleObject(m_OverlappedRead->hEvent, 2000);\n\t\t\t&#125;\n\t\t\telse\n\t\t\t&#123;\n\t\t\t\tChars.Add(0x0);\n\t\t\t\tbreak;\n\t\t\t&#125;\n\t\t&#125;\n\n\t\tif (Byte == Terminator || dwBytesRead == 0)\n\t\t&#123;\n\t\t\t// when Terminator is \\n, we know we're expecting lines from Arduino. But those\n\t\t\t// are ended in \\r\\n. That means that if we found the line Terminator (\\n), our previous\n\t\t\t// character could be \\r. If it is, we remove that from the array.\n\t\t\tif (Chars.Num() > 0 &amp;&amp; Terminator == '\\n' &amp;&amp; Chars.Top() == '\\r') Chars.Pop(false);\n\n\t\t\tChars.Add(0x0);\n\t\t\tbreak;\n\t\t&#125;\n\t\telse Chars.Add(Byte);\n\n\t&#125; while (Byte != 0x0 &amp;&amp; Byte != Terminator);\n\n\tbSuccess = true;\n\tauto Convert = FUTF8ToTCHAR((ANSICHAR*)Chars.GetData());\n\treturn FString(Convert.Get());\n&#125;\n\nfloat USerial::ReadFloat(bool&amp; bSuccess)\n&#123;\n\tbSuccess = false;\n\n\tTArray&lt;uint8> Bytes = ReadBytes(4);\n\tif (Bytes.Num() == 0) return 0;\n\n\tbSuccess = true;\n\treturn *(reinterpret_cast&lt;float*>(Bytes.GetData()));\n&#125;\n\nint32 USerial::ReadInt(bool&amp; bSuccess)\n&#123;\n\tbSuccess = false;\n\n\tTArray&lt;uint8> Bytes = ReadBytes(4);\n\tif (Bytes.Num() == 0) return 0;\n\n\tbSuccess = true;\n\treturn *(reinterpret_cast&lt;int32*>(Bytes.GetData()));\n&#125;\n\nuint8 USerial::ReadByte(bool&amp; bSuccess)\n&#123;\n\tbSuccess = false;\n\tif (!m_hIDComDev) return 0x0;\n\n\tuint8 Byte = 0x0;\n\tbool bReadStatus;\n\tunsigned long dwBytesRead, dwErrorFlags;\n\tCOMSTAT ComStat;\n\n\tClearCommError(m_hIDComDev, &amp;dwErrorFlags, &amp;ComStat);\n\tif (!ComStat.cbInQue) return 0x0;\n\n\tbReadStatus = BOOL2bool(ReadFile(\n\t\tm_hIDComDev,\n\t\t&amp;Byte,\n\t\t1,\n\t\t&amp;dwBytesRead,\n\t\tm_OverlappedRead));\n\n\tif (!bReadStatus)\n\t&#123;\n\t\tif (GetLastError() == ERROR_IO_PENDING)\n\t\t&#123;\n\t\t\tWaitForSingleObject(m_OverlappedRead->hEvent, 2000);\n\t\t&#125;\n\t\telse\n\t\t&#123;\n\t\t\treturn 0x0;\n\t\t&#125;\n\t&#125;\n\n\tbSuccess = dwBytesRead > 0;\n\treturn Byte;\n&#125;\n\nTArray&lt;uint8> USerial::ReadBytes(int32 Limit)\n&#123;\n\tTArray&lt;uint8> Data;\n\n\tif (!m_hIDComDev) return Data;\n\n\tData.Empty(Limit);\n\n\tuint8* Buffer = new uint8[Limit];\n\tbool bReadStatus;\n\tunsigned long dwBytesRead, dwErrorFlags;\n\tCOMSTAT ComStat;\n\n\tClearCommError(m_hIDComDev, &amp;dwErrorFlags, &amp;ComStat);\n\tif (!ComStat.cbInQue) return Data;\n\n\tbReadStatus = BOOL2bool(ReadFile(\n\t\tm_hIDComDev,\n\t\tBuffer,\n\t\tLimit,\n\t\t&amp;dwBytesRead,\n\t\tm_OverlappedRead));\n\n\tif (!bReadStatus)\n\t&#123;\n\t\tif (GetLastError() == ERROR_IO_PENDING)\n\t\t&#123;\n\t\t\tWaitForSingleObject(m_OverlappedRead->hEvent, 2000);\n\t\t&#125;\n\t\telse\n\t\t&#123;\n\t\t\treturn Data;\n\t\t&#125;\n\t&#125;\n\n\tData.Append(Buffer, dwBytesRead);\n\treturn Data;\n&#125;\n\nbool USerial::Print(FString String)\n&#123;\n\tauto Convert = FTCHARToUTF8(*String);\n\tTArray&lt;uint8> Data;\n\tData.Append((uint8*)Convert.Get(), Convert.Length());\n\n\treturn WriteBytes(Data);\n&#125;\n\nbool USerial::Println(FString String)\n&#123;\n\treturn Print(String + LineEndToStr(WriteLineEnd));\n&#125;\n\nbool USerial::WriteFloat(float Value)\n&#123;\n\tTArray&lt;uint8> Buffer;\n\tBuffer.Append(reinterpret_cast&lt;uint8*>(&amp;Value), 4);\n\treturn WriteBytes(Buffer);\n&#125;\n\nbool USerial::WriteInt(int32 Value)\n&#123;\n\tTArray&lt;uint8> Buffer;\n\tBuffer.Append(reinterpret_cast&lt;uint8*>(&amp;Value), 4);\n\treturn WriteBytes(Buffer);\n&#125;\n\nbool USerial::WriteByte(uint8 Value)\n&#123;\n\tTArray&lt;uint8> Buffer(&#123; Value &#125;);\n\treturn WriteBytes(Buffer);\n&#125;\n\nbool USerial::WriteBytes(TArray&lt;uint8> Buffer)\n&#123;\n\tif (!m_hIDComDev) false;\n\n\tbool bWriteStat;\n\tunsigned long dwBytesWritten;\n\n\tbWriteStat = BOOL2bool(WriteFile(m_hIDComDev, Buffer.GetData(), Buffer.Num(), &amp;dwBytesWritten, m_OverlappedWrite));\n\tif (!bWriteStat &amp;&amp; (GetLastError() == ERROR_IO_PENDING))\n\t&#123;\n\t\tif (WaitForSingleObject(m_OverlappedWrite->hEvent, 1000))\n\t\t&#123;\n\t\t\tdwBytesWritten = 0;\n\t\t\treturn false;\n\t\t&#125;\n\t\telse\n\t\t&#123;\n\t\t\tGetOverlappedResult(m_hIDComDev, m_OverlappedWrite, &amp;dwBytesWritten, false);\n\t\t\tm_OverlappedWrite->Offset += dwBytesWritten;\n\t\t\treturn true;\n\t\t&#125;\n\t&#125;\n\n\treturn true;\n&#125;\n\nvoid USerial::Flush()\n&#123;\n\tif (!m_hIDComDev) return;\n\n\tTArray&lt;uint8> Data;\n\n\tdo &#123;\n\t\tData = ReadBytes(8192);\n\t&#125; while (Data.Num() > 0);\n&#125;\n\nFString USerial::LineEndToStr(ELineEnd LineEnd)\n&#123;\n\tswitch (LineEnd)\n\t&#123;\n\tcase ELineEnd::rn:\n\t\treturn TEXT(\"\\r\\n\");\n\tcase ELineEnd::n:\n\t\treturn TEXT(\"\\n\");\n\tcase ELineEnd::r:\n\t\treturn TEXT(\"\\r\");\n\tcase ELineEnd::nr:\n\t\treturn TEXT(\"\\n\\r\");\n\tdefault:\n\t\treturn TEXT(\"null\");\n\t&#125;\n&#125;\n蓝图使用\n\n蓝图代码连接https://blueprintue.com/blueprint/ss-s-s83/\n\n\n","slug":"UE串口通信","date":"2022-07-22T08:14:36.000Z","categories_index":"UnrealEngine","tags_index":"串口通信","author_index":"cBao"},{"id":"650e8b54c427468049a9eded7ddf3373","title":"C++仿函数和代理","content":"仿函数\n\n\n\n\n\n提示\n需要头文件#include &lt; functional &gt;\n\n仿函数与普通函数#include &lt;iostream>\n#include &lt;functional>\n\nint Test(int A, int B)\n&#123;\n\tstd::cout&lt;&lt;A+B&lt;&lt;std::endl;\n\treturn A+B;\n&#125;\n\nint main()\n&#123;\n\tstd::function&lt;int(int,int)> Func_Test=Test;\n\tFunc_Test(2,3);\n&#125;\n\n\nint(int,int)：返回类型(形参列表)\n\n仿函数与Lambda#include &lt;iostream>\n#include &lt;functional>\n\nauto Lam=[&amp;](int A,int B)\n&#123;\n\tstd::cout&lt;&lt;A+B&lt;&lt;std::endl;\n\treturn A+B;\n&#125;;\n\nint main()\n&#123;\n\tstd::function&lt;int(int,int)> Fun_Test=Lam;\n\tFun_Test(3,4);\n&#125;\n\n","slug":"C++仿函数和代理","date":"2022-07-17T07:19:09.000Z","categories_index":"C++","tags_index":"仿函数和代理","author_index":"cBao"},{"id":"8655ec3b78f346469051ac63e86fd947","title":"C存储类","content":"C存储类\n\n\n\n\n\n\n注意\n存储类定义 C 程序中变量/函数的范围（可见性）和生命周期。这些说明符放置在它们所修饰的类型之前\nC中四种存储类：\n\nauto\nregister\nstatic\nextern\n\n\n\nauto 存储类auto 存储类是所有局部变量默认的存储类\n//注意是在花括号里的局部变量,Age1和Age2是相同存储类\n&#123;\n\tint Age1\n\tauto int Age2;\n&#125;\n\n\n\n\n\n\n\n\n注意\nauto只能修饰在函数内的局部变量\n\n\nregister 存储类register 存储类用于定义存储在寄存器中而不是 RAM 中的局部变量\n&#123;\n\tregister int Miles;\n&#125;\n\n\n\n\n\n\n\n\n注意\n寄存器只用于需要快速访问的变量，比如计数器\n不能对register修饰的变量使用取地址符”&amp;”，因为不在RAM中，所以没有内存地址\n定义 ‘register’ 并不意味着变量将被存储在寄存器中，它意味着变量可能存储在寄存器中，这取决于硬件和实现的限制\n\n\nstatic 存储类作用于局部变量：\n\nstatic 存储类指示编译器在程序的生命周期内保持局部变量的存在\n使用 static 修饰局部变量可以在函数调用之间保持局部变量的值\n\n作用于全局变量：\n\n当 static 修饰全局变量时，会使变量的作用域限制在声明它的文件内\n全局声明的一个 static 变量或方法可以被任何函数或方法调用，只要这些方法出现在跟 static 变量或方法同一个文件\n\nextern 存储类\nextern 存储类用于提供一个全局变量的引用，全局变量对所有的程序文件都是可见的\n对于无法初始化的变量，会把变量名指向一个之前定义过的存储位置\nextern 修饰符通常用于当有两个或多个文件共享相同的全局变量或函数的时候\n\n","slug":"C存储类","date":"2022-07-10T08:12:03.000Z","categories_index":"C","tags_index":"C","author_index":"cBao"},{"id":"91073ca00ced3eaf093ce066e8170e85","title":"C数据类型","content":"C数据类型\n","slug":"C数据类型","date":"2022-07-09T07:51:09.000Z","categories_index":"C","tags_index":"C","author_index":"cBao"},{"id":"8b894e11fa6b8b7cfc1195c4546ad7f2","title":"C基本语法","content":"C中两种注释方法\n双斜杠”//“：适合单行注释\n//本行是注释代码\n/**/“：适合多行注释\n/*\n多行注释\n多行注释\n*/\n\n\n\n\n\n\n\n提示\n在Visual Studio中可用\n快捷键Ctrl + K + C快速注释\nCtrl + K + U快速取消注释\n\n分号 ;在C程序中分号”;“（英文输入法下）代表一条语句的结束\n标识符C语言中用来命名变量和函数名称等统称为标识符，C语言是区分大小写的\n\n\n\n\n\n\n\n注意\nC中标识符必须以字母 A-Z 或 a-z 或下划线 _ 开始，不能以数字作为开头，不允许出现标点字符，且不能与下表中关键字同名\n\n关键字\n\n\n关键字\n说明\n\n\n\nauto\n声明自动变量\n\n\nbreak\n跳出当前循环\n\n\ncase\n开关语句分支\n\n\nchar\n声明字符型变量或函数返回值类型\n\n\nconst\n定义常量，如果一个变量被 const 修饰，那么它的值就不能再被改变\n\n\ncontinue\n结束当前循环，开始下一轮循环\n\n\ndefault\n开关语句中的”其它”分支\n\n\ndo\n循环语句的循环体\n\n\ndouble\n声明双精度浮点型变量或函数返回值类型\n\n\nelse\n条件语句否定分支（与 if 连用）\n\n\nenum\n声明枚举类型\n\n\nextern\n声明变量或函数是在其它文件或本文件的其他位置定义\n\n\nfloat\n声明浮点型变量或函数返回值类型\n\n\nfor\n一种循环语句\n\n\ngoto\n无条件跳转语句\n\n\nif\n条件语句\n\n\nint\n声明整型变量或函数\n\n\nlong\n声明长整型变量或函数返回值类型\n\n\nregister\n声明寄存器变量\n\n\nreturn\n子程序返回语句（可以带参数，也可不带参数）\n\n\nshort\n声明短整型变量或函数\n\n\nsigned\n声明有符号类型变量或函数\n\n\nsizeof\n计算数据类型或变量长度（即所占字节数）\n\n\nstatic\n声明静态变量\n\n\nstruct\n声明结构体类型\n\n\nswitch\n用于开关语句\n\n\ntypedef\n用以给数据类型取别名\n\n\nunsigned\n声明无符号类型变量或函数\n\n\nunion\n声明共用体类型\n\n\nvoid\n声明函数无返回值或无参数，声明无类型指针\n\n\nvolatile\n说明变量在程序执行中可被隐含地改变\n\n\nwhile\n循环语句的循环条件\n\n\n\n\n\n\n\n\n\n特别注意\n关键字不能作为常量名、变量名或其他标识符名称\n\n\n\n","slug":"C基本语法","date":"2022-07-08T15:10:17.000Z","categories_index":"C","tags_index":"C","author_index":"cBao"},{"id":"f58daaa95359f10d1d47b72330587f5d","title":"VisualStudio常用操作","content":"Visual Studio中常用的快捷键\n\n\n快捷键\n功能\n\n\n\nCtrl + K, O\n在头文件与源文件之间切换\n\n\nCtrl + K, C\n注释选择行\n\n\nCtrl + K, U\n取消选择行的注释\n\n\nCtrl + K, D\n对齐所有代码\n\n\nCtrl+Shift+U\n全部变为大写\n\n\nCtrl+U\n全部变为小写\n\n\nAlt+鼠标左按钮\n选择矩形文本\n\n\nCtrl+F\n在当前文件中查找\n\n\nCtrl+Shift+F\n在当前的解决方案中查找\n\n\n","slug":"Visual Studio常用操作","date":"2022-07-07T03:18:50.000Z","categories_index":"IDE","tags_index":"Visual Studio","author_index":"cBao"}]