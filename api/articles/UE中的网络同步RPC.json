{"title":"UE中的网络同步RPC","uid":"321e20a64de3485e0958a3f7db00142f","slug":"UE中的网络同步RPC","date":"2022-08-15T07:32:03.000Z","updated":"2022-08-17T15:26:40.262Z","comments":true,"path":"api/articles/UE中的网络同步RPC.json","keywords":null,"cover":"https://cbaoblog.oss-cn-shanghai.aliyuncs.com/UE5LOGO.png","content":"<h1 id=\"UE网络中的服务器在哪！\"><a href=\"#UE网络中的服务器在哪！\" class=\"headerlink\" title=\"UE网络中的服务器在哪！\"></a>UE网络中的服务器在哪！</h1><ul>\n<li>在UE中存在<strong>服务器和客户端重合</strong>，创建房间的客户端同时具备服务器特性</li>\n</ul>\n<h1 id=\"UE中服务器和客户端中对象的关系\"><a href=\"#UE中服务器和客户端中对象的关系\" class=\"headerlink\" title=\"UE中服务器和客户端中对象的关系\"></a>UE中服务器和客户端中对象的关系</h1><ul>\n<li>在服务器端，所有的角色（Actor）都是<strong>Authority（权威的）</strong></li>\n<li>在客户端眼，除了自己控制的角色外，其他的所有角色都是<strong>Simulated proxy（模拟代理）</strong></li>\n<li>在UE网络框架中，Actor是促成网络同步的重要对象</li>\n</ul>\n<h1 id=\"Actor的更新方式\"><a href=\"#Actor的更新方式\" class=\"headerlink\" title=\"Actor的更新方式\"></a>Actor的更新方式</h1><ul>\n<li>属性更新（针对成员变量）具有及时性，随属性变换而进行通知。属性更新不变化不消耗带宽，但会消耗CPU进行监听</li>\n<li>RPC（针对函数），由用户进行调用</li>\n</ul>\n<h1 id=\"UE网络框架对象归属分类\"><a href=\"#UE网络框架对象归属分类\" class=\"headerlink\" title=\"UE网络框架对象归属分类\"></a>UE网络框架对象归属分类</h1><table>\n<thead>\n<tr>\n<th align=\"center\">Server Only（仅存在于服务器上）</th>\n<th align=\"center\">Server &amp; Clients（存在于服务器和所有客户端）</th>\n<th align=\"center\">Server &amp; Owning Client（仅存在于服务器和自身客户端）</th>\n<th align=\"center\">Owning Client Only（仅存在于自己客户端）</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"center\">AGameMode</td>\n<td align=\"center\">AGameState</td>\n<td align=\"center\">APlayerController</td>\n<td align=\"center\">AHUD</td>\n</tr>\n<tr>\n<td align=\"center\"></td>\n<td align=\"center\">APlayerState</td>\n<td align=\"center\"></td>\n<td align=\"center\">UMG Widget</td>\n</tr>\n<tr>\n<td align=\"center\"></td>\n<td align=\"center\">APawn</td>\n<td align=\"center\"></td>\n<td align=\"center\"></td>\n</tr>\n</tbody></table>\n<h1 id=\"角色类型标记\"><a href=\"#角色类型标记\" class=\"headerlink\" title=\"角色类型标记\"></a>角色类型标记</h1><ul>\n<li>每个Actor中都存在两个属性用来裁定当前Actor在服务器/客户端上的身份类型，分为Role和RemoteRole</li>\n<li>在蓝图中为LocalRole和RemoteRole<br><img src=\"https://cbaoblog.oss-cn-shanghai.aliyuncs.com/img/image-20220816222013678.png\" alt=\"image-20220816222013678\"></li>\n<li>Get Local Role：判断当前角色在本地端身份类型</li>\n<li>Get Remote Role：判断当前角色在远端身份类型（当是客户端时，远端为服务端，当是服务端时，远端是客户端）</li>\n</ul>\n<h1 id=\"网络角色三种类型\"><a href=\"#网络角色三种类型\" class=\"headerlink\" title=\"网络角色三种类型\"></a>网络角色三种类型</h1><ul>\n<li>Simulated：由服务器进行数据发送，当前终端进行操控模拟。操控来源于服务器，<strong>Simulate对象无法执行RPC函数</strong></li>\n<li>Autonomous：由当前终端实例进行操控。操控来源于真人</li>\n<li>Authority：服务器端存在标记，表明当前Actor存在于服务器</li>\n</ul>\n<h1 id=\"RPC\"><a href=\"#RPC\" class=\"headerlink\" title=\"RPC\"></a>RPC</h1><p>远端调用，在本机上调用函数，但在其他机器上远程执行的函数。</p>\n<h1 id=\"RPC执行的三种形式\"><a href=\"#RPC执行的三种形式\" class=\"headerlink\" title=\"RPC执行的三种形式\"></a>RPC执行的三种形式</h1><ul>\n<li>服务端执行（Server） ：由客户端调用，在服务器端执行</li>\n<li>客户端执行（Client）： 由服务器端调用，在客户端执行</li>\n<li>所有终端执行（Multicast）  ：由服务器端调用，在所有终端执行</li>\n</ul>\n<h1 id=\"RPC调用注意事项\"><a href=\"#RPC调用注意事项\" class=\"headerlink\" title=\"RPC调用注意事项\"></a>RPC调用注意事项</h1><ul>\n<li><p><strong>必须</strong>从 <strong>Actor</strong> 上调用</p>\n</li>\n<li><p>Actor 必须能被复制（Replicates=true）</p>\n</li>\n<li><p>如果 RPC 是从服务器调用并在客户端上执行，则只有实际拥有这个 Actor 的客户端才会执行函数</p>\n</li>\n<li><p>如果 RPC 是从客户端调用并在服务器上执行，客户端就必须拥有调用 RPC 的 Actor。</p>\n</li>\n<li><p>从服务器上调用RPC</p>\n<table>\n<thead>\n<tr>\n<th align=\"center\">Actor所有权</th>\n<th align=\"center\">未复制</th>\n<th align=\"center\">NetMulticast</th>\n<th align=\"center\">Server</th>\n<th align=\"center\">Client</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"center\">Client-Owned Actor</td>\n<td align=\"center\">在服务器上运行</td>\n<td align=\"center\">在服务器和所有客户端上运行</td>\n<td align=\"center\">在服务器上运行</td>\n<td align=\"center\">在 actor  的所属客户端上运行</td>\n</tr>\n<tr>\n<td align=\"center\">Server-owned actor</td>\n<td align=\"center\">在服务器上运行</td>\n<td align=\"center\">在服务器和所有客户端上运行</td>\n<td align=\"center\">在服务器上运行</td>\n<td align=\"center\">在服务器上运行</td>\n</tr>\n<tr>\n<td align=\"center\">Unowned actor</td>\n<td align=\"center\">在服务器上运行</td>\n<td align=\"center\">在服务器和所有客户端上运行</td>\n<td align=\"center\">在服务器上运行</td>\n<td align=\"center\">在服务器上运行</td>\n</tr>\n</tbody></table>\n</li>\n<li><p>从客户端上调用RPC</p>\n<table>\n<thead>\n<tr>\n<th align=\"center\">Actor所有权</th>\n<th align=\"center\">未复制</th>\n<th align=\"center\">NetMulticast</th>\n<th align=\"center\">Server</th>\n<th align=\"center\">Client</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"center\">Owned by invoking client（当前终端所有权）</td>\n<td align=\"center\">在执行调用的客户端上运行</td>\n<td align=\"center\">在执行调用的客户端上运行</td>\n<td align=\"center\">在服务器上运行</td>\n<td align=\"center\">在执行调用的客户端上运行</td>\n</tr>\n<tr>\n<td align=\"center\">Owned by a different client  （其他终端所有权）</td>\n<td align=\"center\">在执行调用的客户端上运行</td>\n<td align=\"center\">在执行调用的客户端上运行</td>\n<td align=\"center\">丢弃</td>\n<td align=\"center\">在执行调用的客户端上运行</td>\n</tr>\n<tr>\n<td align=\"center\">Server-owned actor</td>\n<td align=\"center\">在执行调用的客户端上运行</td>\n<td align=\"center\">在执行调用的客户端上运行</td>\n<td align=\"center\">丢弃</td>\n<td align=\"center\">在执行调用的客户端上运行</td>\n</tr>\n<tr>\n<td align=\"center\">Unowned actor</td>\n<td align=\"center\">在执行调用的客户端上运行</td>\n<td align=\"center\">在执行调用的客户端上运行</td>\n<td align=\"center\">丢弃</td>\n<td align=\"center\">在执行调用的客户端上运行</td>\n</tr>\n</tbody></table>\n</li>\n</ul>\n<h1 id=\"蓝图中判断服务器和客户端\"><a href=\"#蓝图中判断服务器和客户端\" class=\"headerlink\" title=\"蓝图中判断服务器和客户端\"></a>蓝图中判断服务器和客户端</h1><p><img src=\"https://cbaoblog.oss-cn-shanghai.aliyuncs.com/img/image-20220815155506487.png\" alt=\"image-20220815155506487\"></p>\n<ul>\n<li>Authority：服务器</li>\n<li>Remote：客户端</li>\n</ul>\n<h1 id=\"RPC执行的三种形式-1\"><a href=\"#RPC执行的三种形式-1\" class=\"headerlink\" title=\"RPC执行的三种形式\"></a>RPC执行的三种形式</h1><ul>\n<li>服务端执行（Server）：在客户端调用，在服务端执行</li>\n<li>客户端执行（Client）:在服务端调用，在客户端执行</li>\n<li>所有终端执行（Multicast）：只能在服务端调用，在所有终端执行</li>\n</ul>\n<h1 id=\"设置Actor所有权\"><a href=\"#设置Actor所有权\" class=\"headerlink\" title=\"设置Actor所有权\"></a>设置Actor所有权</h1><ul>\n<li>蓝图中使用Set Owner节点在<strong>服务器</strong>上获得Actor所有权</li>\n</ul>\n<p><img src=\"https://cbaoblog.oss-cn-shanghai.aliyuncs.com/img/image-20220817220137547.png\" alt=\"image-20220817220137547\"></p>\n<p><img src=\"https://cbaoblog.oss-cn-shanghai.aliyuncs.com/img/image-20220817220516531.png\" alt=\"image-20220817220516531\"></p>\n<h1 id=\"数据同步\"><a href=\"#数据同步\" class=\"headerlink\" title=\"数据同步\"></a>数据同步</h1><ul>\n<li>Actor必须满足在网络上<strong>被复制</strong>,设置的<strong>参数</strong>需要<strong>开启复制</strong></li>\n<li>参数的修正<strong>必须在服务器端</strong>修改,才可以在网络上同步</li>\n<li>蓝图参数同步的两种方式：<ul>\n<li>Replicated，同步数据，但没有通知，无法直接通过参数修改驱动逻辑</li>\n<li>•RepNotify，同步数据，并生成通知函数，进行更新通知（向所有终端通知，满足相关性）</li>\n</ul>\n</li>\n</ul>\n","feature":true,"text":"UE网络中的服务器在哪！ 在UE中存在服务器和客户端重合，创建房间的客户端同时具备服务器特性 UE中服务器和客户端中对象的关系 在服务器端，所有的角色（Actor）都是Authority（权威的） 在客户端眼，除了自己控制的角色外，其他的所有角色都是Simulated proxy...","link":"","photos":[],"count_time":{"symbolsCount":"2k","symbolsTime":"2 mins."},"categories":[{"name":"UnrealEngine","slug":"UnrealEngine","count":4,"path":"api/categories/UnrealEngine.json"}],"tags":[{"name":"网络同步RPC","slug":"网络同步RPC","count":1,"path":"api/tags/网络同步RPC.json"}],"toc":"<ol class=\"toc\"><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#UE%E7%BD%91%E7%BB%9C%E4%B8%AD%E7%9A%84%E6%9C%8D%E5%8A%A1%E5%99%A8%E5%9C%A8%E5%93%AA%EF%BC%81\"><span class=\"toc-text\">UE网络中的服务器在哪！</span></a></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#UE%E4%B8%AD%E6%9C%8D%E5%8A%A1%E5%99%A8%E5%92%8C%E5%AE%A2%E6%88%B7%E7%AB%AF%E4%B8%AD%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%85%B3%E7%B3%BB\"><span class=\"toc-text\">UE中服务器和客户端中对象的关系</span></a></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#Actor%E7%9A%84%E6%9B%B4%E6%96%B0%E6%96%B9%E5%BC%8F\"><span class=\"toc-text\">Actor的更新方式</span></a></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#UE%E7%BD%91%E7%BB%9C%E6%A1%86%E6%9E%B6%E5%AF%B9%E8%B1%A1%E5%BD%92%E5%B1%9E%E5%88%86%E7%B1%BB\"><span class=\"toc-text\">UE网络框架对象归属分类</span></a></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#%E8%A7%92%E8%89%B2%E7%B1%BB%E5%9E%8B%E6%A0%87%E8%AE%B0\"><span class=\"toc-text\">角色类型标记</span></a></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#%E7%BD%91%E7%BB%9C%E8%A7%92%E8%89%B2%E4%B8%89%E7%A7%8D%E7%B1%BB%E5%9E%8B\"><span class=\"toc-text\">网络角色三种类型</span></a></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#RPC\"><span class=\"toc-text\">RPC</span></a></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#RPC%E6%89%A7%E8%A1%8C%E7%9A%84%E4%B8%89%E7%A7%8D%E5%BD%A2%E5%BC%8F\"><span class=\"toc-text\">RPC执行的三种形式</span></a></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#RPC%E8%B0%83%E7%94%A8%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9\"><span class=\"toc-text\">RPC调用注意事项</span></a></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#%E8%93%9D%E5%9B%BE%E4%B8%AD%E5%88%A4%E6%96%AD%E6%9C%8D%E5%8A%A1%E5%99%A8%E5%92%8C%E5%AE%A2%E6%88%B7%E7%AB%AF\"><span class=\"toc-text\">蓝图中判断服务器和客户端</span></a></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#RPC%E6%89%A7%E8%A1%8C%E7%9A%84%E4%B8%89%E7%A7%8D%E5%BD%A2%E5%BC%8F-1\"><span class=\"toc-text\">RPC执行的三种形式</span></a></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#%E8%AE%BE%E7%BD%AEActor%E6%89%80%E6%9C%89%E6%9D%83\"><span class=\"toc-text\">设置Actor所有权</span></a></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#%E6%95%B0%E6%8D%AE%E5%90%8C%E6%AD%A5\"><span class=\"toc-text\">数据同步</span></a></li></ol>","author":{"name":"cBao","slug":"blog-author","avatar":"https://cbaoblog.oss-cn-shanghai.aliyuncs.com/HeadPortrait.jpg","link":"/","description":"但求日积月累，收获于细微。<br /><b>虚幻引擎开发</b>","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}},"mapped":true,"prev_post":{"title":"C#图解教程第5版","uid":"666eeba740dffa28e952c25ed8f5ff46","slug":"CSharp图解教程第5版","date":"2023-03-12T05:00:17.000Z","updated":"2023-04-19T15:13:21.325Z","comments":true,"path":"api/articles/CSharp图解教程第5版.json","keywords":null,"cover":"https://cbaoblog.oss-cn-shanghai.aliyuncs.com/CSharp.png","text":"C#中的命名约定 风格名称 描述 推荐使用 示例 Pascal大小写 标识符每个单词首字母大写 用于类型名称和类中对外可见成员的名称（类，方法，命名空间，属性和公有字段） CardDeck Camel大小写 标识符每个单词首字母大写，第一个单词除外 用于局部变量的名称和方法声明的...","link":"","photos":[],"count_time":{"symbolsCount":"44k","symbolsTime":"40 mins."},"categories":[{"name":"C#","slug":"C","count":1,"path":"api/categories/C.json"}],"tags":[{"name":"C#","slug":"C","count":1,"path":"api/tags/C.json"}],"author":{"name":"cBao","slug":"blog-author","avatar":"https://cbaoblog.oss-cn-shanghai.aliyuncs.com/HeadPortrait.jpg","link":"/","description":"但求日积月累，收获于细微。<br /><b>虚幻引擎开发</b>","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}},"feature":true},"next_post":{"title":"UE中的文件API","uid":"fa2dad943cb3925ed47cb72cd3308d02","slug":"UE中的文件操作","date":"2022-08-05T05:58:47.000Z","updated":"2022-08-05T06:12:21.008Z","comments":true,"path":"api/articles/UE中的文件操作.json","keywords":null,"cover":"https://cbaoblog.oss-cn-shanghai.aliyuncs.com/UE5LOGO.png","text":"检查文件夹是否存在//文件路径 FString Dir=FPaths::ProjectDir()/TEXT(\"cBao\"); //检查文件是否存在 IFileManager::Get().DirectoryExists(*Dir) 创建文件夹IFileManager::Get()...","link":"","photos":[],"count_time":{"symbolsCount":"2.2k","symbolsTime":"2 mins."},"categories":[{"name":"UnrealEngine","slug":"UnrealEngine","count":4,"path":"api/categories/UnrealEngine.json"}],"tags":[{"name":"文件操作","slug":"文件操作","count":1,"path":"api/tags/文件操作.json"}],"author":{"name":"cBao","slug":"blog-author","avatar":"https://cbaoblog.oss-cn-shanghai.aliyuncs.com/HeadPortrait.jpg","link":"/","description":"但求日积月累，收获于细微。<br /><b>虚幻引擎开发</b>","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}},"feature":true}}