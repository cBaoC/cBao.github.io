{"title":"UEC++基础","uid":"74d1a6628a5df30cefe103fae4a073dc","slug":"UEC++基础","date":"2023-02-02T06:19:47.000Z","updated":"2023-02-06T10:05:55.868Z","comments":true,"path":"api/articles/UEC++基础.json","keywords":null,"cover":"https://cbaoblog.oss-cn-shanghai.aliyuncs.com/UE5LOGO.png","content":"<h1 id=\"五个最常见的基类\"><a href=\"#五个最常见的基类\" class=\"headerlink\" title=\"五个最常见的基类\"></a>五个最常见的基类</h1><h2 id=\"UObject\"><a href=\"#UObject\" class=\"headerlink\" title=\"UObject\"></a>UObject</h2><h3 id=\"UObject类提供的功能\"><a href=\"#UObject类提供的功能\" class=\"headerlink\" title=\"UObject类提供的功能\"></a>UObject类提供的功能</h3><ol>\n<li>Garbage collection 垃圾回收(GC)<ul>\n<li>原生C++中的内存管理由程序员完成</li>\n<li>虚幻引擎提供两种垃圾回收的解决方案<ul>\n<li>继承自UObject类，同时指向UObject类实例对象的指针成员变量用 <strong>UPROPERTY宏进行标记</strong> ，虚幻会自动地进行对象的生命周期管理</li>\n<li>采用智能指针：只有 <strong>非UObject类型</strong> ，才能使用智能指针进行自动内存释放</li>\n</ul>\n</li>\n</ul>\n</li>\n<li>Reference updating 引用自动更新</li>\n<li>Reflection 反射<ul>\n<li>反射是一套可以在 <strong>运行时获取</strong> 一个类的成员变量和成员函数的一种机制</li>\n</ul>\n</li>\n<li>Serialization序列化<ul>\n<li>将对象保存到磁盘，下次运行时完好无损的加载</li>\n</ul>\n</li>\n<li>Automatic updating of default property changes 自动检测默认变量的更改</li>\n<li>Automatic property initialzation 自动变量初始化</li>\n<li>Automatic editor integration 和虚幻引擎编辑器的自动交互<ul>\n<li>将变量暴露到虚幻引擎的Edit面板进行编辑</li>\n</ul>\n</li>\n<li>Type information available at runtime 运行时类型识别</li>\n<li>Network replication 网络复制</li>\n</ol>\n<div class=\"custom-quote warning\">\n<span class=\"custom-quote-svg\"><svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"\" xmlns=\"http://www.w3.org/2000/svg\" data-reactroot=\"\">\n<path fill=\"\" d=\"M20.86 14.13C20 14.7 19.56 15.74 19.77 16.76C20.13 18.55 18.55 20.13 16.76 19.77C15.74 19.57 14.7 20 14.13 20.86C13.12 22.38 10.89 22.38 9.88 20.86C9.3 20 8.26 19.56 7.24 19.77C5.45 20.13 3.87 18.55 4.23 16.76C4.43 15.74 4 14.7 3.14 14.13C1.62 13.12 1.62 10.89 3.14 9.88C4 9.3 4.44 8.26 4.23 7.24C3.87 5.45 5.45 3.87 7.24 4.23C8.26 4.44 9.3 4 9.87 3.14C10.88 1.62 13.11 1.62 14.12 3.14C14.7 4 15.74 4.44 16.76 4.23C18.55 3.87 20.13 5.45 19.77 7.24C19.56 8.26 20 9.3 20.86 9.87C22.38 10.88 22.38 13.12 20.86 14.13Z\" undefined=\"1\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M12 8V13\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M12 15.99V16.01\"></path>\n</svg>\n</span>\n<p class=\"custom-quote-title\">注意</p>\n<ul>\n<li>当需要上述这些功能时，类该继承自UObject类</li>\n<li>UObject类会在引擎加载阶段，创建一个Default Object默认对象<ul>\n<li>构造函数并不是在游戏运行时候调用，即便只有一个UObject对象，构造函数也会被 <strong>调用两次</strong></li>\n<li>构造函数调用时UWorld不一定存在。 <strong>GetWorld()返回值可能为空</strong></li>\n</ul>\n</li>\n</ul>\n\n</div>\n<h2 id=\"Actor\"><a href=\"#Actor\" class=\"headerlink\" title=\"Actor\"></a>Actor</h2><h3 id=\"Actor类的能力\"><a href=\"#Actor类的能力\" class=\"headerlink\" title=\"Actor类的能力\"></a>Actor类的能力</h3><ul>\n<li>Actor类能被 <strong>挂载组件</strong></li>\n</ul>\n<div class=\"custom-quote warning\">\n<span class=\"custom-quote-svg\"><svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"\" xmlns=\"http://www.w3.org/2000/svg\" data-reactroot=\"\">\n<path fill=\"\" d=\"M20.86 14.13C20 14.7 19.56 15.74 19.77 16.76C20.13 18.55 18.55 20.13 16.76 19.77C15.74 19.57 14.7 20 14.13 20.86C13.12 22.38 10.89 22.38 9.88 20.86C9.3 20 8.26 19.56 7.24 19.77C5.45 20.13 3.87 18.55 4.23 16.76C4.43 15.74 4 14.7 3.14 14.13C1.62 13.12 1.62 10.89 3.14 9.88C4 9.3 4.44 8.26 4.23 7.24C3.87 5.45 5.45 3.87 7.24 4.23C8.26 4.44 9.3 4 9.87 3.14C10.88 1.62 13.11 1.62 14.12 3.14C14.7 4 15.74 4.44 16.76 4.23C18.55 3.87 20.13 5.45 19.77 7.24C19.56 8.26 20 9.3 20.86 9.87C22.38 10.88 22.38 13.12 20.86 14.13Z\" undefined=\"1\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M12 8V13\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M12 15.99V16.01\"></path>\n</svg>\n</span>\n<p class=\"custom-quote-title\">注意</p>\n<p><ul>\n<li>当需要挂载组件时，才继承自Actor类</li>\n</ul>\n</p>\n</div>\n<h1 id=\"灵魂与肉体-Pawn、Character和Controller\"><a href=\"#灵魂与肉体-Pawn、Character和Controller\" class=\"headerlink\" title=\"灵魂与肉体: Pawn、Character和Controller\"></a>灵魂与肉体: Pawn、Character和Controller</h1><h2 id=\"Pawn\"><a href=\"#Pawn\" class=\"headerlink\" title=\"Pawn\"></a>Pawn</h2><ul>\n<li>一个可以被Controller操作的兵或卒</li>\n</ul>\n<h2 id=\"Character\"><a href=\"#Character\" class=\"headerlink\" title=\"Character\"></a>Character</h2><ul>\n<li>继承自Pawn类，代表一个角色</li>\n<li>相比于Pawn类，Character类提供了一个特殊组件 <strong>Character Movement</strong> ，该组件提供了角色移动的功能</li>\n</ul>\n<h2 id=\"Controller\"><a href=\"#Controller\" class=\"headerlink\" title=\"Controller\"></a>Controller</h2><ul>\n<li>Controller操纵着Pawn和Character的行为（Pawn和Character是肉体，Controller是用来操控肉体的灵魂）</li>\n<li>Controller可以是 <strong>AI Controller</strong>  也可以是 <strong>Player Controller</strong></li>\n</ul>\n<h1 id=\"虚幻引擎类的命名规则\"><a href=\"#虚幻引擎类的命名规则\" class=\"headerlink\" title=\"虚幻引擎类的命名规则\"></a>虚幻引擎类的命名规则</h1><ul>\n<li>F 纯C++类</li>\n<li>U 继承自UObject，但不继承自Actor</li>\n<li>A 继承自Actor</li>\n<li>S Slate控件相关类</li>\n<li>H HItResult相关类</li>\n</ul>\n<h1 id=\"类对象\"><a href=\"#类对象\" class=\"headerlink\" title=\"类对象\"></a>类对象</h1><h2 id=\"类对象的产生\"><a href=\"#类对象的产生\" class=\"headerlink\" title=\"类对象的产生\"></a>类对象的产生</h2><ul>\n<li><p>如果类是一个纯C++类型(F开头)，通过new来产生对象</p>\n</li>\n<li><p>如果类继承自UObject但不继承自Actor，通过NewObject函数来产生对象</p>\n<pre class=\"line-numbers language-c++\" data-language=\"c++\"><code class=\"language-c++\">NewObject&lt;T&gt;();<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span></span></code></pre></li>\n<li><p>如果类继承自Actor，需要通过SpawnActor函数产生对象</p>\n<pre class=\"line-numbers language-c++\" data-language=\"c++\"><code class=\"language-c++\">GetWorld()-&gt;SpawnActor&lt;AYourActorCLass&gt;();<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span></span></code></pre></li>\n</ul>\n<h2 id=\"类对象的获取\"><a href=\"#类对象的获取\" class=\"headerlink\" title=\"类对象的获取\"></a>类对象的获取</h2><ul>\n<li><p>获取一个类对象的唯一方法，是通过某种方式传递到这个对象的指针或引用</p>\n</li>\n<li><p>如果要获取场景中，某个Actor的实例，需要借助Actor迭代器:TActorIterator</p>\n<pre class=\"line-numbers language-c++\" data-language=\"c++\"><code class=\"language-c++\">for(TActorIterator&lt;AActor&gt; Iterator(GetWorld());Iterator;++Iterator)\n&#123;\n    \t&#x2F;&#x2F;*Iterator获取指向对象的指针\n&#125;<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span></span></code></pre></li>\n</ul>\n<h2 id=\"类对象的销毁\"><a href=\"#类对象的销毁\" class=\"headerlink\" title=\"类对象的销毁\"></a>类对象的销毁</h2><h3 id=\"纯C-类\"><a href=\"#纯C-类\" class=\"headerlink\" title=\"纯C++类\"></a>纯C++类</h3><ul>\n<li><p>当纯C++类实在函数体中创建，并且不是通过new来进行分配内存，不需要手动干涉释放，会随着函数调用结束后，随着函数栈空间一起被释放</p>\n</li>\n<li><p>当纯C++类使用new来分配内存，除非手动删除(delete)，否则该内存永远不会被释放，产生内存泄漏</p>\n</li>\n<li><p>当纯C++类使用new来分配内存，同时使用智能指针TSharedPtr/TSharedRef来进行管理，不应该手动干涉释放，智能指针会自动完成内存的释放</p>\n<pre class=\"line-numbers language-c++\" data-language=\"c++\"><code class=\"language-c++\">TSharedPtr&lt;Test&gt; YourClassPtr&#x3D;MakeShareable(new YourClass());&#x2F;&#x2F;通过MakeShareable函数转化普通指针为智能指针<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span></span></code></pre></li>\n</ul>\n<h3 id=\"UObject类\"><a href=\"#UObject类\" class=\"headerlink\" title=\"UObject类\"></a>UObject类</h3><ul>\n<li>UObject类采用自动垃圾回收机制（当一个类的成员变量包含指向UObject的对象，同时又带有UPROPERTY宏定义，该成员变量将会触发引用计数机制）</li>\n</ul>\n<div class=\"custom-quote tip\">\n<span class=\"custom-quote-svg\"><svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"\" xmlns=\"http://www.w3.org/2000/svg\" data-reactroot=\"\">\n<path fill=\"\" d=\"M20.86 14.13C20 14.7 19.56 15.74 19.77 16.76C20.13 18.55 18.55 20.13 16.76 19.77C15.74 19.57 14.7 20 14.13 20.86C13.12 22.38 10.89 22.38 9.88 20.86C9.3 20 8.26 19.56 7.24 19.77C5.45 20.13 3.87 18.55 4.23 16.76C4.43 15.74 4 14.7 3.14 14.13C1.62 13.12 1.62 10.89 3.14 9.88C4 9.3 4.44 8.26 4.23 7.24C3.87 5.45 5.45 3.87 7.24 4.23C8.26 4.44 9.3 4 9.87 3.14C10.88 1.62 13.11 1.62 14.12 3.14C14.7 4 15.74 4.44 16.76 4.23C18.55 3.87 20.13 5.45 19.77 7.24C19.56 8.26 20 9.3 20.86 9.87C22.38 10.88 22.38 13.12 20.86 14.13Z\" undefined=\"1\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M12.01 15C12.01 14.5 12.01 14.5 12.01 14.5C12.04 13.75 13 13.46 14.04 12.2C14.41 11.74 14.69 11.41 14.86 10.85C15.15 9.95 14.92 9.18 14.86 9.02C14.8 8.79 14.52 8 13.72 7.46C13.06 7.02 12.42 7 12.14 7C11.9 7 11.36 7 10.78 7.3C10.28 7.56 9.98 7.9 9.83 8.1C9.24 8.82 9.06 9.63 9 10.06\"></path>\n<path stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M11.99 18H12.01\"></path>\n</svg></span>\n<p class=\"custom-quote-title\">提示</p>\n<p>        垃圾回收器会定期从根节点Root开始检查，当一个UObject没有被别的任何UObject引用，就会被垃圾回收</p>\n<p>​        可以通过AddToRoot函数来让一个UObject一直不被回收</p>\n</p>\n</div>\n<h3 id=\"Actor类\"><a href=\"#Actor类\" class=\"headerlink\" title=\"Actor类\"></a>Actor类</h3><ul>\n<li>Actor类对象通过Destory函数请求销毁，使用该方式销毁是将Actor从所属世界中摧毁，但对象的内存回收依然由系统决定</li>\n</ul>\n<h1 id=\"从C-到蓝图\"><a href=\"#从C-到蓝图\" class=\"headerlink\" title=\"从C++到蓝图\"></a>从C++到蓝图</h1><h2 id=\"UPROPERTY宏\"><a href=\"#UPROPERTY宏\" class=\"headerlink\" title=\"UPROPERTY宏\"></a>UPROPERTY宏</h2><ul>\n<li><p>可以将一个 <strong>UObject类的子类</strong> 成员变量注册到蓝图中</p>\n<pre class=\"line-numbers language-c++\" data-language=\"c++\"><code class=\"language-c++\">UPROPERTY(BlueprintReadWrite,VisibleAnywhere,Category&#x3D;&quot;YourName&quot;)<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span></span></code></pre></li>\n</ul>\n<h2 id=\"UFUNCTION宏\"><a href=\"#UFUNCTION宏\" class=\"headerlink\" title=\"UFUNCTION宏\"></a>UFUNCTION宏</h2><ul>\n<li><p>可以将函数注册到蓝图中</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">UFUNCTION(BlueprintCallable,Category&#x3D;&quot;YourName&quot;)<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span></span></code></pre>\n\n<ul>\n<li>BlueprintCallable：表示函数可以被蓝图调用</li>\n<li>BlueprintImplementableEvent：该成员函数由蓝图的子类实现，不应在C++中实现（编译错误）</li>\n<li>BlueprintNativeEvent：该成员函数提供一个C++的默认实现，同时也可以被蓝图重载，再C++中需要提供一个“函数名_Implement”为名字的函数实现</li>\n</ul>\n</li>\n</ul>\n<h1 id=\"引擎系统相关类\"><a href=\"#引擎系统相关类\" class=\"headerlink\" title=\"引擎系统相关类\"></a>引擎系统相关类</h1><h2 id=\"FPaths类\"><a href=\"#FPaths类\" class=\"headerlink\" title=\"FPaths类\"></a>FPaths类</h2><ul>\n<li>该类是用于处理路径相关的类</li>\n<li>具体路径类：如获取游戏根目录</li>\n<li>工具类：如判断一个文件是否存在</li>\n<li>路径转换类：如将相对路径转换为绝对路径</li>\n</ul>\n<h2 id=\"Config类的使用\"><a href=\"#Config类的使用\" class=\"headerlink\" title=\"Config类的使用\"></a>Config类的使用</h2><ul>\n<li><p>写配置</p>\n<pre class=\"line-numbers language-c++\" data-language=\"c++\"><code class=\"language-c++\">GConfig.SetString((TEXT(&quot;MySection&quot;),TEXT(&quot;Name&quot;),TEXT(&quot;cBao&quot;),FPath::GameDir&#x2F;&quot;MyConfig.ini&quot;));<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span></span></code></pre>\n\n<ul>\n<li>第一个参数指定Section（区块）</li>\n<li>第二个参数配置Key</li>\n<li>第三个参数配置具体的值</li>\n<li>第四个参数是路径，没有会自动创建</li>\n</ul>\n</li>\n</ul>\n<div class=\"custom-quote tip\">\n<span class=\"custom-quote-svg\"><svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"\" xmlns=\"http://www.w3.org/2000/svg\" data-reactroot=\"\">\n<path fill=\"\" d=\"M20.86 14.13C20 14.7 19.56 15.74 19.77 16.76C20.13 18.55 18.55 20.13 16.76 19.77C15.74 19.57 14.7 20 14.13 20.86C13.12 22.38 10.89 22.38 9.88 20.86C9.3 20 8.26 19.56 7.24 19.77C5.45 20.13 3.87 18.55 4.23 16.76C4.43 15.74 4 14.7 3.14 14.13C1.62 13.12 1.62 10.89 3.14 9.88C4 9.3 4.44 8.26 4.23 7.24C3.87 5.45 5.45 3.87 7.24 4.23C8.26 4.44 9.3 4 9.87 3.14C10.88 1.62 13.11 1.62 14.12 3.14C14.7 4 15.74 4.44 16.76 4.23C18.55 3.87 20.13 5.45 19.77 7.24C19.56 8.26 20 9.3 20.86 9.87C22.38 10.88 22.38 13.12 20.86 14.13Z\" undefined=\"1\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M12.01 15C12.01 14.5 12.01 14.5 12.01 14.5C12.04 13.75 13 13.46 14.04 12.2C14.41 11.74 14.69 11.41 14.86 10.85C15.15 9.95 14.92 9.18 14.86 9.02C14.8 8.79 14.52 8 13.72 7.46C13.06 7.02 12.42 7 12.14 7C11.9 7 11.36 7 10.78 7.3C10.28 7.56 9.98 7.9 9.83 8.1C9.24 8.82 9.06 9.63 9 10.06\"></path>\n<path stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M11.99 18H12.01\"></path>\n</svg></span>\n<p class=\"custom-quote-title\">提示</p>\n<p>​        GConfig对各种类型的数据都有相应的函数，如SetInt，SetBool，SetFloiat等</p>\n\n</div>\n<ul>\n<li><p>读配置</p>\n<pre class=\"line-numbers language-c++\" data-language=\"c++\"><code class=\"language-c++\">FString Result;\nGConfig-&gt;GetString(TEXT(&quot;cBao&quot;),TEXT(&quot;Name&quot;),Result,FPaths::ProjectConfigDir()&#x2F;&quot;cBaoCsConfig.ini&quot;);<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span></span></code></pre></li>\n</ul>\n","feature":true,"text":"五个最常见的基类UObjectUObject类提供的功能 Garbage collection 垃圾回收(GC) 原生C++中的内存管理由程序员完成 虚幻引擎提供两种垃圾回收的解决方案 继承自UObject类，同时指向UObject类实例对象的指针成员变量用 UPROPERTY宏...","link":"","photos":[],"count_time":{"symbolsCount":"3.1k","symbolsTime":"3 mins."},"categories":[{"name":"UnrealEngine","slug":"UnrealEngine","count":5,"path":"api/categories/UnrealEngine.json"}],"tags":[{"name":"UEC++","slug":"UEC","count":1,"path":"api/tags/UEC.json"}],"toc":"<ol class=\"toc\"><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#%E4%BA%94%E4%B8%AA%E6%9C%80%E5%B8%B8%E8%A7%81%E7%9A%84%E5%9F%BA%E7%B1%BB\"><span class=\"toc-text\">五个最常见的基类</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#UObject\"><span class=\"toc-text\">UObject</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#UObject%E7%B1%BB%E6%8F%90%E4%BE%9B%E7%9A%84%E5%8A%9F%E8%83%BD\"><span class=\"toc-text\">UObject类提供的功能</span></a></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#Actor\"><span class=\"toc-text\">Actor</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#Actor%E7%B1%BB%E7%9A%84%E8%83%BD%E5%8A%9B\"><span class=\"toc-text\">Actor类的能力</span></a></li></ol></li></ol></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#%E7%81%B5%E9%AD%82%E4%B8%8E%E8%82%89%E4%BD%93-Pawn%E3%80%81Character%E5%92%8CController\"><span class=\"toc-text\">灵魂与肉体: Pawn、Character和Controller</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#Pawn\"><span class=\"toc-text\">Pawn</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#Character\"><span class=\"toc-text\">Character</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#Controller\"><span class=\"toc-text\">Controller</span></a></li></ol></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#%E8%99%9A%E5%B9%BB%E5%BC%95%E6%93%8E%E7%B1%BB%E7%9A%84%E5%91%BD%E5%90%8D%E8%A7%84%E5%88%99\"><span class=\"toc-text\">虚幻引擎类的命名规则</span></a></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#%E7%B1%BB%E5%AF%B9%E8%B1%A1\"><span class=\"toc-text\">类对象</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E7%B1%BB%E5%AF%B9%E8%B1%A1%E7%9A%84%E4%BA%A7%E7%94%9F\"><span class=\"toc-text\">类对象的产生</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E7%B1%BB%E5%AF%B9%E8%B1%A1%E7%9A%84%E8%8E%B7%E5%8F%96\"><span class=\"toc-text\">类对象的获取</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E7%B1%BB%E5%AF%B9%E8%B1%A1%E7%9A%84%E9%94%80%E6%AF%81\"><span class=\"toc-text\">类对象的销毁</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E7%BA%AFC-%E7%B1%BB\"><span class=\"toc-text\">纯C++类</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#UObject%E7%B1%BB\"><span class=\"toc-text\">UObject类</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#Actor%E7%B1%BB\"><span class=\"toc-text\">Actor类</span></a></li></ol></li></ol></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#%E4%BB%8EC-%E5%88%B0%E8%93%9D%E5%9B%BE\"><span class=\"toc-text\">从C++到蓝图</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#UPROPERTY%E5%AE%8F\"><span class=\"toc-text\">UPROPERTY宏</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#UFUNCTION%E5%AE%8F\"><span class=\"toc-text\">UFUNCTION宏</span></a></li></ol></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#%E5%BC%95%E6%93%8E%E7%B3%BB%E7%BB%9F%E7%9B%B8%E5%85%B3%E7%B1%BB\"><span class=\"toc-text\">引擎系统相关类</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#FPaths%E7%B1%BB\"><span class=\"toc-text\">FPaths类</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#Config%E7%B1%BB%E7%9A%84%E4%BD%BF%E7%94%A8\"><span class=\"toc-text\">Config类的使用</span></a></li></ol></li></ol>","author":{"name":"cBao","slug":"blog-author","avatar":"https://cbaoblog.oss-cn-shanghai.aliyuncs.com/HeadPortrait.jpg","link":"/","description":"但求日积月累，收获于细微。<br /><b>虚幻引擎开发</b>","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}},"mapped":true,"prev_post":{"title":"C语言字符输入/输出","uid":"297e7259160304ea1919564f5d876933","slug":"C语言字符输入输出","date":"2023-03-04T08:23:17.000Z","updated":"2023-03-04T15:12:52.060Z","comments":true,"path":"api/articles/C语言字符输入输出.json","keywords":null,"cover":"https://cbaoblog.oss-cn-shanghai.aliyuncs.com/c.png","text":"单字符I/Ogetchar()和putchar() getchar()和putchar()每次只处理一个字符 #include &lt;iostream> int main() &#123; char c; while((c=getchar())!='#')//当遇到'#'时结束...","link":"","photos":[],"count_time":{"symbolsCount":922,"symbolsTime":"1 mins."},"categories":[{"name":"C","slug":"C","count":1,"path":"api/categories/C.json"}],"tags":[{"name":"C","slug":"C","count":1,"path":"api/tags/C.json"}],"author":{"name":"cBao","slug":"blog-author","avatar":"https://cbaoblog.oss-cn-shanghai.aliyuncs.com/HeadPortrait.jpg","link":"/","description":"但求日积月累，收获于细微。<br /><b>虚幻引擎开发</b>","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}},"feature":true},"next_post":{"title":"Unity3D引擎","uid":"2d7fcd3211374fac141da523879cb012","slug":"Unity3D引擎","date":"2022-09-22T15:48:50.000Z","updated":"2022-10-12T09:57:20.794Z","comments":true,"path":"api/articles/Unity3D引擎.json","keywords":null,"cover":"https://cbaoblog.oss-cn-shanghai.aliyuncs.com/UnityLogo.png","text":"场景中的对象 GameObject类对象是Unity引擎提供作为场景中所有对象的根本 Unity中脚本的基本规则 创建规则 不在VS中创建脚本 可以放在Assets文件夹下的任意位置（建议同一文件夹下） 类名和文件名必须一致，不然不能挂载（因为反射机制创建对象，会通过文件名去找T...","link":"","photos":[],"count_time":{"symbolsCount":"12k","symbolsTime":"11 mins."},"categories":[{"name":"Unity3D引擎","slug":"Unity3D引擎","count":1,"path":"api/categories/Unity3D引擎.json"}],"tags":[{"name":"Unity3D引擎","slug":"Unity3D引擎","count":1,"path":"api/tags/Unity3D引擎.json"}],"author":{"name":"cBao","slug":"blog-author","avatar":"https://cbaoblog.oss-cn-shanghai.aliyuncs.com/HeadPortrait.jpg","link":"/","description":"但求日积月累，收获于细微。<br /><b>虚幻引擎开发</b>","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}}}}