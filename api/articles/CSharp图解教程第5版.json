{"title":"C#图解教程第5版","uid":"666eeba740dffa28e952c25ed8f5ff46","slug":"CSharp图解教程第5版","date":"2023-03-12T05:00:17.000Z","updated":"2023-03-19T13:46:43.448Z","comments":true,"path":"api/articles/CSharp图解教程第5版.json","keywords":null,"cover":"https://cbaoblog.oss-cn-shanghai.aliyuncs.com/CSharp.png","content":"<h1 id=\"C-中的命名约定\"><a href=\"#C-中的命名约定\" class=\"headerlink\" title=\"C#中的命名约定\"></a>C#中的命名约定</h1><table>\n<thead>\n<tr>\n<th align=\"center\">风格名称</th>\n<th align=\"center\">描述</th>\n<th align=\"center\">推荐使用</th>\n<th align=\"center\">示例</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"center\">Pascal大小写</td>\n<td align=\"center\">标识符每个单词首字母大写</td>\n<td align=\"center\">用于类型名称和类中对外可见成员的名称（类，方法，命名空间，属性和公有字段）</td>\n<td align=\"center\">CardDeck</td>\n</tr>\n<tr>\n<td align=\"center\">Camel大小写</td>\n<td align=\"center\">标识符每个单词首字母大写，第一个单词除外</td>\n<td align=\"center\">用于局部变量的名称和方法声明的形参名称</td>\n<td align=\"center\">cardDeck</td>\n</tr>\n<tr>\n<td align=\"center\">下划线和Camel大小写</td>\n<td align=\"center\">以下划线开头的Camel大小写的标识符</td>\n<td align=\"center\">用于私有和受保护的字段</td>\n<td align=\"center\">_cardDeck</td>\n</tr>\n</tbody></table>\n<div class=\"custom-quote warning\">\n<span class=\"custom-quote-svg\"><svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"\" xmlns=\"http://www.w3.org/2000/svg\" data-reactroot=\"\">\n<path fill=\"\" d=\"M20.86 14.13C20 14.7 19.56 15.74 19.77 16.76C20.13 18.55 18.55 20.13 16.76 19.77C15.74 19.57 14.7 20 14.13 20.86C13.12 22.38 10.89 22.38 9.88 20.86C9.3 20 8.26 19.56 7.24 19.77C5.45 20.13 3.87 18.55 4.23 16.76C4.43 15.74 4 14.7 3.14 14.13C1.62 13.12 1.62 10.89 3.14 9.88C4 9.3 4.44 8.26 4.23 7.24C3.87 5.45 5.45 3.87 7.24 4.23C8.26 4.44 9.3 4 9.87 3.14C10.88 1.62 13.11 1.62 14.12 3.14C14.7 4 15.74 4.44 16.76 4.23C18.55 3.87 20.13 5.45 19.77 7.24C19.56 8.26 20 9.3 20.86 9.87C22.38 10.88 22.38 13.12 20.86 14.13Z\" undefined=\"1\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M12 8V13\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M12 15.99V16.01\"></path>\n</svg>\n</span>\n<p class=\"custom-quote-title\">注意</p>\n<ul>\n<li><p>标识符命名可以使用字母，数字，下划线</p>\n</li>\n<li><p>标识符只能以字母和下划线开头，不能以数字开头</p>\n</li>\n<li><p>@字符只能放在标识符首位，不推荐使用</p>\n</li>\n<li><p>不能将关键字用于标识符</p>\n</li>\n<li><p>C#区分大小写</p>\n<p><img src=\"https://cbaoblog.oss-cn-shanghai.aliyuncs.com/img/image-20230312131623748.png\" alt=\"image-20230312131623748\"></p>\n</li>\n</ul>\n\n</div>\n<h1 id=\"C-程序的起点：Main\"><a href=\"#C-程序的起点：Main\" class=\"headerlink\" title=\"C#程序的起点：Main\"></a>C#程序的起点：Main</h1><ul>\n<li><p>每个C#程序必须有一个类带有Main方法</p>\n</li>\n<li><p>每个C#程序的可执行点在Main的第一条指令</p>\n</li>\n<li><p>Main首字母必须大写</p>\n</li>\n<li><p>Main的最简单形式</p>\n<pre class=\"line-numbers language-c#\" data-language=\"c#\"><code class=\"language-c#\">static void Main()\n&#123;\n   &#x2F;&#x2F;更多语句\n&#125;<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span></span></code></pre></li>\n</ul>\n<h1 id=\"空白符\"><a href=\"#空白符\" class=\"headerlink\" title=\"空白符\"></a>空白符</h1><ul>\n<li>空格（Space）</li>\n<li>制表符（Tab）</li>\n<li>换行符</li>\n<li>回车符</li>\n</ul>\n<h1 id=\"块\"><a href=\"#块\" class=\"headerlink\" title=\"块\"></a>块</h1><ul>\n<li>语法上只需要一条语句，而你需要执行的动作无法用一条简单的语句表达的情况下，考虑使用块</li>\n<li>有些特定的程序结构只能使用块。在这些结构，不能用简单语句替代快</li>\n<li>块后面不跟分号</li>\n</ul>\n<h1 id=\"从程序中输出文本\"><a href=\"#从程序中输出文本\" class=\"headerlink\" title=\"从程序中输出文本\"></a>从程序中输出文本</h1><h2 id=\"Write\"><a href=\"#Write\" class=\"headerlink\" title=\"Write\"></a>Write</h2><ul>\n<li>Write是Console类的成员，将文本字符串发送到程序控制台窗口</li>\n<li>Write不会自动添加换行符</li>\n</ul>\n<pre class=\"line-numbers language-c#\" data-language=\"c#\"><code class=\"language-c#\">Console.Write(&quot;Hello&quot;);<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span></span></code></pre>\n\n<h2 id=\"WriteLine\"><a href=\"#WriteLine\" class=\"headerlink\" title=\"WriteLine\"></a>WriteLine</h2><ul>\n<li>WriteLine是Console类的成员，将文本字符串发送到程序控制台窗口</li>\n<li>WriteLine会自动在结尾添加一个换行符</li>\n</ul>\n<pre class=\"line-numbers language-c#\" data-language=\"c#\"><code class=\"language-c#\">Console.WriteLine(&quot;Hello,World&quot;);<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span></span></code></pre>\n\n<h2 id=\"格式字符串\"><a href=\"#格式字符串\" class=\"headerlink\" title=\"格式字符串\"></a>格式字符串</h2><ul>\n<li><p>Write和WriteLine语句的常规形式中可以有一个以上的参数，参数间用逗号分隔</p>\n</li>\n<li><p>第一个参数必须是字符串，称为格式字符串，包含替代标记</p>\n</li>\n<li><p>语法：Console.WriteLine(格式字符串(含替代标记),替换值0,替换值1,替换值2,……);</p>\n<pre class=\"line-numbers language-c#\" data-language=\"c#\"><code class=\"language-c#\">Console.WriteLine(&quot;Hell&#123;0&#125;,Wor&#123;1&#125;d&quot;, &#39;o&#39;, &#39;l&#39;);<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span></span></code></pre></li>\n</ul>\n<div class=\"custom-quote tip\">\n<span class=\"custom-quote-svg\"><svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"\" xmlns=\"http://www.w3.org/2000/svg\" data-reactroot=\"\">\n<path fill=\"\" d=\"M20.86 14.13C20 14.7 19.56 15.74 19.77 16.76C20.13 18.55 18.55 20.13 16.76 19.77C15.74 19.57 14.7 20 14.13 20.86C13.12 22.38 10.89 22.38 9.88 20.86C9.3 20 8.26 19.56 7.24 19.77C5.45 20.13 3.87 18.55 4.23 16.76C4.43 15.74 4 14.7 3.14 14.13C1.62 13.12 1.62 10.89 3.14 9.88C4 9.3 4.44 8.26 4.23 7.24C3.87 5.45 5.45 3.87 7.24 4.23C8.26 4.44 9.3 4 9.87 3.14C10.88 1.62 13.11 1.62 14.12 3.14C14.7 4 15.74 4.44 16.76 4.23C18.55 3.87 20.13 5.45 19.77 7.24C19.56 8.26 20 9.3 20.86 9.87C22.38 10.88 22.38 13.12 20.86 14.13Z\" undefined=\"1\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M12.01 15C12.01 14.5 12.01 14.5 12.01 14.5C12.04 13.75 13 13.46 14.04 12.2C14.41 11.74 14.69 11.41 14.86 10.85C15.15 9.95 14.92 9.18 14.86 9.02C14.8 8.79 14.52 8 13.72 7.46C13.06 7.02 12.42 7 12.14 7C11.9 7 11.36 7 10.78 7.3C10.28 7.56 9.98 7.9 9.83 8.1C9.24 8.82 9.06 9.63 9 10.06\"></path>\n<path stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M11.99 18H12.01\"></path>\n</svg></span>\n<p class=\"custom-quote-title\">提示</p>\n<p><p>​        C#6.0引入字符串插值，通过直接在替代标记内插入变量名实现，前提需要加上$符号    </p>\n<pre class=\"line-numbers language-c#\" data-language=\"c#\"><code class=\"language-c#\">int var1 &#x3D; 3;\nint var2 &#x3D; 4;\nConsole.WriteLine($&quot;&#123;var1&#125;+&#123;var2&#125;&#x3D;?&quot;);<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span></span></code></pre>\n\n</p>\n</div>\n<h2 id=\"多重标记和值\"><a href=\"#多重标记和值\" class=\"headerlink\" title=\"多重标记和值\"></a>多重标记和值</h2><ul>\n<li>在C#中可以使用任意数量的替代标记和任意数量的值，值可以以任何顺序使用</li>\n<li>值可以在格式字符串中替换任意次</li>\n<li>标记不能试图引用超出替换值列表长度以外位置的值，若引用超过长度以外的值，不会产生编译错误，但会产生运行时错误（异常）</li>\n</ul>\n<pre class=\"line-numbers language-c#\" data-language=\"c#\"><code class=\"language-c#\">Console.WriteLine(&quot;He&#123;0&#125;&#123;0&#125;o,Worl&#123;1&#125;&quot;,&#39;l&#39;,&#39;d&#39;);&#x2F;&#x2F;正确用法<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span></span></code></pre>\n\n<p><img src=\"https://cbaoblog.oss-cn-shanghai.aliyuncs.com/img/image-20230312184805411.png\" alt=\"image-20230312184805411\"></p>\n<h2 id=\"格式化数字字符串\"><a href=\"#格式化数字字符串\" class=\"headerlink\" title=\"格式化数字字符串\"></a>格式化数字字符串</h2><ul>\n<li>把值作为货币或者某个小数位数的定点值来显示</li>\n</ul>\n<pre class=\"line-numbers language-c#\" data-language=\"c#\"><code class=\"language-c#\">Console.WriteLine(&quot;The value:&#123;0:C&#125;&quot;, 500);<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span></span></code></pre>\n\n<p><img src=\"https://cbaoblog.oss-cn-shanghai.aliyuncs.com/img/image-20230312185544009.png\" alt=\"image-20230312185544009\"></p>\n<p><img src=\"https://cbaoblog.oss-cn-shanghai.aliyuncs.com/img/image-20230312190445081.png\" alt=\"image-20230312190445081\"></p>\n<h1 id=\"注释\"><a href=\"#注释\" class=\"headerlink\" title=\"注释\"></a>注释</h1><table>\n<thead>\n<tr>\n<th align=\"center\">类型</th>\n<th align=\"center\">开始</th>\n<th align=\"center\">结束</th>\n<th align=\"center\">描述</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"center\">单行注释</td>\n<td align=\"center\">//</td>\n<td align=\"center\"></td>\n<td align=\"center\">从开始标记到该行行尾的文本被编译器忽略</td>\n</tr>\n<tr>\n<td align=\"center\">带分隔符的注释</td>\n<td align=\"center\">/*</td>\n<td align=\"center\">*/</td>\n<td align=\"center\">从开始标记到结束标记之间的文本被编译器忽略</td>\n</tr>\n<tr>\n<td align=\"center\">文档注释</td>\n<td align=\"center\">///</td>\n<td align=\"center\"></td>\n<td align=\"center\">这种类型的注释包含XML文本，可以使用工具生成程序文档</td>\n</tr>\n</tbody></table>\n<h1 id=\"预定义类型\"><a href=\"#预定义类型\" class=\"headerlink\" title=\"预定义类型\"></a>预定义类型</h1><ul>\n<li>C#提供16中预定义类型</li>\n</ul>\n<p><img src=\"https://cbaoblog.oss-cn-shanghai.aliyuncs.com/img/image-20230312200102564.png\" alt=\"image-20230312200102564\"></p>\n<p><img src=\"https://cbaoblog.oss-cn-shanghai.aliyuncs.com/img/image-20230312200217648.png\" alt=\"image-20230312200217648\"></p>\n<p><img src=\"https://cbaoblog.oss-cn-shanghai.aliyuncs.com/img/image-20230312200254264.png\" alt=\"image-20230312200254264\"></p>\n<h1 id=\"用户定义类型\"><a href=\"#用户定义类型\" class=\"headerlink\" title=\"用户定义类型\"></a>用户定义类型</h1><h2 id=\"6种类型可以由用户自己创建\"><a href=\"#6种类型可以由用户自己创建\" class=\"headerlink\" title=\"6种类型可以由用户自己创建\"></a>6种类型可以由用户自己创建</h2><ul>\n<li>类类型（class）</li>\n<li>结构类型（struct）</li>\n<li>数组类型（array）</li>\n<li>枚举类型（enum）</li>\n<li>委托类型（delegate）</li>\n<li>接口类型（interface）</li>\n</ul>\n<h1 id=\"栈和堆\"><a href=\"#栈和堆\" class=\"headerlink\" title=\"栈和堆\"></a>栈和堆</h1><h2 id=\"栈\"><a href=\"#栈\" class=\"headerlink\" title=\"栈\"></a>栈</h2><ul>\n<li><p>栈是一个内存数组，是一个LIFO(后进先出的数据结构)</p>\n</li>\n<li><p>栈存储几种类型的数据</p>\n<ul>\n<li>某些类型变量的值</li>\n<li>程序当前的执行环境</li>\n<li>传递给方法的参数</li>\n</ul>\n</li>\n<li><p>栈的特征</p>\n<ul>\n<li>数据只能从栈的顶端插入和删除</li>\n<li>将数据放到栈顶称为入栈（push）</li>\n<li>从栈顶删除数据称为出栈（pop）</li>\n</ul>\n<p><img src=\"https://cbaoblog.oss-cn-shanghai.aliyuncs.com/img/image-20230312201747146.png\" alt=\"image-20230312201747146\"></p>\n</li>\n</ul>\n<div class=\"custom-quote tip\">\n<span class=\"custom-quote-svg\"><svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"\" xmlns=\"http://www.w3.org/2000/svg\" data-reactroot=\"\">\n<path fill=\"\" d=\"M20.86 14.13C20 14.7 19.56 15.74 19.77 16.76C20.13 18.55 18.55 20.13 16.76 19.77C15.74 19.57 14.7 20 14.13 20.86C13.12 22.38 10.89 22.38 9.88 20.86C9.3 20 8.26 19.56 7.24 19.77C5.45 20.13 3.87 18.55 4.23 16.76C4.43 15.74 4 14.7 3.14 14.13C1.62 13.12 1.62 10.89 3.14 9.88C4 9.3 4.44 8.26 4.23 7.24C3.87 5.45 5.45 3.87 7.24 4.23C8.26 4.44 9.3 4 9.87 3.14C10.88 1.62 13.11 1.62 14.12 3.14C14.7 4 15.74 4.44 16.76 4.23C18.55 3.87 20.13 5.45 19.77 7.24C19.56 8.26 20 9.3 20.86 9.87C22.38 10.88 22.38 13.12 20.86 14.13Z\" undefined=\"1\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M12.01 15C12.01 14.5 12.01 14.5 12.01 14.5C12.04 13.75 13 13.46 14.04 12.2C14.41 11.74 14.69 11.41 14.86 10.85C15.15 9.95 14.92 9.18 14.86 9.02C14.8 8.79 14.52 8 13.72 7.46C13.06 7.02 12.42 7 12.14 7C11.9 7 11.36 7 10.78 7.3C10.28 7.56 9.98 7.9 9.83 8.1C9.24 8.82 9.06 9.63 9 10.06\"></path>\n<path stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M11.99 18H12.01\"></path>\n</svg></span>\n<p class=\"custom-quote-title\">提示</p>\n<p>​        系统管理所有栈操作</p>\n\n</div>\n<h2 id=\"堆\"><a href=\"#堆\" class=\"headerlink\" title=\"堆\"></a>堆</h2><ul>\n<li>堆是一块内存区域，在堆里可以分配大块的内存用于存储某种类型的数据对象</li>\n<li>与栈不同，堆里的内存能够以任意顺序存入和移除</li>\n<li>在C#中GC会自动清除无主的堆对象（C++需要程序员自己释放内存）</li>\n<li>GC垃圾收集的过程</li>\n</ul>\n<p><img src=\"https://cbaoblog.oss-cn-shanghai.aliyuncs.com/img/image-20230312202244187.png\" alt=\"image-20230312202244187\"></p>\n<h1 id=\"值类型和引用类型\"><a href=\"#值类型和引用类型\" class=\"headerlink\" title=\"值类型和引用类型\"></a>值类型和引用类型</h1><p><img src=\"https://cbaoblog.oss-cn-shanghai.aliyuncs.com/img/image-20230312203527565.png\" alt=\"image-20230312203527565\"></p>\n<p><img src=\"https://cbaoblog.oss-cn-shanghai.aliyuncs.com/img/image-20230312203842553.png\" alt=\"image-20230312203842553\"></p>\n<p><img src=\"https://cbaoblog.oss-cn-shanghai.aliyuncs.com/img/image-20230312203928453.png\" alt=\"image-20230312203928453\"></p>\n<h1 id=\"类\"><a href=\"#类\" class=\"headerlink\" title=\"类\"></a>类</h1><h2 id=\"声明类\"><a href=\"#声明类\" class=\"headerlink\" title=\"声明类\"></a>声明类</h2><pre class=\"line-numbers language-c#\" data-language=\"c#\"><code class=\"language-c#\">class Player\n&#123;\n    &#x2F;&#x2F;...\n&#125;<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span></span></code></pre>\n\n<h2 id=\"类成员\"><a href=\"#类成员\" class=\"headerlink\" title=\"类成员\"></a>类成员</h2><ul>\n<li><p>字段和方法是最重要的类成员类型。字段是数据成员，方法是函数成员</p>\n<ul>\n<li><p>字段：隶属于类的变量</p>\n<div class=\"custom-quote warning\">\n<span class=\"custom-quote-svg\"><svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"\" xmlns=\"http://www.w3.org/2000/svg\" data-reactroot=\"\">\n<path fill=\"\" d=\"M20.86 14.13C20 14.7 19.56 15.74 19.77 16.76C20.13 18.55 18.55 20.13 16.76 19.77C15.74 19.57 14.7 20 14.13 20.86C13.12 22.38 10.89 22.38 9.88 20.86C9.3 20 8.26 19.56 7.24 19.77C5.45 20.13 3.87 18.55 4.23 16.76C4.43 15.74 4 14.7 3.14 14.13C1.62 13.12 1.62 10.89 3.14 9.88C4 9.3 4.44 8.26 4.23 7.24C3.87 5.45 5.45 3.87 7.24 4.23C8.26 4.44 9.3 4 9.87 3.14C10.88 1.62 13.11 1.62 14.12 3.14C14.7 4 15.74 4.44 16.76 4.23C18.55 3.87 20.13 5.45 19.77 7.24C19.56 8.26 20 9.3 20.86 9.87C22.38 10.88 22.38 13.12 20.86 14.13Z\" undefined=\"1\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M12 8V13\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M12 15.99V16.01\"></path>\n</svg>\n</span>\n<p class=\"custom-quote-title\">注意</p>\n<p><p>​        与C/C++不同，C#在类型外部不能声明全局变量（变量或字段）。所有字段都属于类型，必须在类型声明内部声明。</p>\n</p>\n</div>\n</li>\n<li><p>方法：相当于C++中的成员函数</p>\n<div class=\"custom-quote warning\">\n<span class=\"custom-quote-svg\"><svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"\" xmlns=\"http://www.w3.org/2000/svg\" data-reactroot=\"\">\n<path fill=\"\" d=\"M20.86 14.13C20 14.7 19.56 15.74 19.77 16.76C20.13 18.55 18.55 20.13 16.76 19.77C15.74 19.57 14.7 20 14.13 20.86C13.12 22.38 10.89 22.38 9.88 20.86C9.3 20 8.26 19.56 7.24 19.77C5.45 20.13 3.87 18.55 4.23 16.76C4.43 15.74 4 14.7 3.14 14.13C1.62 13.12 1.62 10.89 3.14 9.88C4 9.3 4.44 8.26 4.23 7.24C3.87 5.45 5.45 3.87 7.24 4.23C8.26 4.44 9.3 4 9.87 3.14C10.88 1.62 13.11 1.62 14.12 3.14C14.7 4 15.74 4.44 16.76 4.23C18.55 3.87 20.13 5.45 19.77 7.24C19.56 8.26 20 9.3 20.86 9.87C22.38 10.88 22.38 13.12 20.86 14.13Z\" undefined=\"1\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M12 8V13\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M12 15.99V16.01\"></path>\n</svg>\n</span>\n<p class=\"custom-quote-title\">注意</p>\n<p>​        与C/C++不同，C#中没有全局函数声明在类型声明的外部<br>​        C#中的所有方法必须包含返回类型或void</p>\n\n</div>\n</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"为数据分配内存\"><a href=\"#为数据分配内存\" class=\"headerlink\" title=\"为数据分配内存\"></a>为数据分配内存</h2><ul>\n<li><p>使用new运算符为实际数据分配内存</p>\n</li>\n<li><p>new运算符为任意指定类型的实例分配并初始化内存。依据类型的不同从栈或堆里分配</p>\n<pre class=\"line-numbers language-c#\" data-language=\"c#\"><code class=\"language-c#\">Player p1&#x3D;new Player();<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span></span></code></pre></li>\n</ul>\n<h2 id=\"访问修饰符\"><a href=\"#访问修饰符\" class=\"headerlink\" title=\"访问修饰符\"></a>访问修饰符</h2><ul>\n<li>语法<ul>\n<li>字段：访问修饰符 类型 标识符;</li>\n<li>方法：访问修饰符 返回类型 方法名() {…}</li>\n</ul>\n</li>\n<li>五种修饰符<ul>\n<li>私有的（private）<ul>\n<li>C#默认的访问级别是私有访问</li>\n<li>私有成员只能从声明它的类的内部访问，其它的类看不见且无法访问它们</li>\n</ul>\n</li>\n<li>公有的（public）</li>\n<li>受保护的（protected）</li>\n<li>内部的（internal）</li>\n<li>受保护内部的（protected internal）</li>\n</ul>\n</li>\n</ul>\n<h1 id=\"方法\"><a href=\"#方法\" class=\"headerlink\" title=\"方法\"></a>方法</h1><h2 id=\"方法的结构\"><a href=\"#方法的结构\" class=\"headerlink\" title=\"方法的结构\"></a>方法的结构</h2><h3 id=\"方法头\"><a href=\"#方法头\" class=\"headerlink\" title=\"方法头\"></a>方法头</h3><ul>\n<li>指示方法是否返回数据，如果返回，返回什么类型</li>\n<li>方法的名称</li>\n<li>接受的数据类型</li>\n</ul>\n<h3 id=\"方法体\"><a href=\"#方法体\" class=\"headerlink\" title=\"方法体\"></a>方法体</h3><ul>\n<li>包含可执行代码的语句序列，执行过程从方法体的第一条语句开始，一直到整个方法结束</li>\n</ul>\n<p><img src=\"https://cbaoblog.oss-cn-shanghai.aliyuncs.com/img/QQ%E6%88%AA%E5%9B%BE20230314195842.png\" alt=\"QQ截图20230314195842\"></p>\n<h2 id=\"方法体内部的代码执行\"><a href=\"#方法体内部的代码执行\" class=\"headerlink\" title=\"方法体内部的代码执行\"></a>方法体内部的代码执行</h2><ul>\n<li>局部变量</li>\n<li>控制流结构</li>\n<li>方法调用</li>\n<li>内嵌的块</li>\n<li>其它方法（局部函数，C#7.0开始）</li>\n</ul>\n<h2 id=\"局部变量\"><a href=\"#局部变量\" class=\"headerlink\" title=\"局部变量\"></a>局部变量</h2><ul>\n<li>局部变量的生命周期仅限于创建它的块及其内嵌的块<ul>\n<li>声明时开始存在</li>\n<li>在块完成时结束存在</li>\n</ul>\n</li>\n<li>可以在方法体内任意位置声明局部变量，但必须在使用它们前声明</li>\n<li>不会隐式初始化，使用之前未赋值，编译器会产生错误消息</li>\n<li>类型推断和var关键字<ul>\n<li>var关键字只能用于局部变量，不能用于字段（属于类的变量为字段）</li>\n<li>只能在局部变量声明中包含初始化时使用</li>\n<li>一旦编译器推断出变量的类型，它就是固定且不能更改的</li>\n<li>var关键字不改变C#的强类型性质</li>\n</ul>\n</li>\n<li>在C#中不管嵌套级别如何，都不能在第一个名称的有效范围内声明另一个同名的局部变量</li>\n</ul>\n<h2 id=\"控制流\"><a href=\"#控制流\" class=\"headerlink\" title=\"控制流\"></a>控制流</h2><h3 id=\"选择语句\"><a href=\"#选择语句\" class=\"headerlink\" title=\"选择语句\"></a>选择语句</h3><ul>\n<li>if</li>\n<li>if…else</li>\n<li>switch</li>\n</ul>\n<h3 id=\"迭代语句\"><a href=\"#迭代语句\" class=\"headerlink\" title=\"迭代语句\"></a>迭代语句</h3><ul>\n<li>for循环</li>\n<li>while循环</li>\n<li>do循环</li>\n<li>foreach（为一组中每个成员执行一次）</li>\n</ul>\n<h3 id=\"跳转语句\"><a href=\"#跳转语句\" class=\"headerlink\" title=\"跳转语句\"></a>跳转语句</h3><ul>\n<li>break：跳出当前循环</li>\n<li>continue：到当前循环的底部</li>\n<li>goto：到一个标签</li>\n<li>return：返回到调用方法继续执行</li>\n</ul>\n<h2 id=\"返回值\"><a href=\"#返回值\" class=\"headerlink\" title=\"返回值\"></a>返回值</h2><ul>\n<li>如果要返回值，方法必须在方法名前面声明一个返回类型</li>\n<li>如果方法不返回值，必须声明为void返回类型</li>\n</ul>\n<h2 id=\"参数\"><a href=\"#参数\" class=\"headerlink\" title=\"参数\"></a>参数</h2><h3 id=\"形参\"><a href=\"#形参\" class=\"headerlink\" title=\"形参\"></a>形参</h3><ul>\n<li>形参是局部变量，声明在方法的参数列表中</li>\n</ul>\n<h3 id=\"实参\"><a href=\"#实参\" class=\"headerlink\" title=\"实参\"></a>实参</h3><ul>\n<li>用于初始化形参的表达式或变量称作实参</li>\n</ul>\n<h2 id=\"值参数\"><a href=\"#值参数\" class=\"headerlink\" title=\"值参数\"></a>值参数</h2><ul>\n<li>在栈中为形参分配空间</li>\n<li>将实参的值复制给形参</li>\n<li>改变形参不会影响实参</li>\n</ul>\n<h2 id=\"引用参数\"><a href=\"#引用参数\" class=\"headerlink\" title=\"引用参数\"></a>引用参数</h2><ul>\n<li>使用引用参数时，必须在方法的声明和调用中都是用ref修饰符</li>\n<li>实参必须是变量，且必须被赋值</li>\n<li>形参会改变实参</li>\n</ul>\n<h2 id=\"引用类型作为值参数和引用参数\"><a href=\"#引用类型作为值参数和引用参数\" class=\"headerlink\" title=\"引用类型作为值参数和引用参数\"></a>引用类型作为值参数和引用参数</h2><ul>\n<li>将引用类型对象作为值参数传递：如果在方法内创建一个新对象并赋值给形参，将切断形参与实参之间的关联，并且再调用方法后，新对象也不复存在。</li>\n<li>将引用类型对象作为引用参数传递：如果在方法内创建一个新对象并赋值给形参，在方法结束后该对象依然存在，并且是实参所引用的值。</li>\n</ul>\n<h2 id=\"输出参数\"><a href=\"#输出参数\" class=\"headerlink\" title=\"输出参数\"></a>输出参数</h2><ul>\n<li><p>必须在声明和调用中都使用修饰符。输出参数的修饰符是out不是ref</p>\n</li>\n<li><p>和引用参数相似，实参必须是变量，不能是其它类型的表达式</p>\n</li>\n<li><p>out修饰的形参，不用再外部初始化，但必须要在内部赋值，再使用</p>\n</li>\n<li><p>在C#7.0之后，</p>\n<pre class=\"line-numbers language-c#\" data-language=\"c#\"><code class=\"language-c#\">using System;\n\nnamespace Simple\n&#123;\n\n    class Program\n    &#123;\n        int Sum(out int val1, out int val2)\n        &#123;\n            val1 &#x3D; 20;\n            val2 &#x3D; 30;\n            return val1 + val2;\n        &#125;\n        static void Main()\n        &#123;\n            Program p1 &#x3D; new Program();\n            int sum &#x3D; p1.Sum(out int val1, out int val2);&#x2F;&#x2F;不在需要预先声明一个变量用作out参数\n            Console.WriteLine(&quot;val1:&#123;0&#125;,val2:&#123;1&#125;&quot;, val1, val2);\n        &#125;\n    &#125;\n&#125;<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li>\n</ul>\n<h2 id=\"参数数组\"><a href=\"#参数数组\" class=\"headerlink\" title=\"参数数组\"></a>参数数组</h2><ul>\n<li><p>在一个参数列表中只能有一个参数数组</p>\n</li>\n<li><p>如果有，必须是列表中的最后一个</p>\n</li>\n<li><p>由参数数组表示的所有参数必须是同一类型</p>\n</li>\n<li><p>在数据类型前使用params修饰符</p>\n</li>\n<li><p>在数据类型后放置一组空的方括号</p>\n<pre class=\"line-numbers language-c#\" data-language=\"c#\"><code class=\"language-c#\">void Test(params int[] vals);<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span></span></code></pre></li>\n<li><p>如果数组参数是值类型，那么值被复制，实参在方法内部不受影响</p>\n</li>\n<li><p>如果数组参数是引用类型，那么引用被赋值，实参引用的对象在方法内部会受到影响</p>\n</li>\n</ul>\n<h2 id=\"参数类型总结\"><a href=\"#参数类型总结\" class=\"headerlink\" title=\"参数类型总结\"></a>参数类型总结</h2><p><img src=\"https://cbaoblog.oss-cn-shanghai.aliyuncs.com/img/QQ%E6%88%AA%E5%9B%BE20230319152908.png\" alt=\"QQ截图20230319152908\"></p>\n<h2 id=\"ref局部变量和ref返回\"><a href=\"#ref局部变量和ref返回\" class=\"headerlink\" title=\"ref局部变量和ref返回\"></a>ref局部变量和ref返回</h2><h3 id=\"ref局部变量\"><a href=\"#ref局部变量\" class=\"headerlink\" title=\"ref局部变量\"></a>ref局部变量</h3><ul>\n<li><p>创建一个对象的别名，即使引用的对象是值类型</p>\n</li>\n<li><p>对任意一个变量的赋值都会反映到另一个变量上（类似C++中的引用），即使是值类型</p>\n</li>\n<li><p>语法</p>\n<pre class=\"line-numbers language-c#\" data-language=\"c#\"><code class=\"language-c#\">ref int y &#x3D; ref x;&#x2F;&#x2F;y是x的别名<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span></span></code></pre></li>\n</ul>\n<h3 id=\"ref返回\"><a href=\"#ref返回\" class=\"headerlink\" title=\"ref返回\"></a>ref返回</h3><ul>\n<li><p>使方法返回变量的引用而不是变量值</p>\n</li>\n<li><p>语法</p>\n<pre class=\"line-numbers language-c#\" data-language=\"c#\"><code class=\"language-c#\">public ref int RefToVal()\n&#123;\n    return ref Score;\n&#125;<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span></span></code></pre></li>\n</ul>\n<h2 id=\"方法重载\"><a href=\"#方法重载\" class=\"headerlink\" title=\"方法重载\"></a>方法重载</h2><p>一个类中可以有多个同名方法，叫做方法重载，使用相同名称的每个方法必须有一个和其它方法不同的签名</p>\n<ul>\n<li>方法签名组成<ul>\n<li>方法名称</li>\n<li>参数的数目</li>\n<li>参数的类型和顺序</li>\n<li>参数修饰符</li>\n</ul>\n</li>\n<li>返回类型不是签名的一部分</li>\n<li>形参的名称也不是签名的一部分</li>\n</ul>\n<h2 id=\"递归\"><a href=\"#递归\" class=\"headerlink\" title=\"递归\"></a>递归</h2><p>方法调用自身，叫做递归</p>\n<h1 id=\"深入理解类\"><a href=\"#深入理解类\" class=\"headerlink\" title=\"深入理解类\"></a>深入理解类</h1><h2 id=\"成员修饰符的顺序\"><a href=\"#成员修饰符的顺序\" class=\"headerlink\" title=\"成员修饰符的顺序\"></a>成员修饰符的顺序</h2><ul>\n<li>修饰符<ul>\n<li>如果有修饰符，必须放在核心声明之前</li>\n<li>如果有多个修饰符，可以任意顺序排列</li>\n</ul>\n</li>\n<li>特性<ul>\n<li>如果有特性，必须放在核心声明之前</li>\n<li>如果有多个特性，可以任意顺序排列</li>\n</ul>\n</li>\n</ul>\n<p><img src=\"https://cbaoblog.oss-cn-shanghai.aliyuncs.com/img/QQ%E6%88%AA%E5%9B%BE20230319200352.png\" alt=\"QQ截图20230319200352\"></p>\n<h2 id=\"静态字段\"><a href=\"#静态字段\" class=\"headerlink\" title=\"静态字段\"></a>静态字段</h2><ul>\n<li><p>静态字段被类的所有实例共享，所有实例都访问同一内存位置</p>\n</li>\n<li><p>用static修饰符将字段声明成静态</p>\n<pre class=\"line-numbers language-c#\" data-language=\"c#\"><code class=\"language-c#\">static int test &#x3D; 100;<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span></span></code></pre></li>\n<li><p>使用类名和’.’运算符访问静态字段</p>\n</li>\n<li><p>即使不存在类实例，静态成员也存在</p>\n</li>\n</ul>\n<h2 id=\"静态函数成员\"><a href=\"#静态函数成员\" class=\"headerlink\" title=\"静态函数成员\"></a>静态函数成员</h2><ul>\n<li>静态函数成员独立于任何类实例，即使没有类实例，仍然可以调用静态方法</li>\n<li>静态函数成员不能访问实例成员，但能访问静态成员</li>\n</ul>\n<h2 id=\"成员常量\"><a href=\"#成员常量\" class=\"headerlink\" title=\"成员常量\"></a>成员常量</h2><ul>\n<li>类似于静态字段，没有实例也可以使用</li>\n<li>与真正的静态量不同，常量没有自己的存储位置，类似于C/C++中的#define值</li>\n<li>不能声明成static</li>\n</ul>\n<h2 id=\"属性\"><a href=\"#属性\" class=\"headerlink\" title=\"属性\"></a>属性</h2><p>属性是代表类实例或类中的数据项的成员</p>\n<ul>\n<li><p>属性的特征</p>\n<ul>\n<li>是命名的类成员</li>\n<li>有类型</li>\n<li>可以被赋值和读取</li>\n<li>属性是一个函数成员</li>\n<li>不一定为数据存储分配内存</li>\n<li>执行代码</li>\n</ul>\n</li>\n<li><p>属性是一组被称为访问器的方法</p>\n<ul>\n<li>set访问器为属性赋值<ul>\n<li>拥有一个单独的，隐式的值参，名称为value，与属性的类型相同</li>\n<li>拥有一个返回类型void</li>\n</ul>\n</li>\n<li>get访问器从属性获取值<ul>\n<li>没有参数</li>\n<li>拥有一个与属性类型相同的返回类型</li>\n<li>get访问器的所有执行路径必须包含一条return语句，返回一个属性类型的值</li>\n</ul>\n</li>\n<li>访问器set和get可以以任何顺序声明，且除了这两个访问器外，属性上不允许有其它方法</li>\n</ul>\n</li>\n<li><p>不能显示的调用访问器，会产生编译错误</p>\n</li>\n<li><p>属性和关联字段</p>\n<ul>\n<li><p>将字段声明成private，声明一个piblic属性来控制从类的外部对该字段的访问</p>\n<pre class=\"line-numbers language-c#\" data-language=\"c#\"><code class=\"language-c#\">class Test\n&#123;\n    private int val;\n    public int Value\n    &#123;\n        set &#123; val &#x3D; value; &#125;\n        get &#123; return val; &#125;\n        \n    &#125;  \n&#125;<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li>\n<li><p>属性和它们对应的后备字段的命名约定</p>\n<ul>\n<li><p>字段使用Camel大小写，属性使用Pascal大小写</p>\n<pre class=\"line-numbers language-c#\" data-language=\"c#\"><code class=\"language-c#\">class Test\n&#123;\n    private int val;&#x2F;&#x2F;字段使用Camel大小写\n    public int Value&#x2F;&#x2F;属性使用Pascal大小写\n    &#123;\n        set &#123; val &#x3D; value; &#125;\n        get &#123; return val; &#125;\n        \n    &#125;  \n&#125;<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li>\n<li><p>字段使用Camel大小写，并以下划线_开头，属性使用Pascal大小写</p>\n<pre class=\"line-numbers language-c#\" data-language=\"c#\"><code class=\"language-c#\">class Test\n&#123;\n    private int _val;&#x2F;&#x2F;字段使用Camel大小写，并以下划线_开头\n    public int Value&#x2F;&#x2F;属性使用Pascal大小写\n    &#123;\n        set &#123; val &#x3D; value; &#125;\n        get &#123; return val; &#125;\n        \n    &#125;  \n&#125;<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li>\n</ul>\n</li>\n</ul>\n</li>\n<li><p>属性和lambda表达式</p>\n<ul>\n<li><p>C#7.0引入的新语法</p>\n</li>\n<li><p>只能在访问函数体由一个表达式组成时才能使用</p>\n<pre class=\"line-numbers language-c#\" data-language=\"c#\"><code class=\"language-c#\">private int val;\npublic int Value\n&#123;\n    set&#x3D;&gt; val &#x3D; value &gt; 100 ? 100 : value;\n    get &#x3D;&gt; val;\n&#125;<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li>\n</ul>\n</li>\n</ul>\n<h3 id=\"只读和只写属性\"><a href=\"#只读和只写属性\" class=\"headerlink\" title=\"只读和只写属性\"></a>只读和只写属性</h3><p>属性的访问器可以单独声明</p>\n<ul>\n<li>只有get访问器的属性称为只读属性。只读属性能够安全的将一个数据项从类或类的实例中传出</li>\n<li>只有set访问器的属性称为只写属性</li>\n<li>两个访问器中至少有一个必须定义，否则编译器会报错</li>\n</ul>\n<h3 id=\"属性与公有字段\"><a href=\"#属性与公有字段\" class=\"headerlink\" title=\"属性与公有字段\"></a>属性与公有字段</h3><p>按照推荐的编码实践，属性比公有字段更好</p>\n<ul>\n<li>属性是函数成员而不是数据成员，允许处理输入和输出，而公有字段不行</li>\n<li>属性可以只读或只写，而字段不行</li>\n<li>编译后的变量和编译后的属性语义不同</li>\n</ul>\n<h3 id=\"自动实现属性\"><a href=\"#自动实现属性\" class=\"headerlink\" title=\"自动实现属性\"></a>自动实现属性</h3><p>因为属性经常被关联到后备字段，所以C#提供了自动实现属性（自动属性）</p>\n<ul>\n<li><p>允许只声明属性而不声明后备字段，编译器会创建后备字段，自动挂接到get和set访问器上</p>\n</li>\n<li><p>自动实现属性的要点如下</p>\n<ul>\n<li>不声明后备字段，编译器根据属性的类型分配存储</li>\n<li>不能提供访问器的方法体，必须被简单的声明为分号</li>\n</ul>\n<pre class=\"line-numbers language-c#\" data-language=\"c#\"><code class=\"language-c#\">class Test\n&#123;\n    public int Value&#123; get; set; &#125;\n&#125;<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span></span></code></pre></li>\n</ul>\n<h3 id=\"静态属性\"><a href=\"#静态属性\" class=\"headerlink\" title=\"静态属性\"></a>静态属性</h3><p>属性也可以声明为static。静态属性的访问器和所有静态成员一样，具有以下特点：</p>\n<ul>\n<li>不能访问类的实例成员，但能被实例成员访问</li>\n<li>不管类是否有实例，都存在</li>\n<li>在类的内部，可以仅使用名称来引用静态属性</li>\n<li>在类的外部，可以使用类名或者使用using static结构来引用静态属性</li>\n</ul>\n","feature":true,"text":"C#中的命名约定 风格名称 描述 推荐使用 示例 Pascal大小写 标识符每个单词首字母大写 用于类型名称和类中对外可见成员的名称（类，方法，命名空间，属性和公有字段） CardDeck Camel大小写 标识符每个单词首字母大写，第一个单词除外 用于局部变量的名称和方法声明的...","link":"","photos":[],"count_time":{"symbolsCount":"6.9k","symbolsTime":"6 mins."},"categories":[{"name":"C#","slug":"C","count":1,"path":"api/categories/C.json"}],"tags":[{"name":"C#","slug":"C","count":1,"path":"api/tags/C.json"}],"toc":"<ol class=\"toc\"><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#C-%E4%B8%AD%E7%9A%84%E5%91%BD%E5%90%8D%E7%BA%A6%E5%AE%9A\"><span class=\"toc-text\">C#中的命名约定</span></a></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#C-%E7%A8%8B%E5%BA%8F%E7%9A%84%E8%B5%B7%E7%82%B9%EF%BC%9AMain\"><span class=\"toc-text\">C#程序的起点：Main</span></a></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#%E7%A9%BA%E7%99%BD%E7%AC%A6\"><span class=\"toc-text\">空白符</span></a></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#%E5%9D%97\"><span class=\"toc-text\">块</span></a></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#%E4%BB%8E%E7%A8%8B%E5%BA%8F%E4%B8%AD%E8%BE%93%E5%87%BA%E6%96%87%E6%9C%AC\"><span class=\"toc-text\">从程序中输出文本</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#Write\"><span class=\"toc-text\">Write</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#WriteLine\"><span class=\"toc-text\">WriteLine</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E6%A0%BC%E5%BC%8F%E5%AD%97%E7%AC%A6%E4%B8%B2\"><span class=\"toc-text\">格式字符串</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E5%A4%9A%E9%87%8D%E6%A0%87%E8%AE%B0%E5%92%8C%E5%80%BC\"><span class=\"toc-text\">多重标记和值</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E6%A0%BC%E5%BC%8F%E5%8C%96%E6%95%B0%E5%AD%97%E5%AD%97%E7%AC%A6%E4%B8%B2\"><span class=\"toc-text\">格式化数字字符串</span></a></li></ol></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#%E6%B3%A8%E9%87%8A\"><span class=\"toc-text\">注释</span></a></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#%E9%A2%84%E5%AE%9A%E4%B9%89%E7%B1%BB%E5%9E%8B\"><span class=\"toc-text\">预定义类型</span></a></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#%E7%94%A8%E6%88%B7%E5%AE%9A%E4%B9%89%E7%B1%BB%E5%9E%8B\"><span class=\"toc-text\">用户定义类型</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#6%E7%A7%8D%E7%B1%BB%E5%9E%8B%E5%8F%AF%E4%BB%A5%E7%94%B1%E7%94%A8%E6%88%B7%E8%87%AA%E5%B7%B1%E5%88%9B%E5%BB%BA\"><span class=\"toc-text\">6种类型可以由用户自己创建</span></a></li></ol></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#%E6%A0%88%E5%92%8C%E5%A0%86\"><span class=\"toc-text\">栈和堆</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E6%A0%88\"><span class=\"toc-text\">栈</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E5%A0%86\"><span class=\"toc-text\">堆</span></a></li></ol></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#%E5%80%BC%E7%B1%BB%E5%9E%8B%E5%92%8C%E5%BC%95%E7%94%A8%E7%B1%BB%E5%9E%8B\"><span class=\"toc-text\">值类型和引用类型</span></a></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#%E7%B1%BB\"><span class=\"toc-text\">类</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E5%A3%B0%E6%98%8E%E7%B1%BB\"><span class=\"toc-text\">声明类</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E7%B1%BB%E6%88%90%E5%91%98\"><span class=\"toc-text\">类成员</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E4%B8%BA%E6%95%B0%E6%8D%AE%E5%88%86%E9%85%8D%E5%86%85%E5%AD%98\"><span class=\"toc-text\">为数据分配内存</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E8%AE%BF%E9%97%AE%E4%BF%AE%E9%A5%B0%E7%AC%A6\"><span class=\"toc-text\">访问修饰符</span></a></li></ol></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#%E6%96%B9%E6%B3%95\"><span class=\"toc-text\">方法</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E6%96%B9%E6%B3%95%E7%9A%84%E7%BB%93%E6%9E%84\"><span class=\"toc-text\">方法的结构</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E6%96%B9%E6%B3%95%E5%A4%B4\"><span class=\"toc-text\">方法头</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E6%96%B9%E6%B3%95%E4%BD%93\"><span class=\"toc-text\">方法体</span></a></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E6%96%B9%E6%B3%95%E4%BD%93%E5%86%85%E9%83%A8%E7%9A%84%E4%BB%A3%E7%A0%81%E6%89%A7%E8%A1%8C\"><span class=\"toc-text\">方法体内部的代码执行</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E5%B1%80%E9%83%A8%E5%8F%98%E9%87%8F\"><span class=\"toc-text\">局部变量</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E6%8E%A7%E5%88%B6%E6%B5%81\"><span class=\"toc-text\">控制流</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E9%80%89%E6%8B%A9%E8%AF%AD%E5%8F%A5\"><span class=\"toc-text\">选择语句</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E8%BF%AD%E4%BB%A3%E8%AF%AD%E5%8F%A5\"><span class=\"toc-text\">迭代语句</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E8%B7%B3%E8%BD%AC%E8%AF%AD%E5%8F%A5\"><span class=\"toc-text\">跳转语句</span></a></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E8%BF%94%E5%9B%9E%E5%80%BC\"><span class=\"toc-text\">返回值</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E5%8F%82%E6%95%B0\"><span class=\"toc-text\">参数</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E5%BD%A2%E5%8F%82\"><span class=\"toc-text\">形参</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E5%AE%9E%E5%8F%82\"><span class=\"toc-text\">实参</span></a></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E5%80%BC%E5%8F%82%E6%95%B0\"><span class=\"toc-text\">值参数</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E5%BC%95%E7%94%A8%E5%8F%82%E6%95%B0\"><span class=\"toc-text\">引用参数</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E5%BC%95%E7%94%A8%E7%B1%BB%E5%9E%8B%E4%BD%9C%E4%B8%BA%E5%80%BC%E5%8F%82%E6%95%B0%E5%92%8C%E5%BC%95%E7%94%A8%E5%8F%82%E6%95%B0\"><span class=\"toc-text\">引用类型作为值参数和引用参数</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E8%BE%93%E5%87%BA%E5%8F%82%E6%95%B0\"><span class=\"toc-text\">输出参数</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E5%8F%82%E6%95%B0%E6%95%B0%E7%BB%84\"><span class=\"toc-text\">参数数组</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E5%8F%82%E6%95%B0%E7%B1%BB%E5%9E%8B%E6%80%BB%E7%BB%93\"><span class=\"toc-text\">参数类型总结</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#ref%E5%B1%80%E9%83%A8%E5%8F%98%E9%87%8F%E5%92%8Cref%E8%BF%94%E5%9B%9E\"><span class=\"toc-text\">ref局部变量和ref返回</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#ref%E5%B1%80%E9%83%A8%E5%8F%98%E9%87%8F\"><span class=\"toc-text\">ref局部变量</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#ref%E8%BF%94%E5%9B%9E\"><span class=\"toc-text\">ref返回</span></a></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E6%96%B9%E6%B3%95%E9%87%8D%E8%BD%BD\"><span class=\"toc-text\">方法重载</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E9%80%92%E5%BD%92\"><span class=\"toc-text\">递归</span></a></li></ol></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E7%B1%BB\"><span class=\"toc-text\">深入理解类</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E6%88%90%E5%91%98%E4%BF%AE%E9%A5%B0%E7%AC%A6%E7%9A%84%E9%A1%BA%E5%BA%8F\"><span class=\"toc-text\">成员修饰符的顺序</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E9%9D%99%E6%80%81%E5%AD%97%E6%AE%B5\"><span class=\"toc-text\">静态字段</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E9%9D%99%E6%80%81%E5%87%BD%E6%95%B0%E6%88%90%E5%91%98\"><span class=\"toc-text\">静态函数成员</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E6%88%90%E5%91%98%E5%B8%B8%E9%87%8F\"><span class=\"toc-text\">成员常量</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E5%B1%9E%E6%80%A7\"><span class=\"toc-text\">属性</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E5%8F%AA%E8%AF%BB%E5%92%8C%E5%8F%AA%E5%86%99%E5%B1%9E%E6%80%A7\"><span class=\"toc-text\">只读和只写属性</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E5%B1%9E%E6%80%A7%E4%B8%8E%E5%85%AC%E6%9C%89%E5%AD%97%E6%AE%B5\"><span class=\"toc-text\">属性与公有字段</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E8%87%AA%E5%8A%A8%E5%AE%9E%E7%8E%B0%E5%B1%9E%E6%80%A7\"><span class=\"toc-text\">自动实现属性</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E9%9D%99%E6%80%81%E5%B1%9E%E6%80%A7\"><span class=\"toc-text\">静态属性</span></a></li></ol></li></ol></li></ol>","author":{"name":"cBao","slug":"blog-author","avatar":"https://cbaoblog.oss-cn-shanghai.aliyuncs.com/HeadPortrait.jpg","link":"/","description":"但求日积月累，收获于细微。<br /><b>虚幻引擎开发</b>","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}},"mapped":true,"prev_post":{},"next_post":{"title":"C语言字符输入/输出","uid":"297e7259160304ea1919564f5d876933","slug":"C语言字符输入输出","date":"2023-03-04T08:23:17.000Z","updated":"2023-03-04T15:12:52.060Z","comments":true,"path":"api/articles/C语言字符输入输出.json","keywords":null,"cover":"https://cbaoblog.oss-cn-shanghai.aliyuncs.com/c.png","text":"单字符I/Ogetchar()和putchar() getchar()和putchar()每次只处理一个字符 #include &lt;iostream> int main() &#123; char c; while((c=getchar())!='#')//当遇到'#'时结束...","link":"","photos":[],"count_time":{"symbolsCount":922,"symbolsTime":"1 mins."},"categories":[{"name":"C","slug":"C","count":1,"path":"api/categories/C.json"}],"tags":[{"name":"C","slug":"C","count":1,"path":"api/tags/C.json"}],"author":{"name":"cBao","slug":"blog-author","avatar":"https://cbaoblog.oss-cn-shanghai.aliyuncs.com/HeadPortrait.jpg","link":"/","description":"但求日积月累，收获于细微。<br /><b>虚幻引擎开发</b>","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}},"feature":true}}