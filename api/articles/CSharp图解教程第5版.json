{"title":"C#图解教程第5版","uid":"666eeba740dffa28e952c25ed8f5ff46","slug":"CSharp图解教程第5版","date":"2023-03-12T05:00:17.000Z","updated":"2023-04-19T15:13:21.325Z","comments":true,"path":"api/articles/CSharp图解教程第5版.json","keywords":null,"cover":"https://cbaoblog.oss-cn-shanghai.aliyuncs.com/CSharp.png","content":"<h1 id=\"C-中的命名约定\"><a href=\"#C-中的命名约定\" class=\"headerlink\" title=\"C#中的命名约定\"></a>C#中的命名约定</h1><table>\n<thead>\n<tr>\n<th align=\"center\">风格名称</th>\n<th align=\"center\">描述</th>\n<th align=\"center\">推荐使用</th>\n<th align=\"center\">示例</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"center\">Pascal大小写</td>\n<td align=\"center\">标识符每个单词首字母大写</td>\n<td align=\"center\">用于类型名称和类中对外可见成员的名称（类，方法，命名空间，属性和公有字段）</td>\n<td align=\"center\">CardDeck</td>\n</tr>\n<tr>\n<td align=\"center\">Camel大小写</td>\n<td align=\"center\">标识符每个单词首字母大写，第一个单词除外</td>\n<td align=\"center\">用于局部变量的名称和方法声明的形参名称</td>\n<td align=\"center\">cardDeck</td>\n</tr>\n<tr>\n<td align=\"center\">下划线和Camel大小写</td>\n<td align=\"center\">以下划线开头的Camel大小写的标识符</td>\n<td align=\"center\">用于私有和受保护的字段</td>\n<td align=\"center\">_cardDeck</td>\n</tr>\n</tbody></table>\n<div class=\"custom-quote warning\">\n<span class=\"custom-quote-svg\"><svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"\" xmlns=\"http://www.w3.org/2000/svg\" data-reactroot=\"\">\n<path fill=\"\" d=\"M20.86 14.13C20 14.7 19.56 15.74 19.77 16.76C20.13 18.55 18.55 20.13 16.76 19.77C15.74 19.57 14.7 20 14.13 20.86C13.12 22.38 10.89 22.38 9.88 20.86C9.3 20 8.26 19.56 7.24 19.77C5.45 20.13 3.87 18.55 4.23 16.76C4.43 15.74 4 14.7 3.14 14.13C1.62 13.12 1.62 10.89 3.14 9.88C4 9.3 4.44 8.26 4.23 7.24C3.87 5.45 5.45 3.87 7.24 4.23C8.26 4.44 9.3 4 9.87 3.14C10.88 1.62 13.11 1.62 14.12 3.14C14.7 4 15.74 4.44 16.76 4.23C18.55 3.87 20.13 5.45 19.77 7.24C19.56 8.26 20 9.3 20.86 9.87C22.38 10.88 22.38 13.12 20.86 14.13Z\" undefined=\"1\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M12 8V13\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M12 15.99V16.01\"></path>\n</svg>\n</span>\n<p class=\"custom-quote-title\">注意</p>\n<ul>\n<li><p>标识符命名可以使用字母，数字，下划线</p>\n</li>\n<li><p>标识符只能以字母和下划线开头，不能以数字开头</p>\n</li>\n<li><p>@字符只能放在标识符首位，不推荐使用</p>\n</li>\n<li><p>不能将关键字用于标识符</p>\n</li>\n<li><p>C#区分大小写</p>\n<p><img src=\"https://cbaoblog.oss-cn-shanghai.aliyuncs.com/img/image-20230312131623748.png\" alt=\"image-20230312131623748\"></p>\n</li>\n</ul>\n\n</div>\n<h1 id=\"C-程序的起点：Main\"><a href=\"#C-程序的起点：Main\" class=\"headerlink\" title=\"C#程序的起点：Main\"></a>C#程序的起点：Main</h1><ul>\n<li><p>每个C#程序必须有一个类带有Main方法</p>\n</li>\n<li><p>每个C#程序的可执行点在Main的第一条指令</p>\n</li>\n<li><p>Main首字母必须大写</p>\n</li>\n<li><p>Main的最简单形式</p>\n<pre class=\"line-numbers language-c#\" data-language=\"c#\"><code class=\"language-c#\">static void Main()\n&#123;\n   &#x2F;&#x2F;更多语句\n&#125;<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span></span></code></pre></li>\n</ul>\n<h1 id=\"空白符\"><a href=\"#空白符\" class=\"headerlink\" title=\"空白符\"></a>空白符</h1><ul>\n<li>空格（Space）</li>\n<li>制表符（Tab）</li>\n<li>换行符</li>\n<li>回车符</li>\n</ul>\n<h1 id=\"块\"><a href=\"#块\" class=\"headerlink\" title=\"块\"></a>块</h1><ul>\n<li>语法上只需要一条语句，而你需要执行的动作无法用一条简单的语句表达的情况下，考虑使用块</li>\n<li>有些特定的程序结构只能使用块。在这些结构，不能用简单语句替代快</li>\n<li>块后面不跟分号</li>\n</ul>\n<h1 id=\"从程序中输出文本\"><a href=\"#从程序中输出文本\" class=\"headerlink\" title=\"从程序中输出文本\"></a>从程序中输出文本</h1><h2 id=\"Write\"><a href=\"#Write\" class=\"headerlink\" title=\"Write\"></a>Write</h2><ul>\n<li>Write是Console类的成员，将文本字符串发送到程序控制台窗口</li>\n<li>Write不会自动添加换行符</li>\n</ul>\n<pre class=\"line-numbers language-c#\" data-language=\"c#\"><code class=\"language-c#\">Console.Write(&quot;Hello&quot;);<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span></span></code></pre>\n\n<h2 id=\"WriteLine\"><a href=\"#WriteLine\" class=\"headerlink\" title=\"WriteLine\"></a>WriteLine</h2><ul>\n<li>WriteLine是Console类的成员，将文本字符串发送到程序控制台窗口</li>\n<li>WriteLine会自动在结尾添加一个换行符</li>\n</ul>\n<pre class=\"line-numbers language-c#\" data-language=\"c#\"><code class=\"language-c#\">Console.WriteLine(&quot;Hello,World&quot;);<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span></span></code></pre>\n\n<h2 id=\"格式字符串\"><a href=\"#格式字符串\" class=\"headerlink\" title=\"格式字符串\"></a>格式字符串</h2><ul>\n<li><p>Write和WriteLine语句的常规形式中可以有一个以上的参数，参数间用逗号分隔</p>\n</li>\n<li><p>第一个参数必须是字符串，称为格式字符串，包含替代标记</p>\n</li>\n<li><p>语法：Console.WriteLine(格式字符串(含替代标记),替换值0,替换值1,替换值2,……);</p>\n<pre class=\"line-numbers language-c#\" data-language=\"c#\"><code class=\"language-c#\">Console.WriteLine(&quot;Hell&#123;0&#125;,Wor&#123;1&#125;d&quot;, &#39;o&#39;, &#39;l&#39;);<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span></span></code></pre></li>\n</ul>\n<div class=\"custom-quote tip\">\n<span class=\"custom-quote-svg\"><svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"\" xmlns=\"http://www.w3.org/2000/svg\" data-reactroot=\"\">\n<path fill=\"\" d=\"M20.86 14.13C20 14.7 19.56 15.74 19.77 16.76C20.13 18.55 18.55 20.13 16.76 19.77C15.74 19.57 14.7 20 14.13 20.86C13.12 22.38 10.89 22.38 9.88 20.86C9.3 20 8.26 19.56 7.24 19.77C5.45 20.13 3.87 18.55 4.23 16.76C4.43 15.74 4 14.7 3.14 14.13C1.62 13.12 1.62 10.89 3.14 9.88C4 9.3 4.44 8.26 4.23 7.24C3.87 5.45 5.45 3.87 7.24 4.23C8.26 4.44 9.3 4 9.87 3.14C10.88 1.62 13.11 1.62 14.12 3.14C14.7 4 15.74 4.44 16.76 4.23C18.55 3.87 20.13 5.45 19.77 7.24C19.56 8.26 20 9.3 20.86 9.87C22.38 10.88 22.38 13.12 20.86 14.13Z\" undefined=\"1\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M12.01 15C12.01 14.5 12.01 14.5 12.01 14.5C12.04 13.75 13 13.46 14.04 12.2C14.41 11.74 14.69 11.41 14.86 10.85C15.15 9.95 14.92 9.18 14.86 9.02C14.8 8.79 14.52 8 13.72 7.46C13.06 7.02 12.42 7 12.14 7C11.9 7 11.36 7 10.78 7.3C10.28 7.56 9.98 7.9 9.83 8.1C9.24 8.82 9.06 9.63 9 10.06\"></path>\n<path stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M11.99 18H12.01\"></path>\n</svg></span>\n<p class=\"custom-quote-title\">提示</p>\n<p><p>​        C#6.0引入字符串插值，通过直接在替代标记内插入变量名实现，前提需要加上$符号    </p>\n<pre class=\"line-numbers language-c#\" data-language=\"c#\"><code class=\"language-c#\">int var1 &#x3D; 3;\nint var2 &#x3D; 4;\nConsole.WriteLine($&quot;&#123;var1&#125;+&#123;var2&#125;&#x3D;?&quot;);<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span></span></code></pre>\n\n</p>\n</div>\n<h2 id=\"多重标记和值\"><a href=\"#多重标记和值\" class=\"headerlink\" title=\"多重标记和值\"></a>多重标记和值</h2><ul>\n<li>在C#中可以使用任意数量的替代标记和任意数量的值，值可以以任何顺序使用</li>\n<li>值可以在格式字符串中替换任意次</li>\n<li>标记不能试图引用超出替换值列表长度以外位置的值，若引用超过长度以外的值，不会产生编译错误，但会产生运行时错误（异常）</li>\n</ul>\n<pre class=\"line-numbers language-c#\" data-language=\"c#\"><code class=\"language-c#\">Console.WriteLine(&quot;He&#123;0&#125;&#123;0&#125;o,Worl&#123;1&#125;&quot;,&#39;l&#39;,&#39;d&#39;);&#x2F;&#x2F;正确用法<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span></span></code></pre>\n\n<p><img src=\"https://cbaoblog.oss-cn-shanghai.aliyuncs.com/img/image-20230312184805411.png\" alt=\"image-20230312184805411\"></p>\n<h2 id=\"格式化数字字符串\"><a href=\"#格式化数字字符串\" class=\"headerlink\" title=\"格式化数字字符串\"></a>格式化数字字符串</h2><ul>\n<li>把值作为货币或者某个小数位数的定点值来显示</li>\n</ul>\n<pre class=\"line-numbers language-c#\" data-language=\"c#\"><code class=\"language-c#\">Console.WriteLine(&quot;The value:&#123;0:C&#125;&quot;, 500);<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span></span></code></pre>\n\n<p><img src=\"https://cbaoblog.oss-cn-shanghai.aliyuncs.com/img/image-20230312185544009.png\" alt=\"image-20230312185544009\"></p>\n<p><img src=\"https://cbaoblog.oss-cn-shanghai.aliyuncs.com/img/image-20230312190445081.png\" alt=\"image-20230312190445081\"></p>\n<h1 id=\"注释\"><a href=\"#注释\" class=\"headerlink\" title=\"注释\"></a>注释</h1><table>\n<thead>\n<tr>\n<th align=\"center\">类型</th>\n<th align=\"center\">开始</th>\n<th align=\"center\">结束</th>\n<th align=\"center\">描述</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"center\">单行注释</td>\n<td align=\"center\">//</td>\n<td align=\"center\"></td>\n<td align=\"center\">从开始标记到该行行尾的文本被编译器忽略</td>\n</tr>\n<tr>\n<td align=\"center\">带分隔符的注释</td>\n<td align=\"center\">/*</td>\n<td align=\"center\">*/</td>\n<td align=\"center\">从开始标记到结束标记之间的文本被编译器忽略</td>\n</tr>\n<tr>\n<td align=\"center\">文档注释</td>\n<td align=\"center\">///</td>\n<td align=\"center\"></td>\n<td align=\"center\">这种类型的注释包含XML文本，可以使用工具生成程序文档</td>\n</tr>\n</tbody></table>\n<h1 id=\"预定义类型\"><a href=\"#预定义类型\" class=\"headerlink\" title=\"预定义类型\"></a>预定义类型</h1><ul>\n<li>C#提供16种预定义类型</li>\n</ul>\n<p><img src=\"https://cbaoblog.oss-cn-shanghai.aliyuncs.com/img/image-20230312200102564.png\" alt=\"image-20230312200102564\"></p>\n<p><img src=\"https://cbaoblog.oss-cn-shanghai.aliyuncs.com/img/image-20230312200217648.png\" alt=\"image-20230312200217648\"></p>\n<p><img src=\"https://cbaoblog.oss-cn-shanghai.aliyuncs.com/img/image-20230312200254264.png\" alt=\"image-20230312200254264\"></p>\n<h1 id=\"用户定义类型\"><a href=\"#用户定义类型\" class=\"headerlink\" title=\"用户定义类型\"></a>用户定义类型</h1><h2 id=\"6种类型可以由用户自己创建\"><a href=\"#6种类型可以由用户自己创建\" class=\"headerlink\" title=\"6种类型可以由用户自己创建\"></a>6种类型可以由用户自己创建</h2><ul>\n<li>类类型（class）</li>\n<li>结构类型（struct）</li>\n<li>数组类型（array）</li>\n<li>枚举类型（enum）</li>\n<li>委托类型（delegate）</li>\n<li>接口类型（interface）</li>\n</ul>\n<h1 id=\"栈和堆\"><a href=\"#栈和堆\" class=\"headerlink\" title=\"栈和堆\"></a>栈和堆</h1><h2 id=\"栈\"><a href=\"#栈\" class=\"headerlink\" title=\"栈\"></a>栈</h2><ul>\n<li><p>栈是一个内存数组，是一个LIFO(后进先出的数据结构)</p>\n</li>\n<li><p>栈存储几种类型的数据</p>\n<ul>\n<li>某些类型变量的值</li>\n<li>程序当前的执行环境</li>\n<li>传递给方法的参数</li>\n</ul>\n</li>\n<li><p>栈的特征</p>\n<ul>\n<li>数据只能从栈的顶端插入和删除</li>\n<li>将数据放到栈顶称为入栈（push）</li>\n<li>从栈顶删除数据称为出栈（pop）</li>\n</ul>\n<p><img src=\"https://cbaoblog.oss-cn-shanghai.aliyuncs.com/img/image-20230312201747146.png\" alt=\"image-20230312201747146\"></p>\n</li>\n</ul>\n<div class=\"custom-quote tip\">\n<span class=\"custom-quote-svg\"><svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"\" xmlns=\"http://www.w3.org/2000/svg\" data-reactroot=\"\">\n<path fill=\"\" d=\"M20.86 14.13C20 14.7 19.56 15.74 19.77 16.76C20.13 18.55 18.55 20.13 16.76 19.77C15.74 19.57 14.7 20 14.13 20.86C13.12 22.38 10.89 22.38 9.88 20.86C9.3 20 8.26 19.56 7.24 19.77C5.45 20.13 3.87 18.55 4.23 16.76C4.43 15.74 4 14.7 3.14 14.13C1.62 13.12 1.62 10.89 3.14 9.88C4 9.3 4.44 8.26 4.23 7.24C3.87 5.45 5.45 3.87 7.24 4.23C8.26 4.44 9.3 4 9.87 3.14C10.88 1.62 13.11 1.62 14.12 3.14C14.7 4 15.74 4.44 16.76 4.23C18.55 3.87 20.13 5.45 19.77 7.24C19.56 8.26 20 9.3 20.86 9.87C22.38 10.88 22.38 13.12 20.86 14.13Z\" undefined=\"1\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M12.01 15C12.01 14.5 12.01 14.5 12.01 14.5C12.04 13.75 13 13.46 14.04 12.2C14.41 11.74 14.69 11.41 14.86 10.85C15.15 9.95 14.92 9.18 14.86 9.02C14.8 8.79 14.52 8 13.72 7.46C13.06 7.02 12.42 7 12.14 7C11.9 7 11.36 7 10.78 7.3C10.28 7.56 9.98 7.9 9.83 8.1C9.24 8.82 9.06 9.63 9 10.06\"></path>\n<path stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M11.99 18H12.01\"></path>\n</svg></span>\n<p class=\"custom-quote-title\">提示</p>\n<p>​        系统管理所有栈操作</p>\n\n</div>\n<h2 id=\"堆\"><a href=\"#堆\" class=\"headerlink\" title=\"堆\"></a>堆</h2><ul>\n<li>堆是一块内存区域，在堆里可以分配大块的内存用于存储某种类型的数据对象</li>\n<li>与栈不同，堆里的内存能够以任意顺序存入和移除</li>\n<li>在C#中GC会自动清除无主的堆对象（C++需要程序员自己释放内存）</li>\n<li>GC垃圾收集的过程</li>\n</ul>\n<p><img src=\"https://cbaoblog.oss-cn-shanghai.aliyuncs.com/img/image-20230312202244187.png\" alt=\"image-20230312202244187\"></p>\n<h1 id=\"值类型和引用类型\"><a href=\"#值类型和引用类型\" class=\"headerlink\" title=\"值类型和引用类型\"></a>值类型和引用类型</h1><p><img src=\"https://cbaoblog.oss-cn-shanghai.aliyuncs.com/img/image-20230312203527565.png\" alt=\"image-20230312203527565\"></p>\n<p><img src=\"https://cbaoblog.oss-cn-shanghai.aliyuncs.com/img/image-20230312203842553.png\" alt=\"image-20230312203842553\"></p>\n<p><img src=\"https://cbaoblog.oss-cn-shanghai.aliyuncs.com/img/image-20230312203928453.png\" alt=\"image-20230312203928453\"></p>\n<h1 id=\"类\"><a href=\"#类\" class=\"headerlink\" title=\"类\"></a>类</h1><h2 id=\"声明类\"><a href=\"#声明类\" class=\"headerlink\" title=\"声明类\"></a>声明类</h2><pre class=\"line-numbers language-c#\" data-language=\"c#\"><code class=\"language-c#\">class Player\n&#123;\n    &#x2F;&#x2F;...\n&#125;<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span></span></code></pre>\n\n<h2 id=\"类成员\"><a href=\"#类成员\" class=\"headerlink\" title=\"类成员\"></a>类成员</h2><ul>\n<li><p>字段和方法是最重要的类成员类型。字段是数据成员，方法是函数成员</p>\n<ul>\n<li><p>字段：隶属于类的变量</p>\n<div class=\"custom-quote warning\">\n<span class=\"custom-quote-svg\"><svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"\" xmlns=\"http://www.w3.org/2000/svg\" data-reactroot=\"\">\n<path fill=\"\" d=\"M20.86 14.13C20 14.7 19.56 15.74 19.77 16.76C20.13 18.55 18.55 20.13 16.76 19.77C15.74 19.57 14.7 20 14.13 20.86C13.12 22.38 10.89 22.38 9.88 20.86C9.3 20 8.26 19.56 7.24 19.77C5.45 20.13 3.87 18.55 4.23 16.76C4.43 15.74 4 14.7 3.14 14.13C1.62 13.12 1.62 10.89 3.14 9.88C4 9.3 4.44 8.26 4.23 7.24C3.87 5.45 5.45 3.87 7.24 4.23C8.26 4.44 9.3 4 9.87 3.14C10.88 1.62 13.11 1.62 14.12 3.14C14.7 4 15.74 4.44 16.76 4.23C18.55 3.87 20.13 5.45 19.77 7.24C19.56 8.26 20 9.3 20.86 9.87C22.38 10.88 22.38 13.12 20.86 14.13Z\" undefined=\"1\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M12 8V13\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M12 15.99V16.01\"></path>\n</svg>\n</span>\n<p class=\"custom-quote-title\">注意</p>\n<p><p>​        与C/C++不同，C#在类型外部不能声明全局变量（变量或字段）。所有字段都属于类型，必须在类型内部声明。</p>\n</p>\n</div>\n</li>\n<li><p>方法：相当于C++中的成员函数</p>\n<div class=\"custom-quote warning\">\n<span class=\"custom-quote-svg\"><svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"\" xmlns=\"http://www.w3.org/2000/svg\" data-reactroot=\"\">\n<path fill=\"\" d=\"M20.86 14.13C20 14.7 19.56 15.74 19.77 16.76C20.13 18.55 18.55 20.13 16.76 19.77C15.74 19.57 14.7 20 14.13 20.86C13.12 22.38 10.89 22.38 9.88 20.86C9.3 20 8.26 19.56 7.24 19.77C5.45 20.13 3.87 18.55 4.23 16.76C4.43 15.74 4 14.7 3.14 14.13C1.62 13.12 1.62 10.89 3.14 9.88C4 9.3 4.44 8.26 4.23 7.24C3.87 5.45 5.45 3.87 7.24 4.23C8.26 4.44 9.3 4 9.87 3.14C10.88 1.62 13.11 1.62 14.12 3.14C14.7 4 15.74 4.44 16.76 4.23C18.55 3.87 20.13 5.45 19.77 7.24C19.56 8.26 20 9.3 20.86 9.87C22.38 10.88 22.38 13.12 20.86 14.13Z\" undefined=\"1\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M12 8V13\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M12 15.99V16.01\"></path>\n</svg>\n</span>\n<p class=\"custom-quote-title\">注意</p>\n<p>​        与C/C++不同，C#中没有全局函数<br>​        C#中的所有方法必须包含返回类型或void</p>\n\n</div>\n</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"为数据分配内存\"><a href=\"#为数据分配内存\" class=\"headerlink\" title=\"为数据分配内存\"></a>为数据分配内存</h2><ul>\n<li><p>使用new运算符为实际数据分配内存</p>\n</li>\n<li><p>new运算符为任意指定类型的实例分配并初始化内存。依据类型的不同从栈或堆里分配</p>\n<pre class=\"line-numbers language-c#\" data-language=\"c#\"><code class=\"language-c#\">Player p1&#x3D;new Player();<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span></span></code></pre></li>\n</ul>\n<h2 id=\"访问修饰符\"><a href=\"#访问修饰符\" class=\"headerlink\" title=\"访问修饰符\"></a>访问修饰符</h2><ul>\n<li>语法<ul>\n<li>字段：访问修饰符 类型 标识符;</li>\n<li>方法：访问修饰符 返回类型 方法名() {…}</li>\n</ul>\n</li>\n<li>五种修饰符<ul>\n<li>私有的（private）<ul>\n<li>C#默认的访问级别是私有访问</li>\n<li>私有成员只能从声明它的类的内部访问，其它的类看不见且无法访问它们</li>\n</ul>\n</li>\n<li>公有的（public）</li>\n<li>受保护的（protected）</li>\n<li>内部的（internal）</li>\n<li>受保护内部的（protected internal）</li>\n</ul>\n</li>\n</ul>\n<h1 id=\"方法\"><a href=\"#方法\" class=\"headerlink\" title=\"方法\"></a>方法</h1><h2 id=\"方法的结构\"><a href=\"#方法的结构\" class=\"headerlink\" title=\"方法的结构\"></a>方法的结构</h2><h3 id=\"方法头\"><a href=\"#方法头\" class=\"headerlink\" title=\"方法头\"></a>方法头</h3><ul>\n<li>指示方法是否返回数据，如果返回，返回什么类型</li>\n<li>方法的名称</li>\n<li>接受的数据类型</li>\n</ul>\n<h3 id=\"方法体\"><a href=\"#方法体\" class=\"headerlink\" title=\"方法体\"></a>方法体</h3><ul>\n<li>包含可执行代码的语句序列，执行过程从方法体的第一条语句开始，一直到整个方法结束</li>\n</ul>\n<p><img src=\"https://cbaoblog.oss-cn-shanghai.aliyuncs.com/img/QQ%E6%88%AA%E5%9B%BE20230314195842.png\" alt=\"QQ截图20230314195842\"></p>\n<h2 id=\"方法体内部的代码执行\"><a href=\"#方法体内部的代码执行\" class=\"headerlink\" title=\"方法体内部的代码执行\"></a>方法体内部的代码执行</h2><ul>\n<li>局部变量</li>\n<li>控制流结构</li>\n<li>方法调用</li>\n<li>内嵌的块</li>\n<li>其它方法（局部函数，C#7.0开始）</li>\n</ul>\n<h2 id=\"局部变量\"><a href=\"#局部变量\" class=\"headerlink\" title=\"局部变量\"></a>局部变量</h2><ul>\n<li>局部变量的生命周期仅限于创建它的块及其内嵌的块<ul>\n<li>声明时开始存在</li>\n<li>在块完成时结束存在</li>\n</ul>\n</li>\n<li>可以在方法体内任意位置声明局部变量，但必须在使用它们前声明</li>\n<li>不会隐式初始化，使用之前未赋值，编译器会产生错误消息</li>\n<li>类型推断和var关键字<ul>\n<li>var关键字只能用于局部变量，不能用于字段（属于类的变量为字段）</li>\n<li>只能在局部变量声明中包含初始化时使用</li>\n<li>一旦编译器推断出变量的类型，它就是固定且不能更改的</li>\n<li>var关键字不改变C#的强类型性质</li>\n</ul>\n</li>\n<li>在C#中不管嵌套级别如何，都不能在第一个名称的有效范围内声明另一个同名的局部变量</li>\n</ul>\n<h2 id=\"控制流\"><a href=\"#控制流\" class=\"headerlink\" title=\"控制流\"></a>控制流</h2><h3 id=\"选择语句\"><a href=\"#选择语句\" class=\"headerlink\" title=\"选择语句\"></a>选择语句</h3><ul>\n<li>if</li>\n<li>if…else</li>\n<li>switch</li>\n</ul>\n<h3 id=\"迭代语句\"><a href=\"#迭代语句\" class=\"headerlink\" title=\"迭代语句\"></a>迭代语句</h3><ul>\n<li>for循环</li>\n<li>while循环</li>\n<li>do循环</li>\n<li>foreach（为一组中每个成员执行一次）</li>\n</ul>\n<h3 id=\"跳转语句\"><a href=\"#跳转语句\" class=\"headerlink\" title=\"跳转语句\"></a>跳转语句</h3><ul>\n<li>break：跳出当前循环</li>\n<li>continue：到当前循环的底部</li>\n<li>goto：到一个标签</li>\n<li>return：返回到调用方法继续执行</li>\n</ul>\n<h2 id=\"返回值\"><a href=\"#返回值\" class=\"headerlink\" title=\"返回值\"></a>返回值</h2><ul>\n<li>如果要返回值，方法必须在方法名前面声明一个返回类型</li>\n<li>如果方法不返回值，必须声明为void返回类型</li>\n</ul>\n<h2 id=\"参数\"><a href=\"#参数\" class=\"headerlink\" title=\"参数\"></a>参数</h2><h3 id=\"形参\"><a href=\"#形参\" class=\"headerlink\" title=\"形参\"></a>形参</h3><ul>\n<li>形参是局部变量，声明在方法的参数列表中</li>\n</ul>\n<h3 id=\"实参\"><a href=\"#实参\" class=\"headerlink\" title=\"实参\"></a>实参</h3><ul>\n<li>用于初始化形参的表达式或变量称作实参</li>\n</ul>\n<h2 id=\"值参数\"><a href=\"#值参数\" class=\"headerlink\" title=\"值参数\"></a>值参数</h2><ul>\n<li>在栈中为形参分配空间</li>\n<li>将实参的值复制给形参</li>\n<li>改变形参不会影响实参</li>\n</ul>\n<h2 id=\"引用参数\"><a href=\"#引用参数\" class=\"headerlink\" title=\"引用参数\"></a>引用参数</h2><ul>\n<li>使用引用参数时，必须在方法的声明和调用中都是用ref修饰符</li>\n<li>实参必须是变量，且必须被赋值</li>\n<li>形参会改变实参</li>\n</ul>\n<h2 id=\"引用类型作为值参数和引用参数\"><a href=\"#引用类型作为值参数和引用参数\" class=\"headerlink\" title=\"引用类型作为值参数和引用参数\"></a>引用类型作为值参数和引用参数</h2><ul>\n<li>将引用类型对象作为值参数传递：如果在方法内创建一个新对象并赋值给形参，将切断形参与实参之间的关联，并且再调用方法后，新对象也不复存在。</li>\n<li>将引用类型对象作为引用参数传递：如果在方法内创建一个新对象并赋值给形参，在方法结束后该对象依然存在，并且是实参所引用的值。</li>\n</ul>\n<h2 id=\"输出参数\"><a href=\"#输出参数\" class=\"headerlink\" title=\"输出参数\"></a>输出参数</h2><ul>\n<li><p>必须在声明和调用中都使用修饰符。输出参数的修饰符是out不是ref</p>\n</li>\n<li><p>和引用参数相似，实参必须是变量，不能是其它类型的表达式</p>\n</li>\n<li><p>out修饰的形参，不用再外部初始化，但必须要在内部赋值，再使用</p>\n</li>\n<li><p>在C#7.0之后，</p>\n<pre class=\"line-numbers language-c#\" data-language=\"c#\"><code class=\"language-c#\">using System;\n\nnamespace Simple\n&#123;\n\n    class Program\n    &#123;\n        int Sum(out int val1, out int val2)\n        &#123;\n            val1 &#x3D; 20;\n            val2 &#x3D; 30;\n            return val1 + val2;\n        &#125;\n        static void Main()\n        &#123;\n            Program p1 &#x3D; new Program();\n            int sum &#x3D; p1.Sum(out int val1, out int val2);&#x2F;&#x2F;不在需要预先声明一个变量用作out参数\n            Console.WriteLine(&quot;val1:&#123;0&#125;,val2:&#123;1&#125;&quot;, val1, val2);\n        &#125;\n    &#125;\n&#125;<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li>\n</ul>\n<h2 id=\"参数数组\"><a href=\"#参数数组\" class=\"headerlink\" title=\"参数数组\"></a>参数数组</h2><ul>\n<li><p>在一个参数列表中只能有一个参数数组</p>\n</li>\n<li><p>如果有，必须是列表中的最后一个</p>\n</li>\n<li><p>由参数数组表示的所有参数必须是同一类型</p>\n</li>\n<li><p>在数据类型前使用params修饰符</p>\n</li>\n<li><p>在数据类型后放置一组空的方括号</p>\n<pre class=\"line-numbers language-c#\" data-language=\"c#\"><code class=\"language-c#\">void Test(params int[] vals);<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span></span></code></pre></li>\n<li><p>如果数组参数是值类型，那么值被复制，实参在方法内部不受影响</p>\n</li>\n<li><p>如果数组参数是引用类型，那么引用被赋值，实参引用的对象在方法内部会受到影响</p>\n</li>\n</ul>\n<h2 id=\"参数类型总结\"><a href=\"#参数类型总结\" class=\"headerlink\" title=\"参数类型总结\"></a>参数类型总结</h2><p><img src=\"https://cbaoblog.oss-cn-shanghai.aliyuncs.com/img/QQ%E6%88%AA%E5%9B%BE20230319152908.png\" alt=\"QQ截图20230319152908\"></p>\n<h2 id=\"ref局部变量和ref返回\"><a href=\"#ref局部变量和ref返回\" class=\"headerlink\" title=\"ref局部变量和ref返回\"></a>ref局部变量和ref返回</h2><h3 id=\"ref局部变量\"><a href=\"#ref局部变量\" class=\"headerlink\" title=\"ref局部变量\"></a>ref局部变量</h3><ul>\n<li><p>创建一个对象的别名，即使引用的对象是值类型</p>\n</li>\n<li><p>对任意一个变量的赋值都会反映到另一个变量上（类似C++中的引用），即使是值类型</p>\n</li>\n<li><p>语法</p>\n<pre class=\"line-numbers language-c#\" data-language=\"c#\"><code class=\"language-c#\">ref int y &#x3D; ref x;&#x2F;&#x2F;y是x的别名<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span></span></code></pre></li>\n</ul>\n<h3 id=\"ref返回\"><a href=\"#ref返回\" class=\"headerlink\" title=\"ref返回\"></a>ref返回</h3><ul>\n<li><p>使方法返回变量的引用而不是变量值</p>\n</li>\n<li><p>语法</p>\n<pre class=\"line-numbers language-c#\" data-language=\"c#\"><code class=\"language-c#\">public ref int RefToVal()\n&#123;\n    return ref Score;\n&#125;<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span></span></code></pre></li>\n</ul>\n<h2 id=\"方法重载\"><a href=\"#方法重载\" class=\"headerlink\" title=\"方法重载\"></a>方法重载</h2><p>一个类中可以有多个同名方法，叫做方法重载，使用相同名称的每个方法必须有一个和其它方法不同的签名</p>\n<ul>\n<li>方法签名组成<ul>\n<li>方法名称</li>\n<li>参数的数目</li>\n<li>参数的类型和顺序</li>\n<li>参数修饰符</li>\n</ul>\n</li>\n<li>返回类型不是签名的一部分</li>\n<li>形参的名称也不是签名的一部分</li>\n</ul>\n<h2 id=\"递归\"><a href=\"#递归\" class=\"headerlink\" title=\"递归\"></a>递归</h2><p>方法调用自身，叫做递归</p>\n<h1 id=\"深入理解类\"><a href=\"#深入理解类\" class=\"headerlink\" title=\"深入理解类\"></a>深入理解类</h1><h2 id=\"成员修饰符的顺序\"><a href=\"#成员修饰符的顺序\" class=\"headerlink\" title=\"成员修饰符的顺序\"></a>成员修饰符的顺序</h2><ul>\n<li>修饰符<ul>\n<li>如果有修饰符，必须放在核心声明之前</li>\n<li>如果有多个修饰符，可以任意顺序排列</li>\n</ul>\n</li>\n<li>特性<ul>\n<li>如果有特性，必须放在核心声明之前</li>\n<li>如果有多个特性，可以任意顺序排列</li>\n</ul>\n</li>\n</ul>\n<p><img src=\"https://cbaoblog.oss-cn-shanghai.aliyuncs.com/img/QQ%E6%88%AA%E5%9B%BE20230319200352.png\" alt=\"QQ截图20230319200352\"></p>\n<h2 id=\"静态字段\"><a href=\"#静态字段\" class=\"headerlink\" title=\"静态字段\"></a>静态字段</h2><ul>\n<li><p>静态字段被类的所有实例共享，所有实例都访问同一内存位置</p>\n</li>\n<li><p>用static修饰符将字段声明成静态</p>\n<pre class=\"line-numbers language-c#\" data-language=\"c#\"><code class=\"language-c#\">static int test &#x3D; 100;<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span></span></code></pre></li>\n<li><p>使用类名和’.’运算符访问静态字段</p>\n</li>\n<li><p>即使不存在类实例，静态成员也存在</p>\n</li>\n</ul>\n<h2 id=\"静态函数成员\"><a href=\"#静态函数成员\" class=\"headerlink\" title=\"静态函数成员\"></a>静态函数成员</h2><ul>\n<li>静态函数成员独立于任何类实例，即使没有类实例，仍然可以调用静态方法</li>\n<li>静态函数成员不能访问实例成员，但能访问静态成员</li>\n</ul>\n<h2 id=\"成员常量\"><a href=\"#成员常量\" class=\"headerlink\" title=\"成员常量\"></a>成员常量</h2><ul>\n<li>类似于静态字段，没有实例也可以使用</li>\n<li>与真正的静态量不同，常量没有自己的存储位置，类似于C/C++中的#define值</li>\n<li>不能声明成static</li>\n</ul>\n<h2 id=\"属性\"><a href=\"#属性\" class=\"headerlink\" title=\"属性\"></a>属性</h2><p>属性是代表类实例或类中数据项的成员</p>\n<ul>\n<li><p>属性的特征</p>\n<ul>\n<li>是命名的类成员</li>\n<li>有类型</li>\n<li>可以被赋值和读取</li>\n<li>属性是一个函数成员</li>\n<li>不一定为数据存储分配内存</li>\n<li>执行代码</li>\n</ul>\n</li>\n<li><p>属性是一组被称为访问器的方法</p>\n<ul>\n<li>set访问器为属性赋值<ul>\n<li>拥有一个单独的，隐式的值参，名称为value，与属性的类型相同</li>\n<li>拥有一个返回类型void</li>\n</ul>\n</li>\n<li>get访问器从属性获取值<ul>\n<li>没有参数</li>\n<li>拥有一个与属性类型相同的返回类型</li>\n<li>get访问器的所有执行路径必须包含一条return语句，返回一个属性类型的值</li>\n</ul>\n</li>\n<li>访问器set和get可以以任何顺序声明，且除了这两个访问器外，属性上不允许有其它方法</li>\n</ul>\n</li>\n<li><p>不能显示的调用访问器，会产生编译错误</p>\n</li>\n<li><p>属性和关联字段</p>\n<ul>\n<li><p>将字段声明成private，声明一个public属性来控制从类的外部对该字段的访问</p>\n<pre class=\"line-numbers language-c#\" data-language=\"c#\"><code class=\"language-c#\">class Test\n&#123;\n    private int val;\n    public int Value\n    &#123;\n        set &#123; val &#x3D; value; &#125;\n        get &#123; return val; &#125;\n        \n    &#125;  \n&#125;<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li>\n<li><p>属性和它们对应的后备字段的命名约定</p>\n<ul>\n<li><p>字段使用Camel大小写，属性使用Pascal大小写</p>\n<pre class=\"line-numbers language-c#\" data-language=\"c#\"><code class=\"language-c#\">class Test\n&#123;\n    private int val;&#x2F;&#x2F;字段使用Camel大小写\n    public int Value&#x2F;&#x2F;属性使用Pascal大小写\n    &#123;\n        set &#123; val &#x3D; value; &#125;\n        get &#123; return val; &#125;\n        \n    &#125;  \n&#125;<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li>\n<li><p>字段使用Camel大小写，并以下划线_开头，属性使用Pascal大小写（按照C#命名约定，推荐使用这种方式）</p>\n<pre class=\"line-numbers language-c#\" data-language=\"c#\"><code class=\"language-c#\">class Test\n&#123;\n    private int _val;&#x2F;&#x2F;字段使用Camel大小写，并以下划线_开头\n    public int Value&#x2F;&#x2F;属性使用Pascal大小写\n    &#123;\n        set &#123; val &#x3D; value; &#125;\n        get &#123; return val; &#125;\n        \n    &#125;  \n&#125;<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li>\n</ul>\n</li>\n</ul>\n</li>\n<li><p>属性和lambda表达式</p>\n<ul>\n<li><p>C#7.0引入的新语法</p>\n</li>\n<li><p>只能在访问函数体由一个表达式组成时才能使用</p>\n<pre class=\"line-numbers language-c#\" data-language=\"c#\"><code class=\"language-c#\">private int val;\npublic int Value\n&#123;\n    set&#x3D;&gt; val &#x3D; value &gt; 100 ? 100 : value;\n    get &#x3D;&gt; val;\n&#125;<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li>\n</ul>\n</li>\n</ul>\n<h3 id=\"只读和只写属性\"><a href=\"#只读和只写属性\" class=\"headerlink\" title=\"只读和只写属性\"></a>只读和只写属性</h3><p>属性的访问器可以单独声明</p>\n<ul>\n<li>只有get访问器的属性称为只读属性。只读属性能够安全的将一个数据项从类或类的实例中传出</li>\n<li>只有set访问器的属性称为只写属性</li>\n<li>两个访问器中至少有一个必须定义，否则编译器会报错</li>\n</ul>\n<h3 id=\"属性与公有字段\"><a href=\"#属性与公有字段\" class=\"headerlink\" title=\"属性与公有字段\"></a>属性与公有字段</h3><p>按照推荐的编码实践，属性比公有字段更好</p>\n<ul>\n<li>属性是函数成员而不是数据成员，允许处理输入和输出，而公有字段不行</li>\n<li>属性可以只读或只写，而字段不行</li>\n<li>编译后的变量和编译后的属性语义不同</li>\n</ul>\n<h3 id=\"自动实现属性\"><a href=\"#自动实现属性\" class=\"headerlink\" title=\"自动实现属性\"></a>自动实现属性</h3><p>因为属性经常被关联到后备字段，所以C#提供了自动实现属性（自动属性）</p>\n<ul>\n<li><p>允许只声明属性而不声明后备字段，编译器会创建后备字段，自动挂接到get和set访问器上</p>\n</li>\n<li><p>自动实现属性的要点如下</p>\n<ul>\n<li>不声明后备字段，编译器根据属性的类型分配存储</li>\n<li>不能提供访问器的方法体，必须被简单的声明为分号</li>\n</ul>\n<pre class=\"line-numbers language-c#\" data-language=\"c#\"><code class=\"language-c#\">class Test\n&#123;\n    public int Value&#123; get; set; &#125;\n&#125;<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span></span></code></pre></li>\n</ul>\n<h3 id=\"静态属性\"><a href=\"#静态属性\" class=\"headerlink\" title=\"静态属性\"></a>静态属性</h3><p>属性也可以声明为static。静态属性的访问器和所有静态成员一样，具有以下特点：</p>\n<ul>\n<li>不能访问类的实例成员，但能被实例成员访问</li>\n<li>不管类是否有实例，都存在</li>\n<li>在类的内部，可以仅使用名称来引用静态属性</li>\n<li>在类的外部，可以使用类名或者使用using static结构来引用静态属性</li>\n</ul>\n<h2 id=\"实例构造函数\"><a href=\"#实例构造函数\" class=\"headerlink\" title=\"实例构造函数\"></a>实例构造函数</h2><p>实例构造函数是一个特殊的方法，它在创建每个新实例时执行</p>\n<ul>\n<li>构造函数用于初始化类实例的状态</li>\n<li>如果希望能从类的外部创建类的实例，需要将构造函数声明为public</li>\n<li>构造函数的名称和类名相同</li>\n<li>构造函数不能有返回值</li>\n<li>构造函数可以带参数</li>\n<li>构造函数可以被重载</li>\n<li>如果在类的声明中没有显示的提供实例构造函数，编译器会提供一个隐式的默认构造函数（没有参数，构造体为空）</li>\n<li>如果为类显示定义了构造函数，编译器不会为该类定义默认构造函数</li>\n<li>将构造函数的访问修饰符设置成private，这样在类外部就不能实例该类型对象</li>\n</ul>\n<h2 id=\"静态构造函数\"><a href=\"#静态构造函数\" class=\"headerlink\" title=\"静态构造函数\"></a>静态构造函数</h2><p>构造函数可以声明为static，实例构造函数初始化每个新实例，static构造函数初始化类级别的项，通常静态构造函数初始化类的静态字段</p>\n<ul>\n<li>在引用任何静态成员之前</li>\n<li>在创建类的任何实例之前</li>\n<li>静态构造函数的名称必须和类名相同</li>\n<li>构造函数不能有返回值</li>\n<li>静态构造函数声明中使用static关键字</li>\n<li>类只能有一个静态构造函数，且不能带参数</li>\n<li>静态构造函数不能有访问修饰符</li>\n</ul>\n<div class=\"custom-quote warning\">\n<span class=\"custom-quote-svg\"><svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"\" xmlns=\"http://www.w3.org/2000/svg\" data-reactroot=\"\">\n<path fill=\"\" d=\"M20.86 14.13C20 14.7 19.56 15.74 19.77 16.76C20.13 18.55 18.55 20.13 16.76 19.77C15.74 19.57 14.7 20 14.13 20.86C13.12 22.38 10.89 22.38 9.88 20.86C9.3 20 8.26 19.56 7.24 19.77C5.45 20.13 3.87 18.55 4.23 16.76C4.43 15.74 4 14.7 3.14 14.13C1.62 13.12 1.62 10.89 3.14 9.88C4 9.3 4.44 8.26 4.23 7.24C3.87 5.45 5.45 3.87 7.24 4.23C8.26 4.44 9.3 4 9.87 3.14C10.88 1.62 13.11 1.62 14.12 3.14C14.7 4 15.74 4.44 16.76 4.23C18.55 3.87 20.13 5.45 19.77 7.24C19.56 8.26 20 9.3 20.86 9.87C22.38 10.88 22.38 13.12 20.86 14.13Z\" undefined=\"1\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M12 8V13\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M12 15.99V16.01\"></path>\n</svg>\n</span>\n<p class=\"custom-quote-title\">注意</p>\n<p><ul>\n<li>类既可以有静态构造函数也可以有实例构造函数</li>\n<li>如同静态方法，静态构造函数不能访问所在类的实例成员，因此不能使用this访问器</li>\n<li>不能从程序中显示的调用静态构造函数，系统自动调用</li>\n</ul>\n</p>\n</div>\n<h2 id=\"对象初始化语句\"><a href=\"#对象初始化语句\" class=\"headerlink\" title=\"对象初始化语句\"></a>对象初始化语句</h2><ul>\n<li><p>创建对象的代码必须能够访问要初始化的字段和属性（公有的）</p>\n</li>\n<li><p>初始化语句发生在构造方法执行之后</p>\n</li>\n<li><p>语法示例</p>\n<pre class=\"line-numbers language-c#\" data-language=\"c#\"><code class=\"language-c#\">Test t2 &#x3D; new Test &#123; X &#x3D; 10, Y &#x3D; 20&#125;;&#x2F;&#x2F;使用了初始化语句<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span></span></code></pre></li>\n</ul>\n<h2 id=\"析构函数\"><a href=\"#析构函数\" class=\"headerlink\" title=\"析构函数\"></a>析构函数</h2><p>析构函数执行在类的实例被销毁之前需要的清理或释放非托管资源的行为</p>\n<h2 id=\"readonly修饰符\"><a href=\"#readonly修饰符\" class=\"headerlink\" title=\"readonly修饰符\"></a>readonly修饰符</h2><p>字段可以用readonly修饰符声明，作用类似于const，一旦值被设定就不能改变</p>\n<ul>\n<li><p>const字段只能在字段的声明语句中初始化，而readonly字段可以在下列任意位置设置它的值</p>\n<ul>\n<li>字段声明语句，类似const</li>\n<li>类的任何构造函数，如果是static字段，初始化必须在静态构造函数中完成</li>\n</ul>\n</li>\n<li><p>const字段的值必须在编译时决定，而readonly字段的值可以在运行时决定</p>\n</li>\n<li><p>语法示例</p>\n<pre class=\"line-numbers language-c++\" data-language=\"c++\"><code class=\"language-c++\">class Test\n&#123;\n    public Test()\n    &#123;\n        val &#x3D; 20;&#x2F;&#x2F;在构造函数中为只读字段赋值\n    &#125;\n    public readonly int val;&#x2F;&#x2F;只读字段\n&#125;<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li>\n</ul>\n<h2 id=\"this关键字\"><a href=\"#this关键字\" class=\"headerlink\" title=\"this关键字\"></a>this关键字</h2><p>this关键字在类中使用，是对当前实例的引用，它只能被用在下列类成员的代码块中</p>\n<ul>\n<li>实例构造函数</li>\n<li>实例方法</li>\n<li>属性和索引器的实例访问器</li>\n<li>用于区分类的成员和局部变量或参数</li>\n<li>作为调用方法的实参</li>\n</ul>\n<div class=\"custom-quote warning\">\n<span class=\"custom-quote-svg\"><svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"\" xmlns=\"http://www.w3.org/2000/svg\" data-reactroot=\"\">\n<path fill=\"\" d=\"M20.86 14.13C20 14.7 19.56 15.74 19.77 16.76C20.13 18.55 18.55 20.13 16.76 19.77C15.74 19.57 14.7 20 14.13 20.86C13.12 22.38 10.89 22.38 9.88 20.86C9.3 20 8.26 19.56 7.24 19.77C5.45 20.13 3.87 18.55 4.23 16.76C4.43 15.74 4 14.7 3.14 14.13C1.62 13.12 1.62 10.89 3.14 9.88C4 9.3 4.44 8.26 4.23 7.24C3.87 5.45 5.45 3.87 7.24 4.23C8.26 4.44 9.3 4 9.87 3.14C10.88 1.62 13.11 1.62 14.12 3.14C14.7 4 15.74 4.44 16.76 4.23C18.55 3.87 20.13 5.45 19.77 7.24C19.56 8.26 20 9.3 20.86 9.87C22.38 10.88 22.38 13.12 20.86 14.13Z\" undefined=\"1\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M12 8V13\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M12 15.99V16.01\"></path>\n</svg>\n</span>\n<p class=\"custom-quote-title\">注意</p>\n<p>​    因为静态成员不是实例的一部分，所以不能在任何静态函数成员的代码中使用this关键字</p>\n\n</div>\n<h2 id=\"索引器\"><a href=\"#索引器\" class=\"headerlink\" title=\"索引器\"></a>索引器</h2><p>索引器是一组get和set的访问器，与属性类似</p>\n<ul>\n<li>和属性一样，索引器不用分配内存来存储</li>\n<li>索引器和属性都主要被用来访问其它数据成员，它们与这些成员关联，并为它们提供获取和设置访问<ul>\n<li>属性通常表示单个数据成员</li>\n<li>索引器通常表示多个数据成员</li>\n</ul>\n</li>\n<li>和属性一样，索引器可以只有一个访问器，也可以两个都有</li>\n<li>索引器总是实例成员，所以不能被声明成static</li>\n<li>和属性一样，实现get和set的访问器的代码不一定要关联到某个字段或属性</li>\n<li>不能显示调用get和set访问器</li>\n</ul>\n<h3 id=\"声明索引器\"><a href=\"#声明索引器\" class=\"headerlink\" title=\"声明索引器\"></a>声明索引器</h3><ul>\n<li>索引器没有名称。在名称的位置是关键字this</li>\n<li>参数列表在方括号中间</li>\n<li>参数列表中必须至少声明一个参数</li>\n</ul>\n<pre class=\"line-numbers language-c#\" data-language=\"c#\"><code class=\"language-c#\">string this[int index]\n&#123;\n    get &#123; return this[index]; &#125;\n    set &#123; this[index] &#x3D; value; &#125;\n&#125;<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<h3 id=\"索引器的set访问器\"><a href=\"#索引器的set访问器\" class=\"headerlink\" title=\"索引器的set访问器\"></a>索引器的set访问器</h3><p>当索引器被用于赋值时，set访问器被调用，并接受两项数据</p>\n<ul>\n<li>一个名为value的隐式参数，其中持有要保存的数据</li>\n<li>一个或更多索引参数，表示数据应该保存到哪里</li>\n</ul>\n<h3 id=\"索引器示例\"><a href=\"#索引器示例\" class=\"headerlink\" title=\"索引器示例\"></a>索引器示例</h3><pre class=\"line-numbers language-c#\" data-language=\"c#\"><code class=\"language-c#\">class Test\n&#123;\n    private int val1;\n    private int val2;\n    private int val3;\n\n    public int this[int index]\n    &#123;\n        get\n        &#123;\n            switch (index)\n            &#123;\n                case 0: return val1;\n                case 1: return val2;\n                case 2: return val3;\n                default:  throw new IndexOutOfRangeException();\n            &#125;\n        &#125;\n        set\n        &#123;\n            switch (index)\n            &#123;\n                case 0:val1&#x3D; value; break;\n                case 1:val2&#x3D; value; break;\n                case 2:val3&#x3D; value; break;\n                default:throw new IndexOutOfRangeException();\n            &#125;\n        &#125;\n    &#125;\n&#125;<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<h3 id=\"索引器重载\"><a href=\"#索引器重载\" class=\"headerlink\" title=\"索引器重载\"></a>索引器重载</h3><p>只要索引器的参数列表不同，类就可以有任意多个索引器。索引器类型不同是不够的</p>\n<div class=\"custom-quote warning\">\n<span class=\"custom-quote-svg\"><svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"\" xmlns=\"http://www.w3.org/2000/svg\" data-reactroot=\"\">\n<path fill=\"\" d=\"M20.86 14.13C20 14.7 19.56 15.74 19.77 16.76C20.13 18.55 18.55 20.13 16.76 19.77C15.74 19.57 14.7 20 14.13 20.86C13.12 22.38 10.89 22.38 9.88 20.86C9.3 20 8.26 19.56 7.24 19.77C5.45 20.13 3.87 18.55 4.23 16.76C4.43 15.74 4 14.7 3.14 14.13C1.62 13.12 1.62 10.89 3.14 9.88C4 9.3 4.44 8.26 4.23 7.24C3.87 5.45 5.45 3.87 7.24 4.23C8.26 4.44 9.3 4 9.87 3.14C10.88 1.62 13.11 1.62 14.12 3.14C14.7 4 15.74 4.44 16.76 4.23C18.55 3.87 20.13 5.45 19.77 7.24C19.56 8.26 20 9.3 20.86 9.87C22.38 10.88 22.38 13.12 20.86 14.13Z\" undefined=\"1\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M12 8V13\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M12 15.99V16.01\"></path>\n</svg>\n</span>\n<p class=\"custom-quote-title\">注意</p>\n<p><p>​        类中重载的索引器必须有不同的参数列表</p>\n</p>\n</div>\n<h3 id=\"访问器的访问修饰符\"><a href=\"#访问器的访问修饰符\" class=\"headerlink\" title=\"访问器的访问修饰符\"></a>访问器的访问修饰符</h3><ul>\n<li>仅当成员（属性或索引器）既有get访问器也有set访问器时，其访问器才能有访问修饰符</li>\n<li>虽然两个访问器都必须出现，但其中只能有一个访问修饰符</li>\n<li>访问器的访问修饰符的限制必须比成员的访问级别更严格</li>\n</ul>\n<p><img src=\"https://cbaoblog.oss-cn-shanghai.aliyuncs.com/img/QQ%E6%88%AA%E5%9B%BE20230320210726.png\" alt=\"QQ截图20230320210726\"></p>\n<h3 id=\"分部类和分部类型\"><a href=\"#分部类和分部类型\" class=\"headerlink\" title=\"分部类和分部类型\"></a>分部类和分部类型</h3><p>类的声明可以分割成几个分部类的声明</p>\n<ul>\n<li><p>每个分部类的声明都含有一些类成员的声明</p>\n</li>\n<li><p>类的分部类声明可以在同一个文件中也可以在不同文件中</p>\n</li>\n<li><p>每个分部类声明必须标注为partial class，而不是单独的关键字class</p>\n</li>\n<li><p>分部类声明和普通类声明相同，只是增加了类型修饰符partial</p>\n</li>\n<li><p>分部类示例</p>\n<pre class=\"line-numbers language-c#\" data-language=\"c#\"><code class=\"language-c#\">partial class Test\n&#123;\n    public int val1;\n&#125;\n\npartial class Test\n&#123;\n    public Test()\n    &#123;\n        val1 &#x3D; 1;\n    &#125;\n    public int val2;\n&#125;<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li>\n</ul>\n<h3 id=\"分部方法\"><a href=\"#分部方法\" class=\"headerlink\" title=\"分部方法\"></a>分部方法</h3><p>分部方法是声明在分部类中不同部分的方法，分部方法的不同部分可以声明在分部类的不同部分中，也可以声明在同一个部分中</p>\n<h4 id=\"分部方法的两个部分\"><a href=\"#分部方法的两个部分\" class=\"headerlink\" title=\"分部方法的两个部分\"></a>分部方法的两个部分</h4><ul>\n<li>定义分部方法声明<ul>\n<li>给出签名和返回类型</li>\n<li>声明的实现部分只是一个分号</li>\n</ul>\n</li>\n<li>实现分部方法声明<ul>\n<li>给出签名和返回类型</li>\n<li>以普通的语句块形式实现</li>\n</ul>\n</li>\n</ul>\n<h1 id=\"类和继承\"><a href=\"#类和继承\" class=\"headerlink\" title=\"类和继承\"></a>类和继承</h1><h2 id=\"类继承\"><a href=\"#类继承\" class=\"headerlink\" title=\"类继承\"></a>类继承</h2><p>通过继承可以定义一个新类，新类为一个已经声明的类进行拓展</p>\n<ul>\n<li><p>可以使用一个已经存在的类作为新类的基础。已经存在的类称为基类，新类称为派生类</p>\n</li>\n<li><p>派生类组成如下</p>\n<ul>\n<li>本身声明中的成员</li>\n<li>基类的成员</li>\n</ul>\n</li>\n<li><p>要声明一个派生类，需要在类名后加入基类规格说明</p>\n<pre class=\"line-numbers language-c#\" data-language=\"c#\"><code class=\"language-c#\">class Base\n&#123;\n    \n&#125;\n\n&#x2F;&#x2F;使用基类规格说明,Base是Sub的基类\nclass Sub : Base\n&#123;\n    \n&#125;<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li>\n<li><p>派生类拓展它的基类，因为它包含基类的成员，还有它本身声明中新增功能</p>\n</li>\n<li><p>派生类不能删除它所继承的任何成员</p>\n</li>\n</ul>\n<h2 id=\"访问继承的成员\"><a href=\"#访问继承的成员\" class=\"headerlink\" title=\"访问继承的成员\"></a>访问继承的成员</h2><p>继承的成员可以被访问，就像它们是派生类自己声明的一样</p>\n<h2 id=\"所有类都派生自object\"><a href=\"#所有类都派生自object\" class=\"headerlink\" title=\"所有类都派生自object\"></a>所有类都派生自object</h2><p>除了特殊的类object，所有类都是派生类，即使没有基类规格说明，类object是唯一的非派生类，因为它是继承层次结构的基础</p>\n<ul>\n<li>没有基类规格说明的类隐式地直接派生自类object</li>\n<li>一个类声明的基类规格说明中只能有一个单独的类。称为单继承</li>\n<li>虽然类只能直接继承一个基类，但派生的层次没有限制</li>\n</ul>\n<h2 id=\"屏蔽基类成员\"><a href=\"#屏蔽基类成员\" class=\"headerlink\" title=\"屏蔽基类成员\"></a>屏蔽基类成员</h2><p>虽然派生类不能删除它继承的任何成员，但可以用与基类成员名称相同的成员来屏蔽基类成员。</p>\n<ul>\n<li><p>要屏蔽一个继承的数据成员，需要声明一个新的相同类型的成员，并使用相同的名称</p>\n</li>\n<li><p>通过在派生类中声明新的带有相同签名的函数成员，可以屏蔽继承的函数成员，签名由名称和参数列表组成，不包括返回类型</p>\n</li>\n<li><p>要让编译器知道故意屏蔽继承的成员，可使用new修饰符，否则编译器会警告你隐藏了一个继承的成员</p>\n<pre class=\"line-numbers language-c#\" data-language=\"c#\"><code class=\"language-c#\">class Base\n&#123;\n    public int val;\n&#125;\n\nclass Sub : Base\n&#123;\n    &#x2F;&#x2F;使用new 关键字 显示的告诉编译器屏蔽继承的成员\n    new public int val;\n&#125;<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li>\n<li><p>也可以屏蔽静态成员</p>\n</li>\n</ul>\n<h2 id=\"基类访问\"><a href=\"#基类访问\" class=\"headerlink\" title=\"基类访问\"></a>基类访问</h2><p>如果派生类必须访问被隐藏的继承成员，可以使用基类访问表达式，基类访问表达式由关键字base后面跟着一个点和成员名称组成</p>\n<pre class=\"line-numbers language-c#\" data-language=\"c#\"><code class=\"language-c#\">class Base\n&#123;\n    public int val&#x3D;20;\n&#125;\n\n&#x2F;&#x2F;使用基类规格说明,Base是Sub的基类\nclass Sub : Base\n&#123;\n    &#x2F;&#x2F;使用new 关键字 显示的告诉编译器屏蔽继承的成员\n    new public int val;\n    public void PrintfFun()\n    &#123;\n        &#x2F;&#x2F;使用base关键字访问被隐藏的基类成员\n        Console.WriteLine(base.val);\n    &#125;\n&#125;<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<h2 id=\"使用基类的引用\"><a href=\"#使用基类的引用\" class=\"headerlink\" title=\"使用基类的引用\"></a>使用基类的引用</h2><p>派生类的实例由基类的实例和派生类新增的成员组成。派生类的引用指向整个类对象，包括基类部分</p>\n<p>如果有一个派生类对象的引用，就可以获取该对象基类部分的引用（使用类型转换运算符把该引用转换为基类类型）</p>\n<pre class=\"line-numbers language-c#\" data-language=\"c#\"><code class=\"language-c#\">class Base\n&#123;\n    public void Printf()\n    &#123;\n        Console.WriteLine(&quot;My Base Class&quot;);\n    &#125;\n&#125;\n\n&#x2F;&#x2F;使用基类规格说明,Base是Sub的基类\nclass Sub : Base\n&#123;\n    &#x2F;&#x2F;隐藏基类的Printf函数\n    new public void Printf()\n    &#123;\n        Console.WriteLine(&quot;My Sub Class&quot;);\n    &#125;\n&#125;\n\nclass Program\n&#123;\n    static void Main()\n    &#123;\n        Sub s1&#x3D;new Sub();\n        Base b1 &#x3D; (Base)s1;&#x2F;&#x2F;强转成基类类型\n        b1.Printf();&#x2F;&#x2F;调用的是基类的Printf\n    &#125;  \n&#125;<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<h2 id=\"虚方法和覆写方法\"><a href=\"#虚方法和覆写方法\" class=\"headerlink\" title=\"虚方法和覆写方法\"></a>虚方法和覆写方法</h2><p>当使用基类的引用访问派生类对象时，得到的是基类的成员，虚方法可以使基类的引用访问“升至”派生类内</p>\n<h3 id=\"使用基类引用调用派生类方法\"><a href=\"#使用基类引用调用派生类方法\" class=\"headerlink\" title=\"使用基类引用调用派生类方法\"></a>使用基类引用调用派生类方法</h3><ul>\n<li>派生类的方法和基类的方法有相同的签名和返回类型</li>\n<li>基类的方法使用virtual标注</li>\n<li>派生类的方法使用override标注</li>\n</ul>\n<pre class=\"line-numbers language-c#\" data-language=\"c#\"><code class=\"language-c#\">class Base\n&#123;\n    &#x2F;&#x2F;virtual标记表示该方法可被覆写\n    virtual public void Printf()\n    &#123;\n        Console.WriteLine(&quot;My Base Class&quot;);\n    &#125;\n&#125;\n\n&#x2F;&#x2F;使用基类规格说明,Base是Sub的基类\nclass Sub : Base\n&#123;\n    &#x2F;&#x2F;override标记覆写基类方法\n    override public void Printf()\n    &#123;\n        Console.WriteLine(&quot;My Sub Class&quot;);\n    &#125;\n&#125;\n\n\nclass Program\n&#123;\n    static void Main()\n    &#123;\n        Sub s1&#x3D;new Sub();\n        Base b1 &#x3D; (Base)s1;&#x2F;&#x2F;强转成基类类型\n        b1.Printf();&#x2F;&#x2F;因为派生类覆写了基类方法，所以调用派生类方法\n    &#125;    \n&#125;<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<div class=\"custom-quote warning\">\n<span class=\"custom-quote-svg\"><svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"\" xmlns=\"http://www.w3.org/2000/svg\" data-reactroot=\"\">\n<path fill=\"\" d=\"M20.86 14.13C20 14.7 19.56 15.74 19.77 16.76C20.13 18.55 18.55 20.13 16.76 19.77C15.74 19.57 14.7 20 14.13 20.86C13.12 22.38 10.89 22.38 9.88 20.86C9.3 20 8.26 19.56 7.24 19.77C5.45 20.13 3.87 18.55 4.23 16.76C4.43 15.74 4 14.7 3.14 14.13C1.62 13.12 1.62 10.89 3.14 9.88C4 9.3 4.44 8.26 4.23 7.24C3.87 5.45 5.45 3.87 7.24 4.23C8.26 4.44 9.3 4 9.87 3.14C10.88 1.62 13.11 1.62 14.12 3.14C14.7 4 15.74 4.44 16.76 4.23C18.55 3.87 20.13 5.45 19.77 7.24C19.56 8.26 20 9.3 20.86 9.87C22.38 10.88 22.38 13.12 20.86 14.13Z\" undefined=\"1\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M12 8V13\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M12 15.99V16.01\"></path>\n</svg>\n</span>\n<p class=\"custom-quote-title\">注意</p>\n<ul>\n<li>覆写和被覆写的方法必须有相同的可访问性</li>\n<li>不能覆写static方法或非虚方法</li>\n<li>方法，属性和索引器，事件都可以被声明成virtual和override</li>\n</ul>\n\n</div>\n<h2 id=\"覆写标记为override的方法\"><a href=\"#覆写标记为override的方法\" class=\"headerlink\" title=\"覆写标记为override的方法\"></a>覆写标记为override的方法</h2><ul>\n<li>当使用对象基类部分的引用调用一个被覆写的方法时，方法的调用被沿派生层次上溯执行，一直到标记为override的方法的最高派生版本</li>\n<li>如果在更高的派生级别有该方法的其它声明，但没有被override标记，那么不会被调用</li>\n</ul>\n<h2 id=\"构造函数执行\"><a href=\"#构造函数执行\" class=\"headerlink\" title=\"构造函数执行\"></a>构造函数执行</h2><ul>\n<li>要创建对象的基类部分，需要隐式调用基类的某个构造函数</li>\n<li>继承层次链中的每个类在执行它自己的构造函数体之前执行它基类的构造函数</li>\n</ul>\n<p><img src=\"https://cbaoblog.oss-cn-shanghai.aliyuncs.com/img/QQ%E6%88%AA%E5%9B%BE20230321215406.png\" alt=\"QQ截图20230321215406\"></p>\n<div class=\"custom-quote warning\">\n<span class=\"custom-quote-svg\"><svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"\" xmlns=\"http://www.w3.org/2000/svg\" data-reactroot=\"\">\n<path fill=\"\" d=\"M20.86 14.13C20 14.7 19.56 15.74 19.77 16.76C20.13 18.55 18.55 20.13 16.76 19.77C15.74 19.57 14.7 20 14.13 20.86C13.12 22.38 10.89 22.38 9.88 20.86C9.3 20 8.26 19.56 7.24 19.77C5.45 20.13 3.87 18.55 4.23 16.76C4.43 15.74 4 14.7 3.14 14.13C1.62 13.12 1.62 10.89 3.14 9.88C4 9.3 4.44 8.26 4.23 7.24C3.87 5.45 5.45 3.87 7.24 4.23C8.26 4.44 9.3 4 9.87 3.14C10.88 1.62 13.11 1.62 14.12 3.14C14.7 4 15.74 4.44 16.76 4.23C18.55 3.87 20.13 5.45 19.77 7.24C19.56 8.26 20 9.3 20.86 9.87C22.38 10.88 22.38 13.12 20.86 14.13Z\" undefined=\"1\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M12 8V13\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M12 15.99V16.01\"></path>\n</svg>\n</span>\n<p class=\"custom-quote-title\">注意</p>\n<p><p>​    强烈反对在构造函数中调用虚方法，在执行基类的构造函数时，基类的虚方法会调用派生类的覆写方法，但这是在执行派生类的构造函数方法之前。</p>\n<p>​    因此，调用会在派生类完全初始化之前传递到派生类。</p>\n</p>\n</div>\n<h2 id=\"构造函数初始化语句\"><a href=\"#构造函数初始化语句\" class=\"headerlink\" title=\"构造函数初始化语句\"></a>构造函数初始化语句</h2><p>默认情况下，在构造对象时，将调用基类的无参构造函数。</p>\n<p>如果希望派生类使用指定的基类构造函数，必须在构造函数初始化语句中指定它</p>\n<ul>\n<li><p>第一种形式使用关键字base指明使用哪一个基类构造函数</p>\n<pre class=\"line-numbers language-c#\" data-language=\"c#\"><code class=\"language-c#\">class Base\n&#123;\n    public Base(int val1,int val2)\n    &#123;\n        Val1 &#x3D; val1;\n        Val2 &#x3D; val2;\n    &#125;\n\n    public int Val1;\n    public int Val2;\n&#125;\n\nclass SubClass : Base\n&#123;\n    &#x2F;&#x2F;base指明使用哪一个基类构造函数\n    public SubClass(int val1, int val2) : base(val1, val2)\n    &#123;\n\n    &#125;\n&#125;<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li>\n<li><p>第二种形式使用关键字this并指明应该使用当前类的哪一个构造函数</p>\n<pre class=\"line-numbers language-c#\" data-language=\"c#\"><code class=\"language-c#\">class Base\n&#123;\n    &#x2F;&#x2F;使用this指定调用当前类的无参构造函数\n    public Base(int val1):this()\n    &#123;\n        Val1 &#x3D; val1;\n    &#125;\n\n    public Base()\n    &#123;\n        Val2 &#x3D; 20;\n    &#125;\n\n    public int Val1;\n    public int Val2;\n\n    public void Printf()\n    &#123;\n        Console.WriteLine($&quot;Val1:&#123;Val1&#125;\\nVal2:&#123;Val2&#125;&quot;);\n    &#125;\n&#125;<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li>\n</ul>\n<h2 id=\"类访问修饰符\"><a href=\"#类访问修饰符\" class=\"headerlink\" title=\"类访问修饰符\"></a>类访问修饰符</h2><p>类的可访问性有两个级别</p>\n<ul>\n<li><p>标记为public的类可以被系统内任何程序集中的代码访问，要是一个类对其它程序集可见，使用public访问修饰符</p>\n<pre class=\"line-numbers language-c#\" data-language=\"c#\"><code class=\"language-c#\">public class Base\n&#123;\n    \n&#125;<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span></span></code></pre></li>\n<li><p>标记为internal的类只能被它自己所在的程序集内的类看到</p>\n<ul>\n<li>这是C#默认的可访问级别</li>\n<li>可以使用internal访问修饰符显示的声明一个类为内部的</li>\n</ul>\n<pre class=\"line-numbers language-c#\" data-language=\"c#\"><code class=\"language-c#\">internal class Base\n&#123;\n    \n&#125;<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span></span></code></pre></li>\n</ul>\n<h2 id=\"程序集之间的继承\"><a href=\"#程序集之间的继承\" class=\"headerlink\" title=\"程序集之间的继承\"></a>程序集之间的继承</h2><p>要从不同程序集中定义的基类派生类，必须具备两个条件</p>\n<ul>\n<li>基类必须被声明成public，这样才能从它所在的程序集外部访问它</li>\n<li>必须在VS工程中的References节点中添加对包含该基类的程序集的引用</li>\n</ul>\n<h2 id=\"成员访问修饰符\"><a href=\"#成员访问修饰符\" class=\"headerlink\" title=\"成员访问修饰符\"></a>成员访问修饰符</h2><ul>\n<li>所有显示声明在类声明中的成员都是相互可见的，无论访问性如何</li>\n<li>继承的成员不在类的声明中显式声明，所以继承的成员对派生类的成员可能是可见的，也可能是不可见的</li>\n<li>五个成员访问级别<ul>\n<li>public<ul>\n<li>访问级别是限制最少的。所有的类，包括程序集内部的类和外部的类都可以自由的访问成员</li>\n</ul>\n</li>\n<li>private<ul>\n<li>修饰的类成员只能被它自己的类的成员访问，不能被其它的类访问，包括继承它的类</li>\n<li>private成员能被嵌套在它的类中的类成员访问</li>\n</ul>\n</li>\n<li>protected<ul>\n<li>访问级别类似private访问级别，但它允许派生自该类的类访问该成员</li>\n</ul>\n</li>\n<li>internal<ul>\n<li>标记为internal的成员对程序集内部的所有类可见，但对程序集外部的类不可见</li>\n</ul>\n</li>\n<li>protected internal</li>\n<li>标记为protected internal的成员对所有继承该类的类以及程序集内部的所有类可见</li>\n</ul>\n</li>\n</ul>\n<p><img src=\"https://cbaoblog.oss-cn-shanghai.aliyuncs.com/img/QQ%E6%88%AA%E5%9B%BE20230322204728.png\" alt=\"QQ截图20230322204728\"></p>\n<p><img src=\"https://cbaoblog.oss-cn-shanghai.aliyuncs.com/img/QQ%E6%88%AA%E5%9B%BE20230322204939.png\" alt=\"QQ截图20230322204939\"></p>\n<h2 id=\"抽象成员\"><a href=\"#抽象成员\" class=\"headerlink\" title=\"抽象成员\"></a>抽象成员</h2><ul>\n<li>必须是一个函数成员，字段和常量不能为抽象成员</li>\n<li>必须用abstract修饰符标记</li>\n<li>不能有实现代码块，抽象成员的代码用分号表示</li>\n<li>抽象成员只能在抽象类中声明</li>\n<li>一共有四种类型的成员可以声明为抽象的<ul>\n<li>方法</li>\n<li>属性</li>\n<li>事件</li>\n<li>索引器</li>\n</ul>\n</li>\n</ul>\n<div class=\"custom-quote warning\">\n<span class=\"custom-quote-svg\"><svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"\" xmlns=\"http://www.w3.org/2000/svg\" data-reactroot=\"\">\n<path fill=\"\" d=\"M20.86 14.13C20 14.7 19.56 15.74 19.77 16.76C20.13 18.55 18.55 20.13 16.76 19.77C15.74 19.57 14.7 20 14.13 20.86C13.12 22.38 10.89 22.38 9.88 20.86C9.3 20 8.26 19.56 7.24 19.77C5.45 20.13 3.87 18.55 4.23 16.76C4.43 15.74 4 14.7 3.14 14.13C1.62 13.12 1.62 10.89 3.14 9.88C4 9.3 4.44 8.26 4.23 7.24C3.87 5.45 5.45 3.87 7.24 4.23C8.26 4.44 9.3 4 9.87 3.14C10.88 1.62 13.11 1.62 14.12 3.14C14.7 4 15.74 4.44 16.76 4.23C18.55 3.87 20.13 5.45 19.77 7.24C19.56 8.26 20 9.3 20.86 9.87C22.38 10.88 22.38 13.12 20.86 14.13Z\" undefined=\"1\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M12 8V13\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M12 15.99V16.01\"></path>\n</svg>\n</span>\n<p class=\"custom-quote-title\">注意</p>\n<ul>\n<li>尽管抽象成员必须在派生类中用相应的成员覆写，但不能把virtual修饰符附加到abstract修饰符</li>\n<li>类似于虚成员，派生类中抽象成员的实现必须指定override修饰符</li>\n</ul>\n\n</div>\n<p><img src=\"https://cbaoblog.oss-cn-shanghai.aliyuncs.com/img/QQ%E6%88%AA%E5%9B%BE20230322210944.png\" alt=\"QQ截图20230322210944\"></p>\n<h2 id=\"抽象类\"><a href=\"#抽象类\" class=\"headerlink\" title=\"抽象类\"></a>抽象类</h2><p>抽象类是指设计为被继承的类。抽象类只能被用作其它类的基类</p>\n<ul>\n<li><p>不能创建抽象类实例</p>\n</li>\n<li><p>抽象类使用abstract修饰符声明</p>\n<pre class=\"line-numbers language-c#\" data-language=\"c#\"><code class=\"language-c#\">abstract class Test\n&#123;\n\n&#125;<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span></span></code></pre></li>\n<li><p>抽象类可以包含抽象成员或普通的非抽象成员，抽象类的成员可以是抽象成员和普通带实现的成员的任意组合</p>\n</li>\n<li><p>抽象类自己可以派生自另一个抽象类。</p>\n</li>\n<li><p>任何派生自抽象类的类必须使用override关键字实现该类所有的抽象成员，除非派生类自己也是抽象类</p>\n</li>\n</ul>\n<h2 id=\"密封类\"><a href=\"#密封类\" class=\"headerlink\" title=\"密封类\"></a>密封类</h2><ul>\n<li>密封类只能被用作独立的类，不能被用作基类（与抽象类相反，抽象类只能用作基类）</li>\n<li>密封类使用sealed修饰符标注</li>\n</ul>\n<pre class=\"line-numbers language-c#\" data-language=\"c#\"><code class=\"language-c#\">&#x2F;&#x2F;密封类\nsealed class Test\n&#123;\n    \n&#125;<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<h2 id=\"静态类\"><a href=\"#静态类\" class=\"headerlink\" title=\"静态类\"></a>静态类</h2><ul>\n<li>静态中所有成员都是静态的</li>\n<li>静态类用于存放不受实例数据影响的数据和函数</li>\n<li>类本身必须标记为static</li>\n<li>类的所有成员必须是静态的</li>\n<li>类可以有一个静态构造函数，但不能有实例构造函数，因为不能创建该类的实例</li>\n<li>静态类是隐式密封的，不能够继承静态类</li>\n<li>可以使用类名和成员名，像访问其它静态成员那样访问静态类成员</li>\n</ul>\n<pre class=\"line-numbers language-c#\" data-language=\"c#\"><code class=\"language-c#\">&#x2F;&#x2F;静态类\nstatic class Test\n&#123;\n    static Test()\n    &#123;\n        val &#x3D; 10;\n    &#125;\n    public static int val;\n    public static void PrintfMe()\n    &#123;\n        Console.WriteLine(&quot;My is static class&quot;);\n    &#125;\n&#125;<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<h2 id=\"拓展方法\"><a href=\"#拓展方法\" class=\"headerlink\" title=\"拓展方法\"></a>拓展方法</h2><h3 id=\"为一个类添加方法的几种方式\"><a href=\"#为一个类添加方法的几种方式\" class=\"headerlink\" title=\"为一个类添加方法的几种方式\"></a>为一个类添加方法的几种方式</h3><ul>\n<li><p>如果有源代码并可以修改这个类，只需要为这个类增加一个新方法</p>\n</li>\n<li><p>如果不能修改这个类，但是这个类不是密封的，可以将这个类作为基类在派生类中添加一个新方法</p>\n</li>\n<li><p>如果这个类是密封类</p>\n<ul>\n<li><p>用一个静态类，在静态类中写一个新方法给这个类使用（不推荐）</p>\n</li>\n<li><p>使用拓展方法（推荐使用）</p>\n<pre class=\"line-numbers language-c#\" data-language=\"c#\"><code class=\"language-c#\">class Test\n&#123;\n    public Test(int val1, int val2)\n    &#123;\n        Val1 &#x3D; val1;\n        Val2 &#x3D; val2;\n    &#125;\n    public int Val1 &#123; get; set; &#125;\n    public int Val2 &#123; get; set; &#125;\n    \n    public int Sum() &#123; return Val1 + Val2; &#125;\n    \n&#125;\n    \nstatic class ExtendTest\n&#123;\n    &#x2F;&#x2F;为Test类添加一个拓展方法\n    public static double Average(this Test t1)\n    &#123;\n        return t1.Sum() &#x2F; 2.0f;\n    &#125;\n&#125;\n    \nclass Program\n&#123;\n    static void Main()\n    &#123;\n        Test t1 &#x3D; new Test(10, 20);\n        &#x2F;&#x2F;直接用该类调用该拓展方法\n        Console.WriteLine(t1.Average());\n    &#125;\n    \n&#125;<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li>\n</ul>\n</li>\n<li><p>拓展方法的要求</p>\n<ul>\n<li>声明拓展方法的类必须声明为static</li>\n<li>拓展方法本身必须声明为static</li>\n<li>拓展方法必须包含关键字this作为它的第一个参数类型，并在后面跟着它的拓展的类的名称<img src=\"https://cbaoblog.oss-cn-shanghai.aliyuncs.com/img/QQ%E6%88%AA%E5%9B%BE20230322215107.png\" alt=\"QQ截图20230322215107\"></li>\n</ul>\n</li>\n</ul>\n<h2 id=\"命名约定\"><a href=\"#命名约定\" class=\"headerlink\" title=\"命名约定\"></a>命名约定<img src=\"https://cbaoblog.oss-cn-shanghai.aliyuncs.com/img/QQ%E6%88%AA%E5%9B%BE20230322215428.png\" alt=\"QQ截图20230322215428\"></h2><h1 id=\"表达式和运算符\"><a href=\"#表达式和运算符\" class=\"headerlink\" title=\"表达式和运算符\"></a>表达式和运算符</h1><h2 id=\"运算符\"><a href=\"#运算符\" class=\"headerlink\" title=\"运算符\"></a>运算符</h2><p>运算符是一个符号</p>\n<ul>\n<li>将操作数作为输入（操作数是指作为运算符输入的数据元素）</li>\n<li>执行某个操作</li>\n<li>基于该操作返回一个值</li>\n</ul>\n<h2 id=\"字面量\"><a href=\"#字面量\" class=\"headerlink\" title=\"字面量\"></a>字面量</h2><p>字面量是源代码中键入的数字或字符串，表示一个指定类型的明确的，固定的值</p>\n<ul>\n<li><p>float字面量结尾要加上一个f</p>\n<pre class=\"line-numbers language-c#\" data-language=\"c#\"><code class=\"language-c#\">float f1&#x3D;12.5f;<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span></span></code></pre></li>\n<li><p>bool有两个字面量：true和false</p>\n</li>\n<li><p>对于引用类型变量，字面量null表示变量没有指向内存中的数据</p>\n</li>\n</ul>\n<h3 id=\"整数字面量\"><a href=\"#整数字面量\" class=\"headerlink\" title=\"整数字面量\"></a>整数字面量</h3><p>整数字面量是最常用的字面量，它们被书写为十进制数字序列</p>\n<ul>\n<li><p>没有小数点</p>\n</li>\n<li><p>带有可选的后缀，指明整数的类型</p>\n<pre class=\"line-numbers language-c#\" data-language=\"c#\"><code class=\"language-c#\">234&#x2F;&#x2F;整型\n236L&#x2F;&#x2F;长整型\n236U&#x2F;&#x2F;无符号整型\n236UL&#x2F;&#x2F;无符号长整形<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span></span></code></pre></li>\n<li><p>整数类型字面量还可以写成十六进制（hex）形式，数字必须是十六进制数（0到F），且字符串必须以0x或0X开始</p>\n</li>\n<li><p>整数类型字面量的第三种格式是二进制计法，所有数字必须是0或1，且以0b或者0B开始</p>\n</li>\n</ul>\n<p><img src=\"https://cbaoblog.oss-cn-shanghai.aliyuncs.com/img/QQ%E6%88%AA%E5%9B%BE20230322235111.png\" alt=\"QQ截图20230322235111\"></p>\n<h3 id=\"实数字面量\"><a href=\"#实数字面量\" class=\"headerlink\" title=\"实数字面量\"></a>实数字面量</h3><p>C#有三种实数数据类型：float，double，decimal</p>\n<p><img src=\"https://cbaoblog.oss-cn-shanghai.aliyuncs.com/img/QQ%E6%88%AA%E5%9B%BE20230323204051.png\" alt=\"QQ截图20230323204051\"></p>\n<h3 id=\"字符字面量\"><a href=\"#字符字面量\" class=\"headerlink\" title=\"字符字面量\"></a>字符字面量</h3><p>字符字面量由两个单引号内的字符组成。字符字面量用于表示单个字符（a），非打印字符（\\n），或执行特殊任务的字符</p>\n<ul>\n<li>字符字面量的类型是char</li>\n<li>简单转义序列是一个反斜杠后面跟着单个字符</li>\n<li>十六进制转义序列是一个反斜杠后面跟着一个大写或小写的x，再跟着4个十六进制数字</li>\n<li>Unicode转义序列是一个反斜杠后面跟着一个大写或小写的u，再跟着4个十六进制数字</li>\n</ul>\n<p><img src=\"https://cbaoblog.oss-cn-shanghai.aliyuncs.com/img/QQ%E6%88%AA%E5%9B%BE20230323210315.png\" alt=\"QQ截图20230323210315\"></p>\n<p><img src=\"https://cbaoblog.oss-cn-shanghai.aliyuncs.com/img/QQ%E6%88%AA%E5%9B%BE20230323210325.png\" alt=\"QQ截图20230323210325\"></p>\n<h3 id=\"字符串字面量\"><a href=\"#字符串字面量\" class=\"headerlink\" title=\"字符串字面量\"></a>字符串字面量</h3><p>字符串字面量使用双引号标记，不同于字符字面量使用单引号。</p>\n<p>有两种字符串字面量类型：</p>\n<ul>\n<li>常规字符串字面量<ul>\n<li>常规字符串字面量由双引号内的字符序列组成</li>\n<li>可以包含字符，简单转义序列，十六进制和Unicode转义序列</li>\n</ul>\n</li>\n<li>逐字字符串字面量<ul>\n<li>逐字字符串的字面量的书写如同常规字符串字面量，以@字符为前缀</li>\n<li>逐字字符串字面量和常规字符串字面量的区别在于字符串中的转义序列不会被求值，再双引号中间的内容会全部被打印</li>\n<li>逐字字符串字面量的唯一例外是相邻的双引号组，会被解释成单个双引号字符</li>\n</ul>\n</li>\n</ul>\n<div class=\"custom-quote warning\">\n<span class=\"custom-quote-svg\"><svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"\" xmlns=\"http://www.w3.org/2000/svg\" data-reactroot=\"\">\n<path fill=\"\" d=\"M20.86 14.13C20 14.7 19.56 15.74 19.77 16.76C20.13 18.55 18.55 20.13 16.76 19.77C15.74 19.57 14.7 20 14.13 20.86C13.12 22.38 10.89 22.38 9.88 20.86C9.3 20 8.26 19.56 7.24 19.77C5.45 20.13 3.87 18.55 4.23 16.76C4.43 15.74 4 14.7 3.14 14.13C1.62 13.12 1.62 10.89 3.14 9.88C4 9.3 4.44 8.26 4.23 7.24C3.87 5.45 5.45 3.87 7.24 4.23C8.26 4.44 9.3 4 9.87 3.14C10.88 1.62 13.11 1.62 14.12 3.14C14.7 4 15.74 4.44 16.76 4.23C18.55 3.87 20.13 5.45 19.77 7.24C19.56 8.26 20 9.3 20.86 9.87C22.38 10.88 22.38 13.12 20.86 14.13Z\" undefined=\"1\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M12 8V13\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M12 15.99V16.01\"></path>\n</svg>\n</span>\n<p class=\"custom-quote-title\">注意</p>\n<p><p>​    编译器让相同的字符串字面量共享堆中同一内存位置以节约内存</p>\n</p>\n</div>\n<h3 id=\"求值顺序\"><a href=\"#求值顺序\" class=\"headerlink\" title=\"求值顺序\"></a>求值顺序</h3><ul>\n<li>优先级</li>\n</ul>\n<p><img src=\"https://cbaoblog.oss-cn-shanghai.aliyuncs.com/img/QQ%E6%88%AA%E5%9B%BE20230323211939.png\" alt=\"QQ截图20230323211939\"></p>\n<ul>\n<li>结合性<ul>\n<li>左结合运算符从左至右求值</li>\n<li>右结合运算符从右至左求值</li>\n<li>除赋值运算符以外，其它二元运算符是左结合的</li>\n<li>赋值运算符和条件运算符是右结合的</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"比较操作和相等性操作\"><a href=\"#比较操作和相等性操作\" class=\"headerlink\" title=\"比较操作和相等性操作\"></a>比较操作和相等性操作</h3><p>对于大多数引用类型来说，比较它们的相等性时，只比较它们的引用</p>\n<ul>\n<li>如果引用相等，说明指向相同的对象，那么相等性比较为true，这称为浅比较</li>\n<li>string类型对象也是引用类型，但它的比较方式不同，比较字符串的相等性时，将比较它们的长度和内容<ul>\n<li>如果两个字符串有相同的长度和内容（区分大小写），那么相等性为true即使占用不同的内存区域</li>\n<li>称为深比较</li>\n</ul>\n</li>\n</ul>\n<div class=\"custom-quote warning\">\n<span class=\"custom-quote-svg\"><svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"\" xmlns=\"http://www.w3.org/2000/svg\" data-reactroot=\"\">\n<path fill=\"\" d=\"M20.86 14.13C20 14.7 19.56 15.74 19.77 16.76C20.13 18.55 18.55 20.13 16.76 19.77C15.74 19.57 14.7 20 14.13 20.86C13.12 22.38 10.89 22.38 9.88 20.86C9.3 20 8.26 19.56 7.24 19.77C5.45 20.13 3.87 18.55 4.23 16.76C4.43 15.74 4 14.7 3.14 14.13C1.62 13.12 1.62 10.89 3.14 9.88C4 9.3 4.44 8.26 4.23 7.24C3.87 5.45 5.45 3.87 7.24 4.23C8.26 4.44 9.3 4 9.87 3.14C10.88 1.62 13.11 1.62 14.12 3.14C14.7 4 15.74 4.44 16.76 4.23C18.55 3.87 20.13 5.45 19.77 7.24C19.56 8.26 20 9.3 20.86 9.87C22.38 10.88 22.38 13.12 20.86 14.13Z\" undefined=\"1\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M12 8V13\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M12 15.99V16.01\"></path>\n</svg>\n</span>\n<p class=\"custom-quote-title\">注意</p>\n<p>​    一般引用类型比较的是引用，不是值</p>\n\n</div>\n<h3 id=\"递增和递减运算符\"><a href=\"#递增和递减运算符\" class=\"headerlink\" title=\"递增和递减运算符\"></a>递增和递减运算符</h3><p><img src=\"https://cbaoblog.oss-cn-shanghai.aliyuncs.com/img/QQ%E6%88%AA%E5%9B%BE20230323214112.png\" alt=\"QQ截图20230323214112\"></p>\n<ul>\n<li>前置递增和递减是先自增或自减后运算</li>\n<li>后置递增和递减是先运算后自增或自减</li>\n</ul>\n<h3 id=\"条件逻辑运算符\"><a href=\"#条件逻辑运算符\" class=\"headerlink\" title=\"条件逻辑运算符\"></a>条件逻辑运算符</h3><p><img src=\"https://cbaoblog.oss-cn-shanghai.aliyuncs.com/img/QQ%E6%88%AA%E5%9B%BE20230323214853.png\" alt=\"QQ截图20230323214853\"></p>\n<ul>\n<li>条件运算符使用“短路”模式操作，所以不要在第二个表达式中放置带副作用的表达式，因为可能不执行</li>\n</ul>\n<h3 id=\"逻辑运算符\"><a href=\"#逻辑运算符\" class=\"headerlink\" title=\"逻辑运算符\"></a>逻辑运算符</h3><p><img src=\"https://cbaoblog.oss-cn-shanghai.aliyuncs.com/img/QQ%E6%88%AA%E5%9B%BE20230323220557.png\" alt=\"QQ截图20230323220557\"></p>\n<h3 id=\"用户定义的类型转换\"><a href=\"#用户定义的类型转换\" class=\"headerlink\" title=\"用户定义的类型转换\"></a>用户定义的类型转换</h3><ul>\n<li><p>可以为自己的类和结构定义隐式转换和显示转换</p>\n</li>\n<li><p>C#提供隐式转换和显示转换</p>\n<ul>\n<li>对于隐式转换，当决定在特定上下文中使用特定类型时，如有必要，编译器会自动执行转换</li>\n<li>对于显示转换，编译器只在使用显示转换运算符时才执行转换</li>\n</ul>\n</li>\n<li><p>声明隐式转换的语法</p>\n<p><img src=\"https://cbaoblog.oss-cn-shanghai.aliyuncs.com/img/QQ%E6%88%AA%E5%9B%BE20230323223822.png\" alt=\"QQ截图20230323223822\"></p>\n</li>\n<li><p>声明显示转换的语法只是将implicit替换成explicit</p>\n</li>\n</ul>\n<h2 id=\"运算符重载\"><a href=\"#运算符重载\" class=\"headerlink\" title=\"运算符重载\"></a>运算符重载</h2><ul>\n<li>运算符重载只能用于类和结构</li>\n<li>一元运算符的重载方法带一个单独的class或struct类型的参数</li>\n<li>二元运算符的重载方法带两个参数，其中必须有一个是class或者struct类型</li>\n<li>声明必须同时使用public和static的修饰符</li>\n<li>运算符必须是要操作的类或者结构的成员</li>\n</ul>\n<pre class=\"line-numbers language-c#\" data-language=\"c#\"><code class=\"language-c#\">&#x2F;&#x2F;重载加法运算符\npublic static Test operator +(Test t, int i)\n&#123;\n    Test t1&#x3D;new Test();\n    t1.val &#x3D; t1.val + i;\n    return t1;\n&#125;<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<div class=\"custom-quote warning\">\n<span class=\"custom-quote-svg\"><svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"\" xmlns=\"http://www.w3.org/2000/svg\" data-reactroot=\"\">\n<path fill=\"\" d=\"M20.86 14.13C20 14.7 19.56 15.74 19.77 16.76C20.13 18.55 18.55 20.13 16.76 19.77C15.74 19.57 14.7 20 14.13 20.86C13.12 22.38 10.89 22.38 9.88 20.86C9.3 20 8.26 19.56 7.24 19.77C5.45 20.13 3.87 18.55 4.23 16.76C4.43 15.74 4 14.7 3.14 14.13C1.62 13.12 1.62 10.89 3.14 9.88C4 9.3 4.44 8.26 4.23 7.24C3.87 5.45 5.45 3.87 7.24 4.23C8.26 4.44 9.3 4 9.87 3.14C10.88 1.62 13.11 1.62 14.12 3.14C14.7 4 15.74 4.44 16.76 4.23C18.55 3.87 20.13 5.45 19.77 7.24C19.56 8.26 20 9.3 20.86 9.87C22.38 10.88 22.38 13.12 20.86 14.13Z\" undefined=\"1\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M12 8V13\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M12 15.99V16.01\"></path>\n</svg>\n</span>\n<p class=\"custom-quote-title\">注意</p>\n<p><p>​    重载运算符应该符合运算符的直观含义</p>\n</p>\n</div>\n<ul>\n<li>运算符重载的限制<ul>\n<li>运算符重载不能创建新运算符</li>\n<li>不能改变运算符语法</li>\n<li>不能重新定义运算符如何处理预定义类型</li>\n<li>不能改变运算符的优先级和结合性</li>\n</ul>\n</li>\n</ul>\n<p><img src=\"https://cbaoblog.oss-cn-shanghai.aliyuncs.com/img/QQ%E6%88%AA%E5%9B%BE20230329211349.png\" alt=\"QQ截图20230329211349\"></p>\n<ul>\n<li>重载递增递减运算符<ul>\n<li>前置<ul>\n<li>在对象上执行递增递减代码</li>\n<li>返回对象</li>\n</ul>\n</li>\n<li>后置<ul>\n<li>如果对象是值类型，系统复制该对象，如果对象是引用类型，则引用会被复制</li>\n<li>在对象上执行递增或递减</li>\n<li>返回保存的操作数</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n<div class=\"custom-quote warning\">\n<span class=\"custom-quote-svg\"><svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"\" xmlns=\"http://www.w3.org/2000/svg\" data-reactroot=\"\">\n<path fill=\"\" d=\"M20.86 14.13C20 14.7 19.56 15.74 19.77 16.76C20.13 18.55 18.55 20.13 16.76 19.77C15.74 19.57 14.7 20 14.13 20.86C13.12 22.38 10.89 22.38 9.88 20.86C9.3 20 8.26 19.56 7.24 19.77C5.45 20.13 3.87 18.55 4.23 16.76C4.43 15.74 4 14.7 3.14 14.13C1.62 13.12 1.62 10.89 3.14 9.88C4 9.3 4.44 8.26 4.23 7.24C3.87 5.45 5.45 3.87 7.24 4.23C8.26 4.44 9.3 4 9.87 3.14C10.88 1.62 13.11 1.62 14.12 3.14C14.7 4 15.74 4.44 16.76 4.23C18.55 3.87 20.13 5.45 19.77 7.24C19.56 8.26 20 9.3 20.86 9.87C22.38 10.88 22.38 13.12 20.86 14.13Z\" undefined=\"1\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M12 8V13\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M12 15.99V16.01\"></path>\n</svg>\n</span>\n<p class=\"custom-quote-title\">注意</p>\n<ul>\n<li>对于值类型参数，重载递增和递减运算符没有一点问题</li>\n<li>对于引用类型参数，重载递增递减运算符时<ul>\n<li>重载前置运算符操作没有问题</li>\n<li>重载后置操作时，原始引用和引用副本指向相同的对象</li>\n</ul>\n</li>\n</ul>\n\n</div>\n<h2 id=\"typeof运算符\"><a href=\"#typeof运算符\" class=\"headerlink\" title=\"typeof运算符\"></a>typeof运算符</h2><p>typeof运算符返回作为其参数的任何类型的System.Type对象，通过该对象可以了解类的特征</p>\n<ul>\n<li>不能重载typeof运算符</li>\n<li>typeof是一元运算符</li>\n<li>GetType方法也会调用typeof运算符</li>\n</ul>\n<h2 id=\"nameof运算符\"><a href=\"#nameof运算符\" class=\"headerlink\" title=\"nameof运算符\"></a>nameof运算符</h2><p>nameof运算符返回一个表示传入参数的字符串</p>\n<h1 id=\"语句\"><a href=\"#语句\" class=\"headerlink\" title=\"语句\"></a>语句</h1><p>C#中的语句跟C/C++中的语句非常类似</p>\n<ul>\n<li>语句是描述某个类型或让程序执行某个动作的源代码指令</li>\n<li>语句的类型<ul>\n<li>声明语句：声明类型或变量</li>\n<li>嵌入语句：执行动作或管理控制流</li>\n<li>标签语句：控制跳转</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"控制流语句\"><a href=\"#控制流语句\" class=\"headerlink\" title=\"控制流语句\"></a>控制流语句</h2><ul>\n<li><p>条件执行语句</p>\n<ul>\n<li><p>if</p>\n<pre class=\"line-numbers language-c#\" data-language=\"c#\"><code class=\"language-c#\">&#x2F;&#x2F;TestExpr必须计算成bool型值\n&#x2F;&#x2F;如果为true执行\nif(TestExpr)\n&#123;\n\t&#x2F;&#x2F;执行语句\n&#125;<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<p><img src=\"https://cbaoblog.oss-cn-shanghai.aliyuncs.com/img/QQ%E6%88%AA%E5%9B%BE20230401170557.png\" alt=\"QQ截图20230401170557\"></p>\n</li>\n<li><p>if…else</p>\n<pre class=\"line-numbers language-c#\" data-language=\"c#\"><code class=\"language-c#\">&#x2F;&#x2F;如果TestExpr为true执行语句1，否则执行语句二\nif(TestExpr)\n&#123;\n\t&#x2F;&#x2F;执行语句1\n&#125;\nelse\n&#123;\n\t&#x2F;&#x2F;执行语句2\n&#125;<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<p><img src=\"https://cbaoblog.oss-cn-shanghai.aliyuncs.com/img/QQ%E6%88%AA%E5%9B%BE20230401170857.png\" alt=\"QQ截图20230401170857\"></p>\n</li>\n<li><p>switch</p>\n<pre class=\"line-numbers language-c#\" data-language=\"c#\"><code class=\"language-c#\">int test &#x3D; 11;\nswitch (test)\n&#123;\n    case 0:\n        Console.WriteLine(0);\n        break;\n    case 1:\n        Console.WriteLine(1);\n        break;\n    case 2:\n        Console.WriteLine(2);\n        break;\n    case 3:\n        Console.WriteLine(3);\n        break;\n    default:\n        Console.WriteLine(&quot;可选&quot;);\n        break;\n&#125;\n\n&#x2F;&#x2F;注意\n&#x2F;&#x2F;case后的表达式可以是任何类型的模式（C#7.0之后）\n&#x2F;&#x2F;C#中不可以执行一个switch段中的代码再直接执行下一个switch段，除非没有插入可执行语句\n&#x2F;&#x2F;case 1:\n&#x2F;&#x2F;case 2:<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li>\n</ul>\n</li>\n<li><p>循环语句重复执行一个代码片段</p>\n<ul>\n<li><p>while</p>\n<pre class=\"line-numbers language-c#\" data-language=\"c#\"><code class=\"language-c#\">&#x2F;&#x2F;首先对TestExpr求值只要不为false就会一直执行循环体\nwhile(TestExpr)\n&#123;\n\t&#x2F;&#x2F;循环体\n&#125;<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span></span></code></pre></li>\n<li><p>do</p>\n<pre class=\"line-numbers language-c#\" data-language=\"c#\"><code class=\"language-c#\">&#x2F;&#x2F;do循环至少执行一次循环体\nint a &#x3D; 0;\ndo\n&#123;\n    Console.WriteLine(a++);\n&#125; while (a &lt;&#x3D; 10);&#x2F;&#x2F;注意此处有个分号<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li>\n<li><p>for</p>\n<pre class=\"line-numbers language-c#\" data-language=\"c#\"><code class=\"language-c#\">&#x2F;&#x2F;在for循环的开始执行一次Initializar\n&#x2F;&#x2F;然后对TestExpr求值\n&#x2F;&#x2F;如果返回true执行Statement，接着执行IterationExpr\nfor(Initializar;TestExpr;IterationExpr)\n&#123;\n    &#x2F;&#x2F;Statement\n&#125;<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li>\n<li><p>foreach</p>\n</li>\n</ul>\n</li>\n<li><p>跳转语句把控制流从一个代码片段改变到另一个代码片段中的指定语句</p>\n<ul>\n<li>break<ul>\n<li>用在循环语句中，跳出最内层循环</li>\n</ul>\n</li>\n<li>continue<ul>\n<li>结束当前循环，执行下一次循环</li>\n</ul>\n</li>\n<li>return<ul>\n<li>将控制权返回到调用函数的成员，且能返回一个值</li>\n</ul>\n</li>\n<li>goto<ul>\n<li>不推荐使用该语句，所以直接放弃</li>\n</ul>\n</li>\n<li>throw</li>\n</ul>\n</li>\n</ul>\n<h1 id=\"结构\"><a href=\"#结构\" class=\"headerlink\" title=\"结构\"></a>结构</h1><p>结构是程序员定义的数据类型，与类非常相似</p>\n<ul>\n<li><p>类是引用类型，结构是值类型</p>\n</li>\n<li><p>结构是隐式密封的，所以不能从结构派生其它结构</p>\n</li>\n<li><p>语法</p>\n<pre class=\"line-numbers language-c#\" data-language=\"c#\"><code class=\"language-c#\">struct StructName\n&#123;\n    &#x2F;&#x2F;成员\n&#125;c<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span></span></code></pre></li>\n</ul>\n<h2 id=\"结构是值类型\"><a href=\"#结构是值类型\" class=\"headerlink\" title=\"结构是值类型\"></a>结构是值类型</h2><p>和所有值类型一样，结构类型变量含有自己的数据</p>\n<ul>\n<li>结构类型的变量不能为null</li>\n<li>两个结构变量不能引用同一对象</li>\n</ul>\n<p><img src=\"https://cbaoblog.oss-cn-shanghai.aliyuncs.com/img/QQ%E6%88%AA%E5%9B%BE20230405222047.png\" alt=\"QQ截图20230405222047\"></p>\n<h2 id=\"对结构赋值\"><a href=\"#对结构赋值\" class=\"headerlink\" title=\"对结构赋值\"></a>对结构赋值</h2><ul>\n<li><p>把一个结构赋值给另一个结构，就是将一个结构的值复制给另一个结构，和复制类变量不同，复制类变量时只复制引用</p>\n<p><img src=\"https://cbaoblog.oss-cn-shanghai.aliyuncs.com/img/QQ%E6%88%AA%E5%9B%BE20230405222403.png\" alt=\"QQ截图20230405222403\"></p>\n</li>\n</ul>\n<h2 id=\"构造函数和析构函数\"><a href=\"#构造函数和析构函数\" class=\"headerlink\" title=\"构造函数和析构函数\"></a>构造函数和析构函数</h2><ul>\n<li>结构可以有实例构造函数和静态构造函数，但不允许有析构函数</li>\n<li>C#语言隐式的为每个结构提供一个无参数的构造函数（该构造函数把结构的每个成员设置为该类型的默认值，值成员设置成默认值，引用成员设置成null）</li>\n<li>调用一个构造函数，包括无参构造函数，要使用new运算符</li>\n<li>对于每个结构都存在无参数的构造函数，且不能删除或重定义（结构不能声明无参构造函数）</li>\n</ul>\n<div class=\"custom-quote warning\">\n<span class=\"custom-quote-svg\"><svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"\" xmlns=\"http://www.w3.org/2000/svg\" data-reactroot=\"\">\n<path fill=\"\" d=\"M20.86 14.13C20 14.7 19.56 15.74 19.77 16.76C20.13 18.55 18.55 20.13 16.76 19.77C15.74 19.57 14.7 20 14.13 20.86C13.12 22.38 10.89 22.38 9.88 20.86C9.3 20 8.26 19.56 7.24 19.77C5.45 20.13 3.87 18.55 4.23 16.76C4.43 15.74 4 14.7 3.14 14.13C1.62 13.12 1.62 10.89 3.14 9.88C4 9.3 4.44 8.26 4.23 7.24C3.87 5.45 5.45 3.87 7.24 4.23C8.26 4.44 9.3 4 9.87 3.14C10.88 1.62 13.11 1.62 14.12 3.14C14.7 4 15.74 4.44 16.76 4.23C18.55 3.87 20.13 5.45 19.77 7.24C19.56 8.26 20 9.3 20.86 9.87C22.38 10.88 22.38 13.12 20.86 14.13Z\" undefined=\"1\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M12 8V13\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M12 15.99V16.01\"></path>\n</svg>\n</span>\n<p class=\"custom-quote-title\">注意</p>\n<p><p>​    对于类，编译器只在没有声明其它构造函数时提供隐式的无参构造函数</p>\n</p>\n</div>\n<ul>\n<li><p>使用new运算符创建结构的实例</p>\n<pre class=\"line-numbers language-c#\" data-language=\"c#\"><code class=\"language-c#\">struct MyTestStruct\n&#123;\n    public int Test;\n&#125;\n\nclass Test\n&#123;\n    static void Main()\n    &#123;\n        MyTestStruct m1 &#x3D; new MyTestStruct();\n\n\n    &#125;\n&#125;<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li>\n<li><p>不使用new运算符创建结构的实例</p>\n<ul>\n<li>必须在显示设置数据成员之后，才能使用它们的值</li>\n<li>在对所有数据成员赋值之后，才能调用结构的函数成员</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"静态构造函数-1\"><a href=\"#静态构造函数-1\" class=\"headerlink\" title=\"静态构造函数\"></a>静态构造函数</h2><p>与类相似，结构的静态构造函数创建并初始化静态数据成员，且不能引用实例成员</p>\n<ul>\n<li>结构的静态构造函数遵从与类的静态构造函数一样的规则，但允许有不带参数的静态构造函数（实例构造函数必须要有形参）</li>\n<li>以下两种行为，会调用静态构造函数<ul>\n<li>调用显式声明的构造函数</li>\n<li>引用结构的静态成员</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"结构的构造函数和析构函数小结\"><a href=\"#结构的构造函数和析构函数小结\" class=\"headerlink\" title=\"结构的构造函数和析构函数小结\"></a>结构的构造函数和析构函数小结</h2><p><img src=\"https://cbaoblog.oss-cn-shanghai.aliyuncs.com/img/QQ%E6%88%AA%E5%9B%BE20230405224552.png\" alt=\"QQ截图20230405224552\"></p>\n<h2 id=\"属性和字段初始化语句\"><a href=\"#属性和字段初始化语句\" class=\"headerlink\" title=\"属性和字段初始化语句\"></a>属性和字段初始化语句</h2><p>在声明结构时，不允许使用实例属性和字段初始化语句，但是静态属性和静态字段都可以在声明结构体时进行初始化</p>\n<pre class=\"line-numbers language-c#\" data-language=\"c#\"><code class=\"language-c#\">struct MyTestStruct\n&#123;\n    &#x2F;&#x2F;静态字段可以在声明时进行初始化\n    public static int B&#x3D;20;\n    &#x2F;&#x2F;静态属性可以在声明时进行初始化\n    public static int A &#123; get; set; &#125; &#x3D; 30;\n\n    &#x2F;&#x2F;不允许使用实例属性和字段初始化语句\n    &#x2F;&#x2F;public int Test&#x3D;30;\n&#125;<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<h2 id=\"结构是密封的\"><a href=\"#结构是密封的\" class=\"headerlink\" title=\"结构是密封的\"></a>结构是密封的</h2><ul>\n<li>结构总是隐式密封的，因此，不能从它们派生其它结构</li>\n<li>不能用于结构的修饰符<ul>\n<li>protected</li>\n<li>protected internal</li>\n<li>abstruct</li>\n<li>sealed</li>\n<li>virtual</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"装箱和拆箱\"><a href=\"#装箱和拆箱\" class=\"headerlink\" title=\"装箱和拆箱\"></a>装箱和拆箱</h2><ul>\n<li>如同其它值类型数据，如果想将一个结构的实例作为引用类型对象，必须创建装箱的副本</li>\n<li>装箱的过程就是制作值类型变量的引用类型副本</li>\n</ul>\n<h2 id=\"结构作为返回值和参数\"><a href=\"#结构作为返回值和参数\" class=\"headerlink\" title=\"结构作为返回值和参数\"></a>结构作为返回值和参数</h2><p>结构可以作为返回值和参数</p>\n<ul>\n<li>返回值：当作为返回值时，将创建它的副本并从函数成员返回</li>\n<li>值参数（形参列表）：当结构被用作值参数时，将创建实参结构的副本，该副本用于方法的执行</li>\n<li>ref和out参数：如果把一个结构用作ref或out参数，传入方法的是该结构的引用，形参会影响实参</li>\n</ul>\n<h2 id=\"结构的其它内容\"><a href=\"#结构的其它内容\" class=\"headerlink\" title=\"结构的其它内容\"></a>结构的其它内容</h2><ul>\n<li>对结构的分配的开销比创建类实例小，使用结构代替类有时可以提高性能，但要注意装箱和拆箱的高昂代价</li>\n<li>预定义简单类型（int，short，long,…）在.NET和C#中被视作原始类型，但实际上在.NET中都实现为结构</li>\n<li>可以使用与声明分部</li>\n</ul>\n<h1 id=\"枚举\"><a href=\"#枚举\" class=\"headerlink\" title=\"枚举\"></a>枚举</h1><p>枚举是由程序员定义的类型</p>\n<ul>\n<li><p>与结构一样，枚举是值类型，因此是直接存储它们的数据，而不是分开存储成引用和数据</p>\n</li>\n<li><p>枚举只有一种类型的成员：命名的整数值常量</p>\n</li>\n<li><p>枚举成员声明列表使用逗号分隔，没有分号</p>\n<pre class=\"line-numbers language-c#\" data-language=\"c#\"><code class=\"language-c#\">enum TrafficLight\n&#123;\n    Red,\n    Green,\n    Yello\n&#125;<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li>\n<li><p>每个枚举成员都有一个底层整数类型，默认为int</p>\n</li>\n<li><p>在默认情况下，编译器为第一个成员赋值为0，对后续每个成员赋的值都比前一个成员多1</p>\n</li>\n</ul>\n<h2 id=\"设置底层类型和显式值\"><a href=\"#设置底层类型和显式值\" class=\"headerlink\" title=\"设置底层类型和显式值\"></a>设置底层类型和显式值</h2><ul>\n<li><p>可以把冒号和类型名放在枚举名之后，这样可以使用int以外的整数类型</p>\n<pre class=\"line-numbers language-c#\" data-language=\"c#\"><code class=\"language-c#\">enum TrafficLight : ulong\n&#123;\n    Red &#x3D; 100000000000,&#x2F;&#x2F;此处使用的是ulong类型\n    Green,\n    Yello\n&#125;<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li>\n</ul>\n<h2 id=\"位标记\"><a href=\"#位标记\" class=\"headerlink\" title=\"位标记\"></a>位标记</h2><p>//请参考书籍</p>\n<h2 id=\"关于枚举的更多内容\"><a href=\"#关于枚举的更多内容\" class=\"headerlink\" title=\"关于枚举的更多内容\"></a>关于枚举的更多内容</h2><ul>\n<li><p>枚举只有单一的成员类型：声明的成员常量</p>\n</li>\n<li><p>不能对成员使用修饰符，它们都是隐式的具有和枚举相同的可访问性</p>\n</li>\n<li><p>由于成员是静态的，即使没有该枚举类型的变量也可以访问</p>\n</li>\n<li><p>.NET Enum类型（enum就是基于该类型）中的一些静态方法</p>\n<ul>\n<li><p>GetName方法以一个枚举类型对象和一个整数为参数，返回相应的枚举成员名称</p>\n<pre class=\"line-numbers language-c#\" data-language=\"c#\"><code class=\"language-c#\">enum TrafficLight\n&#123;\n    Red,\n    Green,\n    Yello\n&#125;\n\nclass Test\n&#123;\n    static void Main()\n    &#123;\n        TrafficLight tra &#x3D; TrafficLight.Red;\n        Console.WriteLine(Enum.GetName(tra.GetType(), 1));\n    &#125;\n&#125;<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li>\n<li><p>GetNames方法以一个枚举类型对象为参数，返回该枚举中所有成员的名称</p>\n<pre class=\"line-numbers language-c#\" data-language=\"c#\"><code class=\"language-c#\">enum TrafficLight : ulong\n&#123;\n    Red &#x3D; 100000000000,&#x2F;&#x2F;此处使用的是ulong类型\n    Green,\n    Yello\n&#125;\n\nclass Test\n&#123;\n    static void Main()\n    &#123;\n        TrafficLight tra &#x3D; TrafficLight.Red;\n        foreach (var t in Enum.GetNames(tra.GetType()))\n        &#123;\n            Console.WriteLine(t);\n        &#125;\n    &#125;\n&#125;<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li>\n</ul>\n</li>\n</ul>\n<h1 id=\"数组\"><a href=\"#数组\" class=\"headerlink\" title=\"数组\"></a>数组</h1><p>数组实际上是由一个变量名称表示的一组同类型的数据元素，每个元素通过数组名和方括号来访问</p>\n<h2 id=\"定义\"><a href=\"#定义\" class=\"headerlink\" title=\"定义\"></a>定义</h2><ul>\n<li>元素：数组的独立数据项称作元素（数组的所有元素必须是相同的类型，或继承自相同的类型）</li>\n<li>秩/维度：数组的维度数可以为任何正数，数组的维度称为秩</li>\n<li>维度长度：数组的每一个维度有长度，是这个方向的位置个数</li>\n<li>数组长度：数组的所有维度中的元素总数称为数组的长度</li>\n</ul>\n<h2 id=\"重要细节\"><a href=\"#重要细节\" class=\"headerlink\" title=\"重要细节\"></a>重要细节</h2><ul>\n<li>数组一旦创建，大小就是固定的。C#中不支持动态数组</li>\n<li>数组索引号是从0开始的，所以索引号范围是0~n-1<br><img src=\"https://cbaoblog.oss-cn-shanghai.aliyuncs.com/img/QQ%E6%88%AA%E5%9B%BE20230405235302.png\" alt=\"QQ截图20230405235302\"></li>\n</ul>\n<h2 id=\"数组的类型\"><a href=\"#数组的类型\" class=\"headerlink\" title=\"数组的类型\"></a>数组的类型</h2><p>C#提供两种类型的数组</p>\n<ul>\n<li>一维数组可以认为是单行元素或元素向量</li>\n<li>多维数组是由主向量中的位置组成的，每个位置本身又是一个数组，称为子数组</li>\n</ul>\n<h2 id=\"两种类型的多维数组\"><a href=\"#两种类型的多维数组\" class=\"headerlink\" title=\"两种类型的多维数组\"></a>两种类型的多维数组</h2><ul>\n<li>矩形数组<ul>\n<li>某个维度的所有子数组具有相同长度的多维数组</li>\n<li>不管有多少维度，总是使用一组方括号</li>\n</ul>\n</li>\n<li>交错数组<ul>\n<li>每一个子数组都是独立数组的多维数组</li>\n<li>可以有不同长度的子数组</li>\n<li>为数组的每一个维度使用一对方括号</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"C-中的各种数组图示\"><a href=\"#C-中的各种数组图示\" class=\"headerlink\" title=\"C#中的各种数组图示\"></a>C#中的各种数组图示</h2><p><img src=\"https://cbaoblog.oss-cn-shanghai.aliyuncs.com/img/QQ%E6%88%AA%E5%9B%BE20230406231702.png\" alt=\"QQ截图20230406231702\"></p>\n<h2 id=\"数组是对象\"><a href=\"#数组是对象\" class=\"headerlink\" title=\"数组是对象\"></a>数组是对象</h2><ul>\n<li><p>Rank返回数组维度数的属性</p>\n</li>\n<li><p>Length返回数组的长度（数组中所有元素的个数）的属性</p>\n</li>\n<li><p>数组是引用类型，数组对象本身总是在堆上</p>\n</li>\n<li><p>数组的元素既可以是值类型也可以是引用类型</p>\n<ul>\n<li>如果存储的元素是值类型，数组被称作值类型对象</li>\n<li>如果存储的元素是引用类型，数组被称作引用类型数组</li>\n</ul>\n<p><img src=\"https://cbaoblog.oss-cn-shanghai.aliyuncs.com/img/QQ%E6%88%AA%E5%9B%BE20230406232533.png\" alt=\"QQ截图20230406232533\"></p>\n</li>\n</ul>\n<h2 id=\"声明一维数组或矩形数组\"><a href=\"#声明一维数组或矩形数组\" class=\"headerlink\" title=\"声明一维数组或矩形数组\"></a>声明一维数组或矩形数组</h2><ul>\n<li><p>一维数组</p>\n<pre class=\"line-numbers language-c#\" data-language=\"c#\"><code class=\"language-c#\">int[] MyArr &#x3D; &#123; 1, 2, 3 &#125;;<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span></span></code></pre></li>\n<li><p>矩形数组</p>\n<ul>\n<li>可以使用任意多个秩说明符</li>\n<li>不能再数组类型区域中放数组维度长度</li>\n<li>数组声明后，维度数就是固定的，维度长度直到数组实例化时才能确定</li>\n</ul>\n<pre class=\"line-numbers language-c#\" data-language=\"c#\"><code class=\"language-c#\">int[,] MyArr2 &#x3D; &#123; &#123; 1, 2 &#125;, &#123; 3, 4 &#125; &#125;;&#x2F;&#x2F;二维整型数组\nint[,,] MyArr2&#x3D;;&#x2F;&#x2F;三维整型数组<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span></span></code></pre></li>\n</ul>\n<div class=\"custom-quote warning\">\n<span class=\"custom-quote-svg\"><svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"\" xmlns=\"http://www.w3.org/2000/svg\" data-reactroot=\"\">\n<path fill=\"\" d=\"M20.86 14.13C20 14.7 19.56 15.74 19.77 16.76C20.13 18.55 18.55 20.13 16.76 19.77C15.74 19.57 14.7 20 14.13 20.86C13.12 22.38 10.89 22.38 9.88 20.86C9.3 20 8.26 19.56 7.24 19.77C5.45 20.13 3.87 18.55 4.23 16.76C4.43 15.74 4 14.7 3.14 14.13C1.62 13.12 1.62 10.89 3.14 9.88C4 9.3 4.44 8.26 4.23 7.24C3.87 5.45 5.45 3.87 7.24 4.23C8.26 4.44 9.3 4 9.87 3.14C10.88 1.62 13.11 1.62 14.12 3.14C14.7 4 15.74 4.44 16.76 4.23C18.55 3.87 20.13 5.45 19.77 7.24C19.56 8.26 20 9.3 20.86 9.87C22.38 10.88 22.38 13.12 20.86 14.13Z\" undefined=\"1\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M12 8V13\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M12 15.99V16.01\"></path>\n</svg>\n</span>\n<p class=\"custom-quote-title\">注意</p>\n<p>​    C#中数组方括号放在基类型的后面，C/C++中数组的方括号放在变量名称后面</p>\n\n</div>\n<h2 id=\"交错数组\"><a href=\"#交错数组\" class=\"headerlink\" title=\"交错数组\"></a>交错数组</h2><ul>\n<li>本质是数组的数组</li>\n</ul>\n<h2 id=\"数组协变\"><a href=\"#数组协变\" class=\"headerlink\" title=\"数组协变\"></a>数组协变</h2><p>当某个对象不是数组的基类型，也可以把它赋值给数组元素，这种属性叫做数组协变</p>\n<ul>\n<li>当数组是引用类型数组（数组的元素是引用类型）</li>\n<li>在赋值的对象类型和数组基类型之间有隐式转换或显式转换</li>\n<li>值类型数组没有协变</li>\n</ul>\n<h2 id=\"数组继承的有用成员\"><a href=\"#数组继承的有用成员\" class=\"headerlink\" title=\"数组继承的有用成员\"></a>数组继承的有用成员</h2><p><img src=\"https://cbaoblog.oss-cn-shanghai.aliyuncs.com/img/QQ%E6%88%AA%E5%9B%BE20230406235055.png\" alt=\"QQ截图20230406235055\"></p>\n<h2 id=\"Clone方法\"><a href=\"#Clone方法\" class=\"headerlink\" title=\"Clone方法\"></a>Clone方法</h2><p>Clone方法为数组进行浅复制，它只创建数组本身的克隆，如果是引用类型数组，不会复制元素引用的对象</p>\n<ul>\n<li><p>克隆值类型数组会产生两个独立数组</p>\n</li>\n<li><p>克隆引用类型数组会产生指向相同对象的两个数组</p>\n</li>\n<li><p>Clone方法返回object类型的引用，必须被强制转换成数组类型</p>\n<pre class=\"line-numbers language-c#\" data-language=\"c#\"><code class=\"language-c#\">int[] TestArr &#x3D; &#123; 2, 3, 4 &#125;;\nint[] TestArr2 &#x3D; (int[])TestArr.Clone();<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span></span></code></pre></li>\n</ul>\n<h2 id=\"比较数组类型\"><a href=\"#比较数组类型\" class=\"headerlink\" title=\"比较数组类型\"></a>比较数组类型</h2><p><img src=\"https://cbaoblog.oss-cn-shanghai.aliyuncs.com/img/QQ%E6%88%AA%E5%9B%BE20230407233713.png\" alt=\"QQ截图20230407233713\"></p>\n<h2 id=\"数组与ref返回和ref局部变量\"><a href=\"#数组与ref返回和ref局部变量\" class=\"headerlink\" title=\"数组与ref返回和ref局部变量\"></a>数组与ref返回和ref局部变量</h2><pre class=\"line-numbers language-c#\" data-language=\"c#\"><code class=\"language-c#\">static class MyTest\n&#123;\n    public static ref int GetNum(int[] Arr)\n    &#123;\n        return ref Arr[0];\n    &#125;\n\n&#125;\n\nclass Test\n&#123;\n\n    static void Main()\n    &#123;\n        int[] TestArr &#x3D; &#123; 2, 3, 4 &#125;;\n        int[] TestArr2 &#x3D; (int[])TestArr.Clone();\n        ref int cs &#x3D; ref MyTest.GetNum(TestArr);&#x2F;&#x2F;使用ref关键字\n        cs &#x3D; 1000;&#x2F;&#x2F;会改变数组中的值\n        Console.WriteLine(TestArr[0]);\n    &#125;\n&#125;<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<h1 id=\"委托\"><a href=\"#委托\" class=\"headerlink\" title=\"委托\"></a>委托</h1><h2 id=\"什么是委托\"><a href=\"#什么是委托\" class=\"headerlink\" title=\"什么是委托\"></a>什么是委托</h2><p>可以认为委托是持有一个或多个方法的对象（类似C++中的函数指针）</p>\n<pre class=\"line-numbers language-c#\" data-language=\"c#\"><code class=\"language-c#\">delegate void MyDel(int num);&#x2F;&#x2F;声明一个返回类型为void接受一个int值的委托类\n\nclass Test\n&#123;\n    void PrintLow(int num)\n    &#123;\n        Console.WriteLine(&quot;低:&quot;+num);\n    &#125;\n\n    void PrintHeight(int num)\n    &#123;\n        Console.WriteLine(&quot;高:&quot; + num);   \n    &#125;\n\n    static void Main()\n    &#123;\n        Test t1&#x3D;new Test();\n\n        &#x2F;&#x2F;声明委托变量\n        MyDel del;\n\n        &#x2F;&#x2F;生成一个0~99的随机数\n        Random rand &#x3D; new Random();\n        int num &#x3D; rand.Next(99);\n        del&#x3D;num&lt;&#x3D;50?new MyDel(t1.PrintLow):new MyDel(t1.PrintHeight);\n\n        del(num);\n    &#125;\n&#125;<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<h2 id=\"委托概述\"><a href=\"#委托概述\" class=\"headerlink\" title=\"委托概述\"></a>委托概述</h2><p><img src=\"https://cbaoblog.oss-cn-shanghai.aliyuncs.com/img/QQ%E6%88%AA%E5%9B%BE20230408003048.png\" alt=\"QQ截图20230408003048\"></p>\n<p>可以将delegate看作一个包含有序方法列表的对象，这些方法具有相同的签名和返回类型</p>\n<ul>\n<li><p>方法的列表称为调用列表</p>\n</li>\n<li><p>委托持有的方法可以来自任何类或结构，只要满足下面两个要求</p>\n<ul>\n<li>委托的返回类型</li>\n<li>委托的签名（包括ref和out修饰符）</li>\n</ul>\n</li>\n<li><p>调用列表中的方法可以是实例方法也可以是静态方法</p>\n</li>\n<li><p>在调用委托的时候，会执行其调用列表中的所有方法</p>\n<p><img src=\"https://cbaoblog.oss-cn-shanghai.aliyuncs.com/img/QQ%E6%88%AA%E5%9B%BE20230408154833.png\" alt=\"QQ截图20230408154833\"></p>\n</li>\n</ul>\n<h2 id=\"声明委托类型\"><a href=\"#声明委托类型\" class=\"headerlink\" title=\"声明委托类型\"></a>声明委托类型</h2><p>委托是类型，与类一样，委托类型必须在被用来创建变量以及类型的对象之前声明。</p>\n<ul>\n<li><p>委托类型声明</p>\n<ul>\n<li><p>以delegate关键字开头</p>\n</li>\n<li><p>没有方法主体</p>\n<pre class=\"line-numbers language-c#\" data-language=\"c#\"><code class=\"language-c#\">delegate void MyDel(int num);<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span></span></code></pre></li>\n</ul>\n</li>\n</ul>\n<div class=\"custom-quote warning\">\n<span class=\"custom-quote-svg\"><svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"\" xmlns=\"http://www.w3.org/2000/svg\" data-reactroot=\"\">\n<path fill=\"\" d=\"M20.86 14.13C20 14.7 19.56 15.74 19.77 16.76C20.13 18.55 18.55 20.13 16.76 19.77C15.74 19.57 14.7 20 14.13 20.86C13.12 22.38 10.89 22.38 9.88 20.86C9.3 20 8.26 19.56 7.24 19.77C5.45 20.13 3.87 18.55 4.23 16.76C4.43 15.74 4 14.7 3.14 14.13C1.62 13.12 1.62 10.89 3.14 9.88C4 9.3 4.44 8.26 4.23 7.24C3.87 5.45 5.45 3.87 7.24 4.23C8.26 4.44 9.3 4 9.87 3.14C10.88 1.62 13.11 1.62 14.12 3.14C14.7 4 15.74 4.44 16.76 4.23C18.55 3.87 20.13 5.45 19.77 7.24C19.56 8.26 20 9.3 20.86 9.87C22.38 10.88 22.38 13.12 20.86 14.13Z\" undefined=\"1\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M12 8V13\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M12 15.99V16.01\"></path>\n</svg>\n</span>\n<p class=\"custom-quote-title\">注意</p>\n<p><p>​    委托类型声明不需要声明在类内部，因为委托是类型声明</p>\n</p>\n</div>\n<h2 id=\"创建委托对象\"><a href=\"#创建委托对象\" class=\"headerlink\" title=\"创建委托对象\"></a>创建委托对象</h2><p>委托是引用类型，因此有引用和对象。</p>\n<p>两种创建委托对象的方法</p>\n<ul>\n<li><p>第一种是使用带new运算符的对象创建表达式</p>\n<pre class=\"line-numbers language-c#\" data-language=\"c#\"><code class=\"language-c#\">myDel &#x3D; new MyDel(test.MyFunc);<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span></span></code></pre></li>\n<li><p>第二种快捷语法（与上面是等价的）</p>\n<pre class=\"line-numbers language-c#\" data-language=\"c#\"><code class=\"language-c#\">myDel &#x3D; test.MyFunc;<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span></span></code></pre></li>\n</ul>\n<h2 id=\"给委托赋值\"><a href=\"#给委托赋值\" class=\"headerlink\" title=\"给委托赋值\"></a>给委托赋值</h2><p>由于委托是引用类型，可以通过给它赋值来改变包含在委托变量中引用，旧的委托对象被垃圾回收器回收</p>\n<pre class=\"line-numbers language-c#\" data-language=\"c#\"><code class=\"language-c#\">Test test&#x3D; new Test();\nmyDel &#x3D; test.MyFunc;<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span></span></code></pre>\n\n<h2 id=\"组合委托\"><a href=\"#组合委托\" class=\"headerlink\" title=\"组合委托\"></a>组合委托</h2><pre class=\"line-numbers language-c#\" data-language=\"c#\"><code class=\"language-c#\">MyDel myDel, myDel2, myDel3;\nTest test&#x3D; new Test();\nmyDel &#x3D; test.MyFunc;\nmyDel2 &#x3D; test.MyFunc2;\nmyDel3 &#x3D; myDel + myDel2;&#x2F;&#x2F;组合委托\nmyDel3(2);<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<h3 id=\"为委托添加方法\"><a href=\"#为委托添加方法\" class=\"headerlink\" title=\"为委托添加方法\"></a>为委托添加方法</h3><p>使用+=运算符</p>\n<pre class=\"line-numbers language-c#\" data-language=\"c#\"><code class=\"language-c#\">MyDel myDel;\nTest test&#x3D; new Test();\nmyDel &#x3D; test.MyFunc;\n&#x2F;&#x2F;为委托添加方法\nmyDel +&#x3D; test.MyFunc2;\nmyDel(3);<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<h2 id=\"从委托移除方法\"><a href=\"#从委托移除方法\" class=\"headerlink\" title=\"从委托移除方法\"></a>从委托移除方法</h2><p>使用-=运算符</p>\n<pre class=\"line-numbers language-c#\" data-language=\"c#\"><code class=\"language-c#\">MyDel myDel;\nTest test&#x3D; new Test();\nmyDel &#x3D; test.MyFunc;\n&#x2F;&#x2F;为委托添加方法\nmyDel +&#x3D; test.MyFunc2;\n&#x2F;&#x2F;为委托移除方法\nmyDel -&#x3D; test.MyFunc2;\nmyDel(3);<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<div class=\"custom-quote warning\">\n<span class=\"custom-quote-svg\"><svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"\" xmlns=\"http://www.w3.org/2000/svg\" data-reactroot=\"\">\n<path fill=\"\" d=\"M20.86 14.13C20 14.7 19.56 15.74 19.77 16.76C20.13 18.55 18.55 20.13 16.76 19.77C15.74 19.57 14.7 20 14.13 20.86C13.12 22.38 10.89 22.38 9.88 20.86C9.3 20 8.26 19.56 7.24 19.77C5.45 20.13 3.87 18.55 4.23 16.76C4.43 15.74 4 14.7 3.14 14.13C1.62 13.12 1.62 10.89 3.14 9.88C4 9.3 4.44 8.26 4.23 7.24C3.87 5.45 5.45 3.87 7.24 4.23C8.26 4.44 9.3 4 9.87 3.14C10.88 1.62 13.11 1.62 14.12 3.14C14.7 4 15.74 4.44 16.76 4.23C18.55 3.87 20.13 5.45 19.77 7.24C19.56 8.26 20 9.3 20.86 9.87C22.38 10.88 22.38 13.12 20.86 14.13Z\" undefined=\"1\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M12 8V13\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M12 15.99V16.01\"></path>\n</svg>\n</span>\n<p class=\"custom-quote-title\">注意</p>\n<p>移除委托的注意事项：</p>\n<ul>\n<li>如果调用列表中的方法有多个实例，-=运算符将从列表最后开始搜索，移除第一个与方法匹配的实例</li>\n<li>试图删除委托中不存在的方法将无效</li>\n<li>试图调用空委托会抛出异常</li>\n<li>将委托与null进行比较可以判断是否为空委托</li>\n</ul>\n\n</div>\n<h2 id=\"调用委托\"><a href=\"#调用委托\" class=\"headerlink\" title=\"调用委托\"></a>调用委托</h2><ul>\n<li><p>可以通过两种方式调用委托，一种是像调用方法一样调用委托，一种是使用委托的Invoke方法</p>\n<pre class=\"line-numbers language-c#\" data-language=\"c#\"><code class=\"language-c#\">MyDel myDel;\nTest test&#x3D; new Test();\nmyDel &#x3D; test.MyFunc;\n\n&#x2F;&#x2F;为委托添加方法\nmyDel +&#x3D; test.MyFunc2;\n\n&#x2F;&#x2F;普通调用\nmyDel(2);\n\n&#x2F;&#x2F;使用Invoke调用\nmyDel.Invoke(2);<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li>\n<li><p>检查委托是否是空委托然后调用</p>\n<pre class=\"line-numbers language-c#\" data-language=\"c#\"><code class=\"language-c#\">MyDel myDel;\nTest test&#x3D; new Test();\nmyDel &#x3D; test.MyFunc;\n\n&#x2F;&#x2F;为委托添加方法\nmyDel +&#x3D; test.MyFunc2;\n\nif (myDel !&#x3D; null)\n&#123;\n    &#x2F;&#x2F;普通调用\n    myDel(2);\n&#125;\n\n\n&#x2F;&#x2F;使用Invoke调用，用空条件运算符\nmyDel?.Invoke(2);<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li>\n</ul>\n<h2 id=\"调用带返回值的委托\"><a href=\"#调用带返回值的委托\" class=\"headerlink\" title=\"调用带返回值的委托\"></a>调用带返回值的委托</h2><ul>\n<li>调用列表中最后一个方法返回的值就是委托调用返回的值</li>\n<li>调用列表中所有其它方法的返回值都会被忽略</li>\n</ul>\n<h2 id=\"调用带引用参数的委托\"><a href=\"#调用带引用参数的委托\" class=\"headerlink\" title=\"调用带引用参数的委托\"></a>调用带引用参数的委托</h2><p>如果委托有引用参数，参数值会根据调用列表中的一个或多个方法的返回值而改变</p>\n<h2 id=\"匿名方法\"><a href=\"#匿名方法\" class=\"headerlink\" title=\"匿名方法\"></a>匿名方法</h2><p>是在实例化委托时内联声明的方法</p>\n<ul>\n<li>使用匿名方法的时机<ul>\n<li>声明委托变量时作为初始化表达式</li>\n<li>组合委托时在赋值语句的右边</li>\n<li>为委托增加事件时在赋值语句的右边</li>\n</ul>\n</li>\n<li>匿名方法的语法<ul>\n<li>delegate关键字</li>\n<li>参数列表</li>\n<li>语句块</li>\n</ul>\n</li>\n</ul>\n<pre class=\"line-numbers language-c#\" data-language=\"c#\"><code class=\"language-c#\">delegate(参数列表)&#123;语句块&#125;<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span></span></code></pre>\n\n<pre class=\"line-numbers language-c#\" data-language=\"c#\"><code class=\"language-c#\">delegate void MyFunc(int num);\n\nclass Test\n&#123;\n    static void Main()\n    &#123;\n        &#x2F;&#x2F;匿名方法\n        MyFunc TestA &#x3D; delegate (int num) &#123; Console.WriteLine(num); &#125;;\n        TestA(10);\n    &#125;\n&#125;<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<h2 id=\"Lambda\"><a href=\"#Lambda\" class=\"headerlink\" title=\"Lambda\"></a>Lambda</h2><p>可完全代替匿名方法</p>\n<pre class=\"line-numbers language-c#\" data-language=\"c#\"><code class=\"language-c#\">delegate void MyFunc(int num);\n\nclass Test\n&#123;\n    static void Main()\n    &#123;\n    \t&#x2F;&#x2F;Lambda表达式\n        MyFunc TestA &#x3D; (x) &#x3D;&gt; &#123; Console.WriteLine(x); &#125;;\n        TestA(10);\n    &#125;\n&#125;<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<ul>\n<li>Lambda表达式参数列表中的参数必须在参数数量，类型，位置上与委托匹配</li>\n<li>表达式的参数列表中的参数不一定需要包含类型。除非委托有ref或out关键字（必须注明）</li>\n<li>如果只有一个参数，并且是隐式类型的，则两端的圆括号可以省略，否则必须有括号</li>\n<li>如果没有参数，必须使用一组空的圆括号</li>\n</ul>\n<h1 id=\"事件\"><a href=\"#事件\" class=\"headerlink\" title=\"事件\"></a>事件</h1><h2 id=\"发布者和订阅者\"><a href=\"#发布者和订阅者\" class=\"headerlink\" title=\"发布者和订阅者\"></a>发布者和订阅者</h2><p>当一个特定的程序事件发生时，程序的其它部分可以得到该事件已经发生的通知，发布者/订阅者可以满足该需求。</p>\n<ul>\n<li>发布者：发布某个事件的类或者结构，其它类可以在该事件发生时得到通知</li>\n<li>订阅者：注册并在事件发生时得到通知的类或结构</li>\n<li>事件处理程序：由订阅者注册到事件的方法，在发布者触发事件时执行，事件处理程序方法可以定义在事件所在的类或结构中，也可以定义在不同的类或结构中</li>\n<li>触发事件：当事件被触发时，所有注册到它的方法都会被依次调用</li>\n</ul>\n<h2 id=\"声明事件\"><a href=\"#声明事件\" class=\"headerlink\" title=\"声明事件\"></a>声明事件</h2><ul>\n<li>事件声明在一个类中，关键字event</li>\n<li>声明为public，其他类和结构就可以在上面注册事件处理</li>\n<li>不能使用对象常见表达式（new表达式）创建它的对象</li>\n<li>需要委托类型的名称，任何附加到事件的处理程序都必须与委托类型的签名和返回类型匹配</li>\n</ul>\n<pre class=\"line-numbers language-c#\" data-language=\"c#\"><code class=\"language-c#\">delegate void MyFunc(int num);\n\nclass Test\n&#123;\n    &#x2F;&#x2F;声明事件\n    public event MyFunc eventTest;\n\n    static void Main()\n    &#123;\n        \n    &#125;\n&#125;<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<h2 id=\"事件是成员\"><a href=\"#事件是成员\" class=\"headerlink\" title=\"事件是成员\"></a>事件是成员</h2><p>事件和方法，属性一样，事件是类或结构的成员</p>\n<ul>\n<li>由于事件是成员<ul>\n<li>所以不能在一段可执行代码中声明事件</li>\n<li>必须声明在类或者结构中，和其他成员一样</li>\n</ul>\n</li>\n<li>事件成员被隐式自动初始化成null</li>\n</ul>\n<h2 id=\"订阅事件\"><a href=\"#订阅事件\" class=\"headerlink\" title=\"订阅事件\"></a>订阅事件</h2><ul>\n<li>使用+=运算符来为事件添加事件处理程序</li>\n<li>事件处理程序的规范可以是以下任意一种<ul>\n<li>实例方法的名称</li>\n<li>静态方法的名称</li>\n<li>匿名方法</li>\n<li>Lambda表达式</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"触发事件\"><a href=\"#触发事件\" class=\"headerlink\" title=\"触发事件\"></a>触发事件</h2><p>事件成员本身只是保存了需要被调用的事件处理程序，如果事件不被触发，什么都不会发生</p>\n<ul>\n<li>在触发事件之前和null进行比较，来查看事件是否包含事件处理程序</li>\n<li>触发事件的语法和调用方法一样<ul>\n<li>使用事件名称，后面跟着参数列表（包含在圆括号中）</li>\n<li>参数列表必须与事件的委托类型相匹配</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"完整示例\"><a href=\"#完整示例\" class=\"headerlink\" title=\"完整示例\"></a>完整示例</h2><pre class=\"line-numbers language-c#\" data-language=\"c#\"><code class=\"language-c#\">using System;\n\nnamespace EventLearn\n&#123;\n    &#x2F;&#x2F;声明一个委托\n    delegate void TestDelegate();\n\n    &#x2F;&#x2F;发布者\n    class Promulgator\n    &#123;\n        &#x2F;&#x2F;创建事件并发布\n        public event TestDelegate EventTestDelegate;\n\n        &#x2F;&#x2F;触发事件\n        public void TriggerEvent()\n        &#123;\n            EventTestDelegate();\n        &#125;\n    &#125;\n\n    &#x2F;&#x2F;订阅者\n    class Subscriber\n    &#123;\n        public Subscriber(Promulgator promulgator)\n        &#123;\n            promulgator.EventTestDelegate +&#x3D; Func;&#x2F;&#x2F;订阅事件\n        &#125;\n\n        public void Func()\n        &#123;\n            Console.WriteLine(&quot;事件处理程序&quot;);\n        &#125;\n    &#125;\n\n    class MyMain\n    &#123;\n        static void Main()\n        &#123;\n            Promulgator p1&#x3D;new Promulgator();\n            Subscriber s1&#x3D;new Subscriber(p1);\n            Subscriber s2 &#x3D; new Subscriber(p1);\n            p1.TriggerEvent();\n        &#125;\n    &#125;\n&#125;<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<h1 id=\"接口\"><a href=\"#接口\" class=\"headerlink\" title=\"接口\"></a>接口</h1><h2 id=\"什么是接口\"><a href=\"#什么是接口\" class=\"headerlink\" title=\"什么是接口\"></a>什么是接口</h2><p>接口是指定一组函数成员而不实现它们的引用类型，只能类和结构来实现接口</p>\n<h2 id=\"IComparable接口\"><a href=\"#IComparable接口\" class=\"headerlink\" title=\"IComparable接口\"></a>IComparable接口</h2><ul>\n<li><p>数组中的排序方法（Sort）依赖于该接口，用户自定义的类要想使用排序必须实现该接口</p>\n<ul>\n<li>负数值：如果当前对象小于参数对象</li>\n<li>正数值：如果当前对象大于参数对象</li>\n<li>零：如果两个对象在比较时相等</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"声明接口\"><a href=\"#声明接口\" class=\"headerlink\" title=\"声明接口\"></a>声明接口</h2><ul>\n<li>接口声明不能包含以下成员<ul>\n<li>数据成员</li>\n<li>静态成员</li>\n</ul>\n</li>\n<li>接口声明只能包含如下类型的非静态成员函数的声明<ul>\n<li>方法</li>\n<li>属性</li>\n<li>事件</li>\n<li>索引器</li>\n</ul>\n</li>\n<li>这些函数成员的声明不能包含任何实现代码，必须使用分号代替每一个成员声明的主体。</li>\n<li>按照惯例，接口名称必须从大写的I开始</li>\n<li>与类和结构一样，接口声明也可以分隔成分部接口声明</li>\n<li>接口的访问性和接口成员的访问性之间的一些区别<ul>\n<li>接口声明可以有任何访问修饰符</li>\n<li>接口成员是隐式public的，不允许有任何修饰访问符（包括public）</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"实现接口\"><a href=\"#实现接口\" class=\"headerlink\" title=\"实现接口\"></a>实现接口</h2><p>只有类和结构可以实现接口</p>\n<ul>\n<li><p>在基类列表中包括接口名称</p>\n</li>\n<li><p>为每个接口成员提供实现</p>\n</li>\n<li><p>如果类实现了接口，它必须实现接口的所有成员</p>\n</li>\n<li><p>如果类派生自基类并实现接口，基类列表中的基类名称必须放在所有接口之前</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">public interface ITest\n&#123;\n    \n&#125;\npublic interface ITest2\n&#123;\n\n&#125;\n\npublic interface ITest3\n&#123;\n\n&#125;\n\nclass TestBase\n&#123;\n    \n&#125;\n\n&#x2F;&#x2F;基类名称必须在所有接口名称之前\nclass SubTest : TestBase, ITest, ITest2, ITest3\n&#123;\n    \n&#125;\n<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li>\n</ul>\n<h2 id=\"接口是引用类型\"><a href=\"#接口是引用类型\" class=\"headerlink\" title=\"接口是引用类型\"></a>接口是引用类型</h2><pre class=\"line-numbers language-c#\" data-language=\"c#\"><code class=\"language-c#\">using System;\n\nnamespace EventLearn\n&#123;\n    interface IPrint\n    &#123;\n        &#x2F;&#x2F;接口默认访问级别是public\n        void MyPrint();\n    &#125;\n\n    class Test : IPrint\n    &#123;\n        public void MyPrint()\n        &#123;\n            Console.WriteLine(&quot;Test调用接口函数&quot;);\n        &#125;\n    &#125;\n\n    class Test2 : IPrint\n    &#123;\n        public void MyPrint()\n        &#123;\n            Console.WriteLine(&quot;Test2调用接口函数&quot;);\n        &#125;\n    &#125;\n\n    class Program\n    &#123;\n        static void Main()\n        &#123;\n            Test test &#x3D; new Test();\n            Test2 test2 &#x3D; new Test2();\n\t\t\t\n            IPrint p1 &#x3D; test;\n            p1.MyPrint();\n\n            p1 &#x3D; test2;\n            p1.MyPrint();\n        &#125;\n    &#125;\n&#125;<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<h2 id=\"接口和as运算符\"><a href=\"#接口和as运算符\" class=\"headerlink\" title=\"接口和as运算符\"></a>接口和as运算符</h2><p>如果将类对象引用强制转换为类未实现的接口引用，强制转换操作会抛出异常，使用as运算符可以避免抛出异常。</p>\n<ul>\n<li>as运算符如果类实现了接口，表达式返回指向接口的引用</li>\n<li>as运算符如果类没有实现接口，表达式返回null不是抛出异常</li>\n</ul>\n<pre class=\"line-numbers language-c#\" data-language=\"c#\"><code class=\"language-c#\">Test test &#x3D; new Test();\nTest2 test2 &#x3D; new Test2();\n\nIPrint p1 &#x3D; test as IPrint;\nif (p1 !&#x3D; null)\n&#123;\n    p1.MyPrint();\n&#125;\n\np1 &#x3D; test2 as IPrint;\nif (p1 !&#x3D; null)\n&#123;\n    p1.MyPrint();\n&#125;<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<h2 id=\"实现具有重复成员的接口\"><a href=\"#实现具有重复成员的接口\" class=\"headerlink\" title=\"实现具有重复成员的接口\"></a>实现具有重复成员的接口</h2><p>如果类实现多个接口，且其中一些接口成员具有相同签名和返回类型，那么类可以实现单个成员来满足所有包含重复成员的接口</p>\n<pre class=\"line-numbers language-c#\" data-language=\"c#\"><code class=\"language-c#\">using System;\n\nnamespace EventLearn\n&#123;\n    interface IPrint\n    &#123;\n        void MyPrint();\n    &#125;\n\n    interface IPrint2\n    &#123;\n        void MyPrint();\n    &#125;\n\n    class Test : IPrint,IPrint2\n    &#123;\n        &#x2F;&#x2F;同时实现IPrint,IPrint2的接口实现\n        public void MyPrint()\n        &#123;\n            Console.WriteLine(&quot;Test调用接口函数&quot;);\n        &#125;\n    &#125;\n\n\n    class Program\n    &#123;\n        static void Main()\n        &#123;\n            Test test &#x3D; new Test();\n            IPrint p1 &#x3D; test;\n            IPrint p2 &#x3D; test;\n            p1.MyPrint();\n            p2.MyPrint();          \n        &#125;\n    &#125;\n&#125;<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<h2 id=\"派生成员作为接口实现\"><a href=\"#派生成员作为接口实现\" class=\"headerlink\" title=\"派生成员作为接口实现\"></a>派生成员作为接口实现</h2><pre class=\"line-numbers language-c#\" data-language=\"c#\"><code class=\"language-c#\">using System;\n\nnamespace EventLearn\n&#123;\n    interface IPrint\n    &#123;\n        void MyPrint();\n    &#125;\n\n    interface IPrint2\n    &#123;\n        void MyPrint();\n    &#125;\n\n    class Base\n    &#123;\n        &#x2F;&#x2F;基类有和子类对应的接口实现\n        public void MyPrint()\n        &#123;\n            Console.WriteLine(&quot;接口实现&quot;);\n        &#125;\n    &#125;\n\n    class Sub : Base, IPrint, IPrint2\n    &#123;\n        \n    &#125;\n\n    class Program\n    &#123;\n        static void Main()\n        &#123;\n            Sub test &#x3D; new Sub();\n            IPrint p1 &#x3D; test;\n            IPrint p2 &#x3D; test;\n            p1.MyPrint();\n            p2.MyPrint();          \n        &#125;\n    &#125;\n&#125;<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<h2 id=\"显式接口成员实现\"><a href=\"#显式接口成员实现\" class=\"headerlink\" title=\"显式接口成员实现\"></a>显式接口成员实现</h2><ul>\n<li>使用限定接口名称来声明，由接口名称和成员名称以及它们中间的点分隔符号构成</li>\n<li>显式接口成员实现只可以通过指向接口的引用来访问</li>\n</ul>\n<pre class=\"line-numbers language-c#\" data-language=\"c#\"><code class=\"language-c#\">using System;\n\nnamespace EventLearn\n&#123;\n    interface IPrint\n    &#123;\n        void MyPrint();\n    &#125;\n\n    interface IPrint2\n    &#123;\n        void MyPrint();\n    &#125;\n\n    class Base\n    &#123;\n        &#x2F;&#x2F;基类有和子类对应的接口实现\n        public void MyPrint()\n        &#123;\n            Console.WriteLine(&quot;接口实现&quot;);\n        &#125;\n    &#125;\n\n    class Sub : Base, IPrint, IPrint2\n    &#123;\n\n        &#x2F;&#x2F;显示接口成员实现\n        void IPrint.MyPrint()\n        &#123;\n            Console.WriteLine(&quot;IPrint接口&quot;);\n        &#125;\n        &#x2F;&#x2F;显示接口成员实现\n        void IPrint2.MyPrint()\n        &#123;\n            Console.WriteLine(&quot;IPrint2接口&quot;);\n        &#125;\n    &#125;\n\n    class Program\n    &#123;\n        static void Main()\n        &#123;\n            Sub test &#x3D; new Sub();\n            IPrint p1 &#x3D; test;\n            IPrint2 p2 &#x3D; test;\n            p1.MyPrint();\n            p2.MyPrint();          \n        &#125;\n    &#125;\n&#125;<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<h2 id=\"接口可以继承接口\"><a href=\"#接口可以继承接口\" class=\"headerlink\" title=\"接口可以继承接口\"></a>接口可以继承接口</h2><p>接口可以从一个或多个接口继承而来</p>\n<ul>\n<li>类在基类列表中只能有一个类名，而接口可以在基接口列表中有任意多个接口<ul>\n<li>列表中的接口本身可以继承其它接口</li>\n<li>结果接口包含它声明的所有成员和基接口的所有成员</li>\n</ul>\n</li>\n</ul>\n<pre class=\"line-numbers language-c#\" data-language=\"c#\"><code class=\"language-c#\">using System;\n\nnamespace EventLearn\n&#123;\n    interface ITest1\n    &#123;\n        void PrintName();\n    &#125;\n\n    interface ITest2\n    &#123;\n        void PrintAge();\n    &#125;\n\n    &#x2F;&#x2F;接口继承了接口\n    interface ITest : ITest1, ITest2\n    &#123;\n        \n    &#125;\n\n    class MyTestClass : ITest\n    &#123;\n        public void PrintAge()\n        &#123;\n            Console.WriteLine(&quot;25&quot;);\n        &#125;\n\n        public void PrintName()\n        &#123;\n            Console.WriteLine(&quot;cBao&quot;);\n        &#125;\n    &#125;\n\n    class Program\n    &#123;\n        static void Main()\n        &#123;\n            MyTestClass myTestClass &#x3D; new MyTestClass();\n            myTestClass.PrintAge();\n            myTestClass.PrintName();\n        &#125;\n    &#125;\n&#125;<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<h1 id=\"转换\"><a href=\"#转换\" class=\"headerlink\" title=\"转换\"></a>转换</h1><h2 id=\"什么是转换\"><a href=\"#什么是转换\" class=\"headerlink\" title=\"什么是转换\"></a>什么是转换</h2><ul>\n<li>转换（conversion）是接受一个类型的值并将它作为另一个类型的等价值的过程</li>\n<li>转换过的值和源值一样，但其类型为目标类型</li>\n</ul>\n<h2 id=\"隐式转换\"><a href=\"#隐式转换\" class=\"headerlink\" title=\"隐式转换\"></a>隐式转换</h2><ul>\n<li>有些类型的转换不会丢失数据或精度，语言会自动做这些转换，这就叫做隐式转换</li>\n<li>从位数更少的源类型转换为位数更多的目标类型时，目标中多出来的位需要用0或1填充</li>\n<li>当从更小的无符号类型转换为更大的无符号类型时，目标类型多出来的最高位都以0进行填充，叫做零扩展</li>\n</ul>\n<h2 id=\"显式转换和强制转换\"><a href=\"#显式转换和强制转换\" class=\"headerlink\" title=\"显式转换和强制转换\"></a>显式转换和强制转换</h2><p>强制转换表达式(可能会丢失数据)</p>\n<pre class=\"line-numbers language-c#\" data-language=\"c#\"><code class=\"language-c#\">double testDouble &#x3D; 19.4;\n&#x2F;&#x2F;强制类型转换\nint testInt &#x3D; (int)testDouble;\nConsole.WriteLine(testInt);<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span></span></code></pre>\n\n<h2 id=\"数字的转换\"><a href=\"#数字的转换\" class=\"headerlink\" title=\"数字的转换\"></a>数字的转换</h2><ul>\n<li>任何数字类型都能转换为其它数字类型</li>\n</ul>\n<p><img src=\"https://cbaoblog.oss-cn-shanghai.aliyuncs.com/img/%E4%BC%81%E4%B8%9A%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20230417204228.png\" alt=\"企业微信截图_20230417204228\"></p>\n<ul>\n<li><p>隐式数字转换</p>\n<ul>\n<li>占据较少位的数字类型可以隐式转换为占据较多位的数字类型</li>\n</ul>\n<p><img src=\"https://cbaoblog.oss-cn-shanghai.aliyuncs.com/img/%E4%BC%81%E4%B8%9A%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20230417204518.png\" alt=\"企业微信截图_20230417204518\"></p>\n</li>\n</ul>\n<h2 id=\"溢出检测上下文\"><a href=\"#溢出检测上下文\" class=\"headerlink\" title=\"溢出检测上下文\"></a>溢出检测上下文</h2><ul>\n<li><p>对于整数类型，C#允许我们选择运行时是否应该在进行类型转换时检测结果溢出</p>\n</li>\n<li><p>语法</p>\n<pre class=\"line-numbers language-c#\" data-language=\"c#\"><code class=\"language-c#\">checked(表达式);&#x2F;&#x2F;如果溢出将抛出OverflowException异常\nunchecked(表达式);&#x2F;&#x2F;忽略溢出<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span></span></code></pre>\n\n<pre class=\"line-numbers language-c#\" data-language=\"c#\"><code class=\"language-c#\">using System;\n\nnamespace EventLearn\n&#123;\n    class Program\n    &#123;\n        static void Main()\n        &#123;\n            int testInt &#x3D; 1000;\n            byte b1 &#x3D; checked((byte)testInt);&#x2F;&#x2F;抛出溢出异常\n            byte b2 &#x3D; unchecked((byte)testInt);&#x2F;&#x2F;忽略溢出\n            Console.WriteLine(b1);\n        &#125;\n    &#125;\n&#125;<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li>\n</ul>\n<h2 id=\"引用转换\"><a href=\"#引用转换\" class=\"headerlink\" title=\"引用转换\"></a>引用转换</h2><p>引用类型对象由内存中的两部分组成：引用和数据</p>\n<ul>\n<li>由引用保存的那部分信息是它指向的数据类型</li>\n<li>引用转换接受源引用并返回一个指向堆中同一位置的引用，但是把引用“标记”为其它类型</li>\n</ul>\n<h3 id=\"隐式引用转换\"><a href=\"#隐式引用转换\" class=\"headerlink\" title=\"隐式引用转换\"></a>隐式引用转换</h3><ul>\n<li>所有引用类型可以被隐式转换为object类型</li>\n<li>任何接口可以隐式转换为它继承的接口</li>\n<li>类可以隐式转换为<ul>\n<li>继承链中的任何类</li>\n<li>实现的任何接口</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"显式引用转换\"><a href=\"#显式引用转换\" class=\"headerlink\" title=\"显式引用转换\"></a>显式引用转换</h2><ul>\n<li>从object到任何引用类型的转换</li>\n<li>从基类到派生自它的类的转换</li>\n</ul>\n<h2 id=\"装箱转换\"><a href=\"#装箱转换\" class=\"headerlink\" title=\"装箱转换\"></a>装箱转换</h2><p>包括值类型在内的所有C#类型都派生自object类型</p>\n<p>装箱是一种隐式转换，接受值类型的值，根据这个值在堆上创建一个完整的引用类型对象并返回对象的引用</p>\n<pre class=\"line-numbers language-c#\" data-language=\"c#\"><code class=\"language-c#\">using System;\n\nnamespace EventLearn\n&#123;\n\n    class Program\n    &#123;\n        static void Main()\n        &#123;\n            int i &#x3D; 100;\n            &#x2F;&#x2F;装箱操作\n            object oi &#x3D; i;\n            Console.WriteLine(oi);\n        &#125;\n    &#125;\n&#125;<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<ul>\n<li>装箱是创建副本</li>\n<li>装箱是值类型到引用类型的隐式转换</li>\n</ul>\n<h2 id=\"拆箱转换\"><a href=\"#拆箱转换\" class=\"headerlink\" title=\"拆箱转换\"></a>拆箱转换</h2><p>拆箱是把装箱后的对象转换回值类型的过程</p>\n<ul>\n<li><p>拆箱是显式转换</p>\n</li>\n<li><p>系统在把值拆箱成ValueTypeT时执行如下步骤</p>\n<ul>\n<li>检测到要拆箱的对象实际是ValueTypeT的装箱值</li>\n<li>把对象的复制到变量</li>\n</ul>\n</li>\n<li><p>拆箱示例代码</p>\n<pre class=\"line-numbers language-c#\" data-language=\"c#\"><code class=\"language-c#\">using System;\n\nnamespace EventLearn\n&#123;\n\n    class Program\n    &#123;\n        static void Main()\n        &#123;\n            int testi &#x3D; 20;\n            &#x2F;&#x2F;装箱\n            object oi &#x3D; testi;\n            oi &#x3D; 30;\n            &#x2F;&#x2F;拆箱\n            int testi2 &#x3D; (int)oi;\n            Console.WriteLine($&quot;testi:&#123;testi&#125;\\noi:&#123;oi&#125;\\ntesti2:&#123;testi2&#125;&quot;);\n        &#125;\n    &#125;\n&#125;<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li>\n<li><p>尝试将值拆箱成非原始类型时会抛出InvalidCastException异常</p>\n</li>\n</ul>\n<h2 id=\"用户自定义的转换\"><a href=\"#用户自定义的转换\" class=\"headerlink\" title=\"用户自定义的转换\"></a>用户自定义的转换</h2><p>可以为类和结构定义隐式和显式转换</p>\n<ul>\n<li><p>除了implicit和explicit关键字外，隐式转换和显式转换的声明语法是一样的</p>\n</li>\n<li><p>需要public和static修饰符</p>\n</li>\n<li><p>示例代码</p>\n<pre class=\"line-numbers language-c#\" data-language=\"c#\"><code class=\"language-c#\">using System;\n\nnamespace EventLearn\n&#123;\n    class Test\n    &#123;\n        int i &#x3D; 30;\n        &#x2F;&#x2F;public static implicit&#x2F;explicit operator 目标类型 (源)\n        public static implicit operator int(Test ts)\n        &#123;\n            return ts.i;\n        &#125;\n    &#125;\n\n    class Program\n    &#123;\n        static void Main()\n        &#123;\n            Test ts &#x3D; new Test();\n            int i &#x3D; (int)ts;\n            Console.WriteLine(i);\n        &#125;\n    &#125;\n&#125;<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li>\n</ul>\n<h3 id=\"用户自定义转换的约束\"><a href=\"#用户自定义转换的约束\" class=\"headerlink\" title=\"用户自定义转换的约束\"></a>用户自定义转换的约束</h3><ul>\n<li>只可以为类和结构定义用户自定义转换</li>\n<li>不能重定义标准隐式或显式转换</li>\n<li>对于源类型S和目标类型T，如下命题为真<ul>\n<li>S和T必须是不同类型</li>\n<li>S和T不能通过继承关联，S不能派生自T，T也不能派生自S</li>\n<li>S和T都不能是接口类型或object类型</li>\n<li>转换运算符必须是S或T的成员</li>\n</ul>\n</li>\n<li>对于相同的源类型和目标类型，不能声明两种转换，一个是隐式转换一个是显式转换</li>\n</ul>\n<h2 id=\"is运算符\"><a href=\"#is运算符\" class=\"headerlink\" title=\"is运算符\"></a>is运算符</h2><p>使用is运算符来检查转换是否会成功完成，避免盲目尝试转换</p>\n<p>语法：Expr is TargetType</p>\n<p>如果Expr可以通过以下方式成功转换为目标类型，则运算符返回true</p>\n<ul>\n<li>引用转换</li>\n<li>装箱转换</li>\n<li>拆箱转换</li>\n</ul>\n<p>is运算符只可以用于上面三种方式的转换，不能用于用户自定义转换</p>\n<pre class=\"line-numbers language-c#\" data-language=\"c#\"><code class=\"language-c#\">using System;\n\nnamespace EventLearn\n&#123;\n    class Base\n    &#123;\n        \n    &#125;\n\n    class Sub : Base\n    &#123; &#125;\n    class Program\n    &#123;\n        static void Main()\n        &#123;\n            Sub s1 &#x3D; new Sub();\n            if (s1 is Base)\n            &#123;\n                Console.WriteLine(&quot;可以成功转换&quot;);\n            &#125;\n        &#125;\n    &#125;\n&#125;<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<h2 id=\"as运算符\"><a href=\"#as运算符\" class=\"headerlink\" title=\"as运算符\"></a>as运算符</h2><p>as运算符和强制转换运算符类似，只是不抛出异常，如果转换失败返回null</p>\n<p>语法：Expr as TargetType</p>\n<ul>\n<li>Expr是源表达式</li>\n<li>TargetType是目标类型，必须是引用类型</li>\n</ul>\n<pre class=\"line-numbers language-c#\" data-language=\"c#\"><code class=\"language-c#\">using System;\n\nnamespace EventLearn\n&#123;\n    class Base\n    &#123;\n        public int Test &#x3D; 100;\n    &#125;\n\n    class Sub : Base\n    &#123; &#125;\n    class Program\n    &#123;\n        static void Main()\n        &#123;\n            Sub sub &#x3D; new Sub();\n            Base b1 &#x3D; sub as Base;\n            if (b1 !&#x3D; null)\n            &#123;\n                Console.WriteLine(b1.Test);\n            &#125;\n        &#125;\n    &#125;\n&#125;<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<h1 id=\"泛型\"><a href=\"#泛型\" class=\"headerlink\" title=\"泛型\"></a>泛型</h1><p>C#提供了5中泛型：类，结构，接口，委托和方法</p>\n<h2 id=\"泛型类\"><a href=\"#泛型类\" class=\"headerlink\" title=\"泛型类\"></a>泛型类</h2><h3 id=\"声明泛型类\"><a href=\"#声明泛型类\" class=\"headerlink\" title=\"声明泛型类\"></a>声明泛型类</h3><ul>\n<li><p>在类名之后放置一组尖括号&lt;&gt;</p>\n</li>\n<li><p>在尖括号中用逗号分隔的占位符来表示需要提供的类型，叫做类型参数</p>\n</li>\n<li><p>在泛型类声明的主体中使用类型参数来表示替代类型</p>\n</li>\n<li><p>示例</p>\n<pre class=\"line-numbers language-c#\" data-language=\"c#\"><code class=\"language-c#\">class Test&lt;T1, T2&gt;\n&#123;\n    public T1 t1;\n    public T2 t2;\n&#125;<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span></span></code></pre></li>\n</ul>\n<h3 id=\"创建构造类型\"><a href=\"#创建构造类型\" class=\"headerlink\" title=\"创建构造类型\"></a>创建构造类型</h3><pre class=\"line-numbers language-c#\" data-language=\"c#\"><code class=\"language-c#\">Test&lt;int,float&gt; test &#x3D; new Test&lt;int,float&gt;();<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span></span></code></pre>\n\n<h2 id=\"类型参数的约束\"><a href=\"#类型参数的约束\" class=\"headerlink\" title=\"类型参数的约束\"></a>类型参数的约束</h2><p>可以额外提供一些信息让编译器知道参数可以接受哪些类型（约束）</p>\n<h3 id=\"Where子句\"><a href=\"#Where子句\" class=\"headerlink\" title=\"Where子句\"></a>Where子句</h3><p>约束使用where子句列出</p>\n<ul>\n<li><p>每一个有约束的类型参数都有自己的where子句</p>\n</li>\n<li><p>如果形参有多个约束，在where子句中使用逗号分隔</p>\n</li>\n<li><p>语法</p>\n<pre class=\"line-numbers language-c#\" data-language=\"c#\"><code class=\"language-c#\">where 类型参数:约束列表<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span></span></code></pre></li>\n<li><p>注意事项</p>\n<ul>\n<li>在类型参数列表的关闭尖括号之后列出</li>\n<li>不使用逗号或其它分隔符分隔</li>\n<li>可以以任何次序列出</li>\n<li>where是上下文关键字，所以可以在其它上下文中使用</li>\n</ul>\n</li>\n</ul>\n<pre class=\"line-numbers language-c#\" data-language=\"c#\"><code class=\"language-c#\">class Test&lt;T1, T2&gt; where T1 : IComparable where T2 : IComparable\n&#123;\n    \n&#125;<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span></span></code></pre>\n\n<h3 id=\"约束类型和次序\"><a href=\"#约束类型和次序\" class=\"headerlink\" title=\"约束类型和次序\"></a>约束类型和次序</h3><p><img src=\"https://cbaoblog.oss-cn-shanghai.aliyuncs.com/img/QQ%E6%88%AA%E5%9B%BE20230418211553.png\" alt=\"QQ截图20230418211553\"></p>\n<p>where子句可以以任何次序列出。然而where子句中的约束必须有特定的顺序</p>\n<ul>\n<li>最多只能有一个主约束，而且必须放在第一位</li>\n<li>可以有任意多的接口名称约束</li>\n<li>如果存在构造函数约束，则必须放在最后</li>\n</ul>\n<p><img src=\"https://cbaoblog.oss-cn-shanghai.aliyuncs.com/img/QQ%E6%88%AA%E5%9B%BE20230418212037.png\" alt=\"QQ截图20230418212037\"></p>\n<h2 id=\"泛型方法\"><a href=\"#泛型方法\" class=\"headerlink\" title=\"泛型方法\"></a>泛型方法</h2><p>泛型方法是成员，不是类型，泛型方法可以在泛型和非泛型以及结构和接口中声明</p>\n<h3 id=\"声明泛型方法\"><a href=\"#声明泛型方法\" class=\"headerlink\" title=\"声明泛型方法\"></a>声明泛型方法</h3><p>泛型方法具有类型参数列表和可选的约束</p>\n<ul>\n<li><p>泛型方法有两个参数列表</p>\n<ul>\n<li>封闭在圆括号内的方法参数列表</li>\n<li>封闭在尖括号内的类型参数列表</li>\n</ul>\n</li>\n<li><p>声明泛型方法</p>\n<ul>\n<li>在方法名称之后和方法参数列表之前放置类型参数列表</li>\n<li>在方法参数列表后放置可选的约束子句</li>\n</ul>\n<pre class=\"line-numbers language-c#\" data-language=\"c#\"><code class=\"language-c#\">public void TestFunc&lt;T1, T2&gt;(T1 p, T2 p2) where T1 : class where T2 : struct\n&#123;\n    \n&#125;<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span></span></code></pre></li>\n</ul>\n<div class=\"custom-quote warning\">\n<span class=\"custom-quote-svg\"><svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"\" xmlns=\"http://www.w3.org/2000/svg\" data-reactroot=\"\">\n<path fill=\"\" d=\"M20.86 14.13C20 14.7 19.56 15.74 19.77 16.76C20.13 18.55 18.55 20.13 16.76 19.77C15.74 19.57 14.7 20 14.13 20.86C13.12 22.38 10.89 22.38 9.88 20.86C9.3 20 8.26 19.56 7.24 19.77C5.45 20.13 3.87 18.55 4.23 16.76C4.43 15.74 4 14.7 3.14 14.13C1.62 13.12 1.62 10.89 3.14 9.88C4 9.3 4.44 8.26 4.23 7.24C3.87 5.45 5.45 3.87 7.24 4.23C8.26 4.44 9.3 4 9.87 3.14C10.88 1.62 13.11 1.62 14.12 3.14C14.7 4 15.74 4.44 16.76 4.23C18.55 3.87 20.13 5.45 19.77 7.24C19.56 8.26 20 9.3 20.86 9.87C22.38 10.88 22.38 13.12 20.86 14.13Z\" undefined=\"1\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M12 8V13\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M12 15.99V16.01\"></path>\n</svg>\n</span>\n<p class=\"custom-quote-title\">注意</p>\n<p><p>​        类型参数列表在方法名称之后，在方法参数列表之前</p>\n</p>\n</div>\n<h3 id=\"调用泛型方法\"><a href=\"#调用泛型方法\" class=\"headerlink\" title=\"调用泛型方法\"></a>调用泛型方法</h3><p>调用泛型方法时，需要提供类型实参</p>\n<pre class=\"line-numbers language-c#\" data-language=\"c#\"><code class=\"language-c#\">Program p1 &#x3D; new Program();\np1.TestFunc&lt;string, int&gt;(&quot;tset&quot;, 20);\n&#x2F;&#x2F;由于编译器可以从方法参数中推断类型参数，可以省略类型参数和调用中的尖括号\np1.TestFunc(&quot;test&quot;, 20);<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span></span></code></pre>\n\n<h3 id=\"拓展方法和泛型类\"><a href=\"#拓展方法和泛型类\" class=\"headerlink\" title=\"拓展方法和泛型类\"></a>拓展方法和泛型类</h3><p>泛型类的拓展方法</p>\n<ul>\n<li><p>必须声明为static</p>\n</li>\n<li><p>必须是静态类的成员</p>\n</li>\n<li><p>第一个参数类型中必须有关键字this，后面是拓展的泛型类的名字</p>\n</li>\n<li><p>示例</p>\n<pre class=\"line-numbers language-c#\" data-language=\"c#\"><code class=\"language-c#\">using System;\n\nnamespace EventLearn\n&#123;\n    class Test&lt;T&gt;\n    &#123;\n        public T Value &#123; get; set; &#125;\n    &#125;\n\n    static class TestEx\n    &#123;\n        &#x2F;&#x2F;声明一个拓展方法\n        public static void PrintfFunc&lt;T&gt;(this Test&lt;T&gt; test)\n        &#123;\n            Console.WriteLine(test.Value);\n        &#125;\n    &#125;\n\n    class Program\n    &#123;\n      \n\n        static void Main()\n        &#123;\n            Test&lt;int&gt; test &#x3D; new Test&lt;int&gt;();\n            test.Value &#x3D; 100;\n            &#x2F;&#x2F;调用拓展方法\n            test.PrintfFunc();\n        &#125;\n    &#125;\n&#125;<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li>\n</ul>\n<h2 id=\"泛型结构\"><a href=\"#泛型结构\" class=\"headerlink\" title=\"泛型结构\"></a>泛型结构</h2><p>与泛型类相似，泛型结构可以有类型参数和约束。泛型结构的规则和条件与泛型是一样的。</p>\n<h2 id=\"泛型委托\"><a href=\"#泛型委托\" class=\"headerlink\" title=\"泛型委托\"></a>泛型委托</h2><ul>\n<li><p>要声明泛型委托，在委托名称之后，委托参数列表之前的尖括号中放置类型参数列表</p>\n</li>\n<li><p>泛型委托有两个参数列表：委托形参列表和类型参数列表</p>\n</li>\n<li><p>类型参数的范围包括</p>\n<ul>\n<li>返回类型</li>\n<li>形参列表</li>\n<li>约束子句</li>\n</ul>\n</li>\n<li><p>示例</p>\n<pre class=\"line-numbers language-c#\" data-language=\"c#\"><code class=\"language-c#\">using System;\n\nnamespace EventLearn\n&#123;\n    &#x2F;&#x2F;声明一个泛型委托\n    delegate R MyDelegate&lt;R, T&gt;(T value);\n\n    class Program\n    &#123;    \n        static void Main()\n        &#123;\n            Program p&#x3D;new Program();\n            var dele &#x3D; new MyDelegate&lt;int, string&gt;(p.Func);\n            dele(&quot;33333&quot;);\n        &#125;\n\n        public int Func(string value)\n        &#123;\n            Console.WriteLine(value);\n            return 0;\n        &#125;\n    &#125;\n&#125;<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li>\n</ul>\n<h2 id=\"泛型接口\"><a href=\"#泛型接口\" class=\"headerlink\" title=\"泛型接口\"></a>泛型接口</h2><p>泛型接口允许编写形参和接口成员返回类型是泛型类型参数的接口</p>\n<pre class=\"line-numbers language-c#\" data-language=\"c#\"><code class=\"language-c#\">using System;\n\nnamespace EventLearn\n&#123;\n    &#x2F;&#x2F;声明一个泛型接口\n    interface ITest&lt;T&gt;\n    &#123;\n        void PrintfInterface(T value);\n    &#125;\n\n    class TestClass : ITest&lt;int&gt;,ITest&lt;string&gt;\n    &#123;\n        public void PrintfInterface(int value)\n        &#123;\n            Console.WriteLine($&quot;int类型:&#123;value&#125;&quot;);\n        &#125;\n\n        public void PrintfInterface(string value)\n        &#123;\n            Console.WriteLine($&quot;string类型:&#123;value&#125;&quot;);\n        &#125;\n    &#125;\n\n\n    class Program\n    &#123;    \n        static void Main()\n        &#123;\n            TestClass testClass &#x3D; new TestClass();\n            testClass.PrintfInterface(20);\n            testClass.PrintfInterface(&quot;sss&quot;);\n        &#125;\n    &#125;\n&#125;<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<h2 id=\"协变和逆变\"><a href=\"#协变和逆变\" class=\"headerlink\" title=\"协变和逆变\"></a>协变和逆变</h2><h3 id=\"协变\"><a href=\"#协变\" class=\"headerlink\" title=\"协变\"></a>协变</h3><p>协变允许你将一个派生类类型（子类）的泛型实例赋值给基类类型（父类）的泛型实例。在C#中， <strong>协变仅适用于泛型接口和委托</strong> ，并且只有在返回类型中使用泛型参数时才能支持协变。要在泛型接口或委托中启用协变，需要使用<code>out</code>关键字。</p>\n<pre class=\"line-numbers language-c#\" data-language=\"c#\"><code class=\"language-c#\">public interface ICovariant&lt;out T&gt;\n&#123;\n    T Get();\n&#125;\n\npublic class CovariantClass&lt;T&gt; : ICovariant&lt;T&gt;\n&#123;\n    public T Get()\n    &#123;\n        &#x2F;&#x2F; ...\n    &#125;\n&#125;\n\nICovariant&lt;Animal&gt; animals &#x3D; new CovariantClass&lt;Animal&gt;();\nICovariant&lt;Mammal&gt; mammals &#x3D; new CovariantClass&lt;Mammal&gt;();\nICovariant&lt;Cat&gt; cats &#x3D; new CovariantClass&lt;Cat&gt;();\n\nanimals &#x3D; mammals; &#x2F;&#x2F; 协变允许这样的赋值\nanimals &#x3D; cats;    &#x2F;&#x2F; 协变允许这样的赋值<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<h3 id=\"逆变\"><a href=\"#逆变\" class=\"headerlink\" title=\"逆变\"></a>逆变</h3><p>逆变允许你将基类类型（父类）的泛型实例赋值给派生类类型（子类）的泛型实例。在C#中， <strong>逆变仅适用于泛型接口和委托</strong> ，并且只有在参数类型中使用泛型参数时才能支持逆变。要在泛型接口或委托中启用逆变，需要使用<code>in</code>关键字。</p>\n<pre class=\"line-numbers language-c#\" data-language=\"c#\"><code class=\"language-c#\">public interface IContravariant&lt;in T&gt;\n&#123;\n    void Set(T item);\n&#125;\n\npublic class ContravariantClass&lt;T&gt; : IContravariant&lt;T&gt;\n&#123;\n    public void Set(T item)\n    &#123;\n        &#x2F;&#x2F; ...\n    &#125;\n&#125;\n\nIContravariant&lt;Cat&gt; cats &#x3D; new ContravariantClass&lt;Cat&gt;();\nIContravariant&lt;Mammal&gt; mammals &#x3D; new ContravariantClass&lt;Mammal&gt;();\nIContravariant&lt;Animal&gt; animals &#x3D; new ContravariantClass&lt;Animal&gt;();\n\ncats &#x3D; mammals; &#x2F;&#x2F; 逆变允许这样的赋值\ncats &#x3D; animals; &#x2F;&#x2F; 逆变允许这样的赋值<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<div class=\"custom-quote warning\">\n<span class=\"custom-quote-svg\"><svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"\" xmlns=\"http://www.w3.org/2000/svg\" data-reactroot=\"\">\n<path fill=\"\" d=\"M20.86 14.13C20 14.7 19.56 15.74 19.77 16.76C20.13 18.55 18.55 20.13 16.76 19.77C15.74 19.57 14.7 20 14.13 20.86C13.12 22.38 10.89 22.38 9.88 20.86C9.3 20 8.26 19.56 7.24 19.77C5.45 20.13 3.87 18.55 4.23 16.76C4.43 15.74 4 14.7 3.14 14.13C1.62 13.12 1.62 10.89 3.14 9.88C4 9.3 4.44 8.26 4.23 7.24C3.87 5.45 5.45 3.87 7.24 4.23C8.26 4.44 9.3 4 9.87 3.14C10.88 1.62 13.11 1.62 14.12 3.14C14.7 4 15.74 4.44 16.76 4.23C18.55 3.87 20.13 5.45 19.77 7.24C19.56 8.26 20 9.3 20.86 9.87C22.38 10.88 22.38 13.12 20.86 14.13Z\" undefined=\"1\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M12 8V13\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M12 15.99V16.01\"></path>\n</svg>\n</span>\n<p class=\"custom-quote-title\">注意</p>\n<p>​        请注意，协变和逆变仅适用于引用类型，不适用于值类型。这是因为值类型的变量直接包含其数据，而引用类型的变量只是对内存中实际对象的引用。</p>\n\n</div>\n","feature":true,"text":"C#中的命名约定 风格名称 描述 推荐使用 示例 Pascal大小写 标识符每个单词首字母大写 用于类型名称和类中对外可见成员的名称（类，方法，命名空间，属性和公有字段） CardDeck Camel大小写 标识符每个单词首字母大写，第一个单词除外 用于局部变量的名称和方法声明的...","link":"","photos":[],"count_time":{"symbolsCount":"44k","symbolsTime":"40 mins."},"categories":[{"name":"C#","slug":"C","count":1,"path":"api/categories/C.json"}],"tags":[{"name":"C#","slug":"C","count":1,"path":"api/tags/C.json"}],"toc":"<ol class=\"toc\"><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#C-%E4%B8%AD%E7%9A%84%E5%91%BD%E5%90%8D%E7%BA%A6%E5%AE%9A\"><span class=\"toc-text\">C#中的命名约定</span></a></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#C-%E7%A8%8B%E5%BA%8F%E7%9A%84%E8%B5%B7%E7%82%B9%EF%BC%9AMain\"><span class=\"toc-text\">C#程序的起点：Main</span></a></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#%E7%A9%BA%E7%99%BD%E7%AC%A6\"><span class=\"toc-text\">空白符</span></a></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#%E5%9D%97\"><span class=\"toc-text\">块</span></a></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#%E4%BB%8E%E7%A8%8B%E5%BA%8F%E4%B8%AD%E8%BE%93%E5%87%BA%E6%96%87%E6%9C%AC\"><span class=\"toc-text\">从程序中输出文本</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#Write\"><span class=\"toc-text\">Write</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#WriteLine\"><span class=\"toc-text\">WriteLine</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E6%A0%BC%E5%BC%8F%E5%AD%97%E7%AC%A6%E4%B8%B2\"><span class=\"toc-text\">格式字符串</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E5%A4%9A%E9%87%8D%E6%A0%87%E8%AE%B0%E5%92%8C%E5%80%BC\"><span class=\"toc-text\">多重标记和值</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E6%A0%BC%E5%BC%8F%E5%8C%96%E6%95%B0%E5%AD%97%E5%AD%97%E7%AC%A6%E4%B8%B2\"><span class=\"toc-text\">格式化数字字符串</span></a></li></ol></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#%E6%B3%A8%E9%87%8A\"><span class=\"toc-text\">注释</span></a></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#%E9%A2%84%E5%AE%9A%E4%B9%89%E7%B1%BB%E5%9E%8B\"><span class=\"toc-text\">预定义类型</span></a></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#%E7%94%A8%E6%88%B7%E5%AE%9A%E4%B9%89%E7%B1%BB%E5%9E%8B\"><span class=\"toc-text\">用户定义类型</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#6%E7%A7%8D%E7%B1%BB%E5%9E%8B%E5%8F%AF%E4%BB%A5%E7%94%B1%E7%94%A8%E6%88%B7%E8%87%AA%E5%B7%B1%E5%88%9B%E5%BB%BA\"><span class=\"toc-text\">6种类型可以由用户自己创建</span></a></li></ol></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#%E6%A0%88%E5%92%8C%E5%A0%86\"><span class=\"toc-text\">栈和堆</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E6%A0%88\"><span class=\"toc-text\">栈</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E5%A0%86\"><span class=\"toc-text\">堆</span></a></li></ol></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#%E5%80%BC%E7%B1%BB%E5%9E%8B%E5%92%8C%E5%BC%95%E7%94%A8%E7%B1%BB%E5%9E%8B\"><span class=\"toc-text\">值类型和引用类型</span></a></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#%E7%B1%BB\"><span class=\"toc-text\">类</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E5%A3%B0%E6%98%8E%E7%B1%BB\"><span class=\"toc-text\">声明类</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E7%B1%BB%E6%88%90%E5%91%98\"><span class=\"toc-text\">类成员</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E4%B8%BA%E6%95%B0%E6%8D%AE%E5%88%86%E9%85%8D%E5%86%85%E5%AD%98\"><span class=\"toc-text\">为数据分配内存</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E8%AE%BF%E9%97%AE%E4%BF%AE%E9%A5%B0%E7%AC%A6\"><span class=\"toc-text\">访问修饰符</span></a></li></ol></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#%E6%96%B9%E6%B3%95\"><span class=\"toc-text\">方法</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E6%96%B9%E6%B3%95%E7%9A%84%E7%BB%93%E6%9E%84\"><span class=\"toc-text\">方法的结构</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E6%96%B9%E6%B3%95%E5%A4%B4\"><span class=\"toc-text\">方法头</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E6%96%B9%E6%B3%95%E4%BD%93\"><span class=\"toc-text\">方法体</span></a></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E6%96%B9%E6%B3%95%E4%BD%93%E5%86%85%E9%83%A8%E7%9A%84%E4%BB%A3%E7%A0%81%E6%89%A7%E8%A1%8C\"><span class=\"toc-text\">方法体内部的代码执行</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E5%B1%80%E9%83%A8%E5%8F%98%E9%87%8F\"><span class=\"toc-text\">局部变量</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E6%8E%A7%E5%88%B6%E6%B5%81\"><span class=\"toc-text\">控制流</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E9%80%89%E6%8B%A9%E8%AF%AD%E5%8F%A5\"><span class=\"toc-text\">选择语句</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E8%BF%AD%E4%BB%A3%E8%AF%AD%E5%8F%A5\"><span class=\"toc-text\">迭代语句</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E8%B7%B3%E8%BD%AC%E8%AF%AD%E5%8F%A5\"><span class=\"toc-text\">跳转语句</span></a></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E8%BF%94%E5%9B%9E%E5%80%BC\"><span class=\"toc-text\">返回值</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E5%8F%82%E6%95%B0\"><span class=\"toc-text\">参数</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E5%BD%A2%E5%8F%82\"><span class=\"toc-text\">形参</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E5%AE%9E%E5%8F%82\"><span class=\"toc-text\">实参</span></a></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E5%80%BC%E5%8F%82%E6%95%B0\"><span class=\"toc-text\">值参数</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E5%BC%95%E7%94%A8%E5%8F%82%E6%95%B0\"><span class=\"toc-text\">引用参数</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E5%BC%95%E7%94%A8%E7%B1%BB%E5%9E%8B%E4%BD%9C%E4%B8%BA%E5%80%BC%E5%8F%82%E6%95%B0%E5%92%8C%E5%BC%95%E7%94%A8%E5%8F%82%E6%95%B0\"><span class=\"toc-text\">引用类型作为值参数和引用参数</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E8%BE%93%E5%87%BA%E5%8F%82%E6%95%B0\"><span class=\"toc-text\">输出参数</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E5%8F%82%E6%95%B0%E6%95%B0%E7%BB%84\"><span class=\"toc-text\">参数数组</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E5%8F%82%E6%95%B0%E7%B1%BB%E5%9E%8B%E6%80%BB%E7%BB%93\"><span class=\"toc-text\">参数类型总结</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#ref%E5%B1%80%E9%83%A8%E5%8F%98%E9%87%8F%E5%92%8Cref%E8%BF%94%E5%9B%9E\"><span class=\"toc-text\">ref局部变量和ref返回</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#ref%E5%B1%80%E9%83%A8%E5%8F%98%E9%87%8F\"><span class=\"toc-text\">ref局部变量</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#ref%E8%BF%94%E5%9B%9E\"><span class=\"toc-text\">ref返回</span></a></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E6%96%B9%E6%B3%95%E9%87%8D%E8%BD%BD\"><span class=\"toc-text\">方法重载</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E9%80%92%E5%BD%92\"><span class=\"toc-text\">递归</span></a></li></ol></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E7%B1%BB\"><span class=\"toc-text\">深入理解类</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E6%88%90%E5%91%98%E4%BF%AE%E9%A5%B0%E7%AC%A6%E7%9A%84%E9%A1%BA%E5%BA%8F\"><span class=\"toc-text\">成员修饰符的顺序</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E9%9D%99%E6%80%81%E5%AD%97%E6%AE%B5\"><span class=\"toc-text\">静态字段</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E9%9D%99%E6%80%81%E5%87%BD%E6%95%B0%E6%88%90%E5%91%98\"><span class=\"toc-text\">静态函数成员</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E6%88%90%E5%91%98%E5%B8%B8%E9%87%8F\"><span class=\"toc-text\">成员常量</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E5%B1%9E%E6%80%A7\"><span class=\"toc-text\">属性</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E5%8F%AA%E8%AF%BB%E5%92%8C%E5%8F%AA%E5%86%99%E5%B1%9E%E6%80%A7\"><span class=\"toc-text\">只读和只写属性</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E5%B1%9E%E6%80%A7%E4%B8%8E%E5%85%AC%E6%9C%89%E5%AD%97%E6%AE%B5\"><span class=\"toc-text\">属性与公有字段</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E8%87%AA%E5%8A%A8%E5%AE%9E%E7%8E%B0%E5%B1%9E%E6%80%A7\"><span class=\"toc-text\">自动实现属性</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E9%9D%99%E6%80%81%E5%B1%9E%E6%80%A7\"><span class=\"toc-text\">静态属性</span></a></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E5%AE%9E%E4%BE%8B%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0\"><span class=\"toc-text\">实例构造函数</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E9%9D%99%E6%80%81%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0\"><span class=\"toc-text\">静态构造函数</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E5%AF%B9%E8%B1%A1%E5%88%9D%E5%A7%8B%E5%8C%96%E8%AF%AD%E5%8F%A5\"><span class=\"toc-text\">对象初始化语句</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E6%9E%90%E6%9E%84%E5%87%BD%E6%95%B0\"><span class=\"toc-text\">析构函数</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#readonly%E4%BF%AE%E9%A5%B0%E7%AC%A6\"><span class=\"toc-text\">readonly修饰符</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#this%E5%85%B3%E9%94%AE%E5%AD%97\"><span class=\"toc-text\">this关键字</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E7%B4%A2%E5%BC%95%E5%99%A8\"><span class=\"toc-text\">索引器</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E5%A3%B0%E6%98%8E%E7%B4%A2%E5%BC%95%E5%99%A8\"><span class=\"toc-text\">声明索引器</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E7%B4%A2%E5%BC%95%E5%99%A8%E7%9A%84set%E8%AE%BF%E9%97%AE%E5%99%A8\"><span class=\"toc-text\">索引器的set访问器</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E7%B4%A2%E5%BC%95%E5%99%A8%E7%A4%BA%E4%BE%8B\"><span class=\"toc-text\">索引器示例</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E7%B4%A2%E5%BC%95%E5%99%A8%E9%87%8D%E8%BD%BD\"><span class=\"toc-text\">索引器重载</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E8%AE%BF%E9%97%AE%E5%99%A8%E7%9A%84%E8%AE%BF%E9%97%AE%E4%BF%AE%E9%A5%B0%E7%AC%A6\"><span class=\"toc-text\">访问器的访问修饰符</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E5%88%86%E9%83%A8%E7%B1%BB%E5%92%8C%E5%88%86%E9%83%A8%E7%B1%BB%E5%9E%8B\"><span class=\"toc-text\">分部类和分部类型</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E5%88%86%E9%83%A8%E6%96%B9%E6%B3%95\"><span class=\"toc-text\">分部方法</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E5%88%86%E9%83%A8%E6%96%B9%E6%B3%95%E7%9A%84%E4%B8%A4%E4%B8%AA%E9%83%A8%E5%88%86\"><span class=\"toc-text\">分部方法的两个部分</span></a></li></ol></li></ol></li></ol></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#%E7%B1%BB%E5%92%8C%E7%BB%A7%E6%89%BF\"><span class=\"toc-text\">类和继承</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E7%B1%BB%E7%BB%A7%E6%89%BF\"><span class=\"toc-text\">类继承</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E8%AE%BF%E9%97%AE%E7%BB%A7%E6%89%BF%E7%9A%84%E6%88%90%E5%91%98\"><span class=\"toc-text\">访问继承的成员</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E6%89%80%E6%9C%89%E7%B1%BB%E9%83%BD%E6%B4%BE%E7%94%9F%E8%87%AAobject\"><span class=\"toc-text\">所有类都派生自object</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E5%B1%8F%E8%94%BD%E5%9F%BA%E7%B1%BB%E6%88%90%E5%91%98\"><span class=\"toc-text\">屏蔽基类成员</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E5%9F%BA%E7%B1%BB%E8%AE%BF%E9%97%AE\"><span class=\"toc-text\">基类访问</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E4%BD%BF%E7%94%A8%E5%9F%BA%E7%B1%BB%E7%9A%84%E5%BC%95%E7%94%A8\"><span class=\"toc-text\">使用基类的引用</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E8%99%9A%E6%96%B9%E6%B3%95%E5%92%8C%E8%A6%86%E5%86%99%E6%96%B9%E6%B3%95\"><span class=\"toc-text\">虚方法和覆写方法</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E4%BD%BF%E7%94%A8%E5%9F%BA%E7%B1%BB%E5%BC%95%E7%94%A8%E8%B0%83%E7%94%A8%E6%B4%BE%E7%94%9F%E7%B1%BB%E6%96%B9%E6%B3%95\"><span class=\"toc-text\">使用基类引用调用派生类方法</span></a></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E8%A6%86%E5%86%99%E6%A0%87%E8%AE%B0%E4%B8%BAoverride%E7%9A%84%E6%96%B9%E6%B3%95\"><span class=\"toc-text\">覆写标记为override的方法</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%E6%89%A7%E8%A1%8C\"><span class=\"toc-text\">构造函数执行</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%E5%88%9D%E5%A7%8B%E5%8C%96%E8%AF%AD%E5%8F%A5\"><span class=\"toc-text\">构造函数初始化语句</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E7%B1%BB%E8%AE%BF%E9%97%AE%E4%BF%AE%E9%A5%B0%E7%AC%A6\"><span class=\"toc-text\">类访问修饰符</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E7%A8%8B%E5%BA%8F%E9%9B%86%E4%B9%8B%E9%97%B4%E7%9A%84%E7%BB%A7%E6%89%BF\"><span class=\"toc-text\">程序集之间的继承</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E6%88%90%E5%91%98%E8%AE%BF%E9%97%AE%E4%BF%AE%E9%A5%B0%E7%AC%A6\"><span class=\"toc-text\">成员访问修饰符</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E6%8A%BD%E8%B1%A1%E6%88%90%E5%91%98\"><span class=\"toc-text\">抽象成员</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E6%8A%BD%E8%B1%A1%E7%B1%BB\"><span class=\"toc-text\">抽象类</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E5%AF%86%E5%B0%81%E7%B1%BB\"><span class=\"toc-text\">密封类</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E9%9D%99%E6%80%81%E7%B1%BB\"><span class=\"toc-text\">静态类</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E6%8B%93%E5%B1%95%E6%96%B9%E6%B3%95\"><span class=\"toc-text\">拓展方法</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E4%B8%BA%E4%B8%80%E4%B8%AA%E7%B1%BB%E6%B7%BB%E5%8A%A0%E6%96%B9%E6%B3%95%E7%9A%84%E5%87%A0%E7%A7%8D%E6%96%B9%E5%BC%8F\"><span class=\"toc-text\">为一个类添加方法的几种方式</span></a></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E5%91%BD%E5%90%8D%E7%BA%A6%E5%AE%9A\"><span class=\"toc-text\">命名约定</span></a></li></ol></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#%E8%A1%A8%E8%BE%BE%E5%BC%8F%E5%92%8C%E8%BF%90%E7%AE%97%E7%AC%A6\"><span class=\"toc-text\">表达式和运算符</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E8%BF%90%E7%AE%97%E7%AC%A6\"><span class=\"toc-text\">运算符</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E5%AD%97%E9%9D%A2%E9%87%8F\"><span class=\"toc-text\">字面量</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E6%95%B4%E6%95%B0%E5%AD%97%E9%9D%A2%E9%87%8F\"><span class=\"toc-text\">整数字面量</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E5%AE%9E%E6%95%B0%E5%AD%97%E9%9D%A2%E9%87%8F\"><span class=\"toc-text\">实数字面量</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E5%AD%97%E7%AC%A6%E5%AD%97%E9%9D%A2%E9%87%8F\"><span class=\"toc-text\">字符字面量</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%AD%97%E9%9D%A2%E9%87%8F\"><span class=\"toc-text\">字符串字面量</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E6%B1%82%E5%80%BC%E9%A1%BA%E5%BA%8F\"><span class=\"toc-text\">求值顺序</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E6%AF%94%E8%BE%83%E6%93%8D%E4%BD%9C%E5%92%8C%E7%9B%B8%E7%AD%89%E6%80%A7%E6%93%8D%E4%BD%9C\"><span class=\"toc-text\">比较操作和相等性操作</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E9%80%92%E5%A2%9E%E5%92%8C%E9%80%92%E5%87%8F%E8%BF%90%E7%AE%97%E7%AC%A6\"><span class=\"toc-text\">递增和递减运算符</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E6%9D%A1%E4%BB%B6%E9%80%BB%E8%BE%91%E8%BF%90%E7%AE%97%E7%AC%A6\"><span class=\"toc-text\">条件逻辑运算符</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E9%80%BB%E8%BE%91%E8%BF%90%E7%AE%97%E7%AC%A6\"><span class=\"toc-text\">逻辑运算符</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E7%94%A8%E6%88%B7%E5%AE%9A%E4%B9%89%E7%9A%84%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2\"><span class=\"toc-text\">用户定义的类型转换</span></a></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E8%BF%90%E7%AE%97%E7%AC%A6%E9%87%8D%E8%BD%BD\"><span class=\"toc-text\">运算符重载</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#typeof%E8%BF%90%E7%AE%97%E7%AC%A6\"><span class=\"toc-text\">typeof运算符</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#nameof%E8%BF%90%E7%AE%97%E7%AC%A6\"><span class=\"toc-text\">nameof运算符</span></a></li></ol></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#%E8%AF%AD%E5%8F%A5\"><span class=\"toc-text\">语句</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E6%8E%A7%E5%88%B6%E6%B5%81%E8%AF%AD%E5%8F%A5\"><span class=\"toc-text\">控制流语句</span></a></li></ol></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#%E7%BB%93%E6%9E%84\"><span class=\"toc-text\">结构</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E7%BB%93%E6%9E%84%E6%98%AF%E5%80%BC%E7%B1%BB%E5%9E%8B\"><span class=\"toc-text\">结构是值类型</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E5%AF%B9%E7%BB%93%E6%9E%84%E8%B5%8B%E5%80%BC\"><span class=\"toc-text\">对结构赋值</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%E5%92%8C%E6%9E%90%E6%9E%84%E5%87%BD%E6%95%B0\"><span class=\"toc-text\">构造函数和析构函数</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E9%9D%99%E6%80%81%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0-1\"><span class=\"toc-text\">静态构造函数</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E7%BB%93%E6%9E%84%E7%9A%84%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%E5%92%8C%E6%9E%90%E6%9E%84%E5%87%BD%E6%95%B0%E5%B0%8F%E7%BB%93\"><span class=\"toc-text\">结构的构造函数和析构函数小结</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E5%B1%9E%E6%80%A7%E5%92%8C%E5%AD%97%E6%AE%B5%E5%88%9D%E5%A7%8B%E5%8C%96%E8%AF%AD%E5%8F%A5\"><span class=\"toc-text\">属性和字段初始化语句</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E7%BB%93%E6%9E%84%E6%98%AF%E5%AF%86%E5%B0%81%E7%9A%84\"><span class=\"toc-text\">结构是密封的</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E8%A3%85%E7%AE%B1%E5%92%8C%E6%8B%86%E7%AE%B1\"><span class=\"toc-text\">装箱和拆箱</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E7%BB%93%E6%9E%84%E4%BD%9C%E4%B8%BA%E8%BF%94%E5%9B%9E%E5%80%BC%E5%92%8C%E5%8F%82%E6%95%B0\"><span class=\"toc-text\">结构作为返回值和参数</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E7%BB%93%E6%9E%84%E7%9A%84%E5%85%B6%E5%AE%83%E5%86%85%E5%AE%B9\"><span class=\"toc-text\">结构的其它内容</span></a></li></ol></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#%E6%9E%9A%E4%B8%BE\"><span class=\"toc-text\">枚举</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E8%AE%BE%E7%BD%AE%E5%BA%95%E5%B1%82%E7%B1%BB%E5%9E%8B%E5%92%8C%E6%98%BE%E5%BC%8F%E5%80%BC\"><span class=\"toc-text\">设置底层类型和显式值</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E4%BD%8D%E6%A0%87%E8%AE%B0\"><span class=\"toc-text\">位标记</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E5%85%B3%E4%BA%8E%E6%9E%9A%E4%B8%BE%E7%9A%84%E6%9B%B4%E5%A4%9A%E5%86%85%E5%AE%B9\"><span class=\"toc-text\">关于枚举的更多内容</span></a></li></ol></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#%E6%95%B0%E7%BB%84\"><span class=\"toc-text\">数组</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E5%AE%9A%E4%B9%89\"><span class=\"toc-text\">定义</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E9%87%8D%E8%A6%81%E7%BB%86%E8%8A%82\"><span class=\"toc-text\">重要细节</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E6%95%B0%E7%BB%84%E7%9A%84%E7%B1%BB%E5%9E%8B\"><span class=\"toc-text\">数组的类型</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E4%B8%A4%E7%A7%8D%E7%B1%BB%E5%9E%8B%E7%9A%84%E5%A4%9A%E7%BB%B4%E6%95%B0%E7%BB%84\"><span class=\"toc-text\">两种类型的多维数组</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#C-%E4%B8%AD%E7%9A%84%E5%90%84%E7%A7%8D%E6%95%B0%E7%BB%84%E5%9B%BE%E7%A4%BA\"><span class=\"toc-text\">C#中的各种数组图示</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E6%95%B0%E7%BB%84%E6%98%AF%E5%AF%B9%E8%B1%A1\"><span class=\"toc-text\">数组是对象</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E5%A3%B0%E6%98%8E%E4%B8%80%E7%BB%B4%E6%95%B0%E7%BB%84%E6%88%96%E7%9F%A9%E5%BD%A2%E6%95%B0%E7%BB%84\"><span class=\"toc-text\">声明一维数组或矩形数组</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E4%BA%A4%E9%94%99%E6%95%B0%E7%BB%84\"><span class=\"toc-text\">交错数组</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E6%95%B0%E7%BB%84%E5%8D%8F%E5%8F%98\"><span class=\"toc-text\">数组协变</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E6%95%B0%E7%BB%84%E7%BB%A7%E6%89%BF%E7%9A%84%E6%9C%89%E7%94%A8%E6%88%90%E5%91%98\"><span class=\"toc-text\">数组继承的有用成员</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#Clone%E6%96%B9%E6%B3%95\"><span class=\"toc-text\">Clone方法</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E6%AF%94%E8%BE%83%E6%95%B0%E7%BB%84%E7%B1%BB%E5%9E%8B\"><span class=\"toc-text\">比较数组类型</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E6%95%B0%E7%BB%84%E4%B8%8Eref%E8%BF%94%E5%9B%9E%E5%92%8Cref%E5%B1%80%E9%83%A8%E5%8F%98%E9%87%8F\"><span class=\"toc-text\">数组与ref返回和ref局部变量</span></a></li></ol></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#%E5%A7%94%E6%89%98\"><span class=\"toc-text\">委托</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E4%BB%80%E4%B9%88%E6%98%AF%E5%A7%94%E6%89%98\"><span class=\"toc-text\">什么是委托</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E5%A7%94%E6%89%98%E6%A6%82%E8%BF%B0\"><span class=\"toc-text\">委托概述</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E5%A3%B0%E6%98%8E%E5%A7%94%E6%89%98%E7%B1%BB%E5%9E%8B\"><span class=\"toc-text\">声明委托类型</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E5%88%9B%E5%BB%BA%E5%A7%94%E6%89%98%E5%AF%B9%E8%B1%A1\"><span class=\"toc-text\">创建委托对象</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E7%BB%99%E5%A7%94%E6%89%98%E8%B5%8B%E5%80%BC\"><span class=\"toc-text\">给委托赋值</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E7%BB%84%E5%90%88%E5%A7%94%E6%89%98\"><span class=\"toc-text\">组合委托</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E4%B8%BA%E5%A7%94%E6%89%98%E6%B7%BB%E5%8A%A0%E6%96%B9%E6%B3%95\"><span class=\"toc-text\">为委托添加方法</span></a></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E4%BB%8E%E5%A7%94%E6%89%98%E7%A7%BB%E9%99%A4%E6%96%B9%E6%B3%95\"><span class=\"toc-text\">从委托移除方法</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E8%B0%83%E7%94%A8%E5%A7%94%E6%89%98\"><span class=\"toc-text\">调用委托</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E8%B0%83%E7%94%A8%E5%B8%A6%E8%BF%94%E5%9B%9E%E5%80%BC%E7%9A%84%E5%A7%94%E6%89%98\"><span class=\"toc-text\">调用带返回值的委托</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E8%B0%83%E7%94%A8%E5%B8%A6%E5%BC%95%E7%94%A8%E5%8F%82%E6%95%B0%E7%9A%84%E5%A7%94%E6%89%98\"><span class=\"toc-text\">调用带引用参数的委托</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E5%8C%BF%E5%90%8D%E6%96%B9%E6%B3%95\"><span class=\"toc-text\">匿名方法</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#Lambda\"><span class=\"toc-text\">Lambda</span></a></li></ol></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#%E4%BA%8B%E4%BB%B6\"><span class=\"toc-text\">事件</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E5%8F%91%E5%B8%83%E8%80%85%E5%92%8C%E8%AE%A2%E9%98%85%E8%80%85\"><span class=\"toc-text\">发布者和订阅者</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E5%A3%B0%E6%98%8E%E4%BA%8B%E4%BB%B6\"><span class=\"toc-text\">声明事件</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E4%BA%8B%E4%BB%B6%E6%98%AF%E6%88%90%E5%91%98\"><span class=\"toc-text\">事件是成员</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E8%AE%A2%E9%98%85%E4%BA%8B%E4%BB%B6\"><span class=\"toc-text\">订阅事件</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E8%A7%A6%E5%8F%91%E4%BA%8B%E4%BB%B6\"><span class=\"toc-text\">触发事件</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E5%AE%8C%E6%95%B4%E7%A4%BA%E4%BE%8B\"><span class=\"toc-text\">完整示例</span></a></li></ol></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#%E6%8E%A5%E5%8F%A3\"><span class=\"toc-text\">接口</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E4%BB%80%E4%B9%88%E6%98%AF%E6%8E%A5%E5%8F%A3\"><span class=\"toc-text\">什么是接口</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#IComparable%E6%8E%A5%E5%8F%A3\"><span class=\"toc-text\">IComparable接口</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E5%A3%B0%E6%98%8E%E6%8E%A5%E5%8F%A3\"><span class=\"toc-text\">声明接口</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E5%AE%9E%E7%8E%B0%E6%8E%A5%E5%8F%A3\"><span class=\"toc-text\">实现接口</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E6%8E%A5%E5%8F%A3%E6%98%AF%E5%BC%95%E7%94%A8%E7%B1%BB%E5%9E%8B\"><span class=\"toc-text\">接口是引用类型</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E6%8E%A5%E5%8F%A3%E5%92%8Cas%E8%BF%90%E7%AE%97%E7%AC%A6\"><span class=\"toc-text\">接口和as运算符</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E5%AE%9E%E7%8E%B0%E5%85%B7%E6%9C%89%E9%87%8D%E5%A4%8D%E6%88%90%E5%91%98%E7%9A%84%E6%8E%A5%E5%8F%A3\"><span class=\"toc-text\">实现具有重复成员的接口</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E6%B4%BE%E7%94%9F%E6%88%90%E5%91%98%E4%BD%9C%E4%B8%BA%E6%8E%A5%E5%8F%A3%E5%AE%9E%E7%8E%B0\"><span class=\"toc-text\">派生成员作为接口实现</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E6%98%BE%E5%BC%8F%E6%8E%A5%E5%8F%A3%E6%88%90%E5%91%98%E5%AE%9E%E7%8E%B0\"><span class=\"toc-text\">显式接口成员实现</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E6%8E%A5%E5%8F%A3%E5%8F%AF%E4%BB%A5%E7%BB%A7%E6%89%BF%E6%8E%A5%E5%8F%A3\"><span class=\"toc-text\">接口可以继承接口</span></a></li></ol></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#%E8%BD%AC%E6%8D%A2\"><span class=\"toc-text\">转换</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E4%BB%80%E4%B9%88%E6%98%AF%E8%BD%AC%E6%8D%A2\"><span class=\"toc-text\">什么是转换</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E9%9A%90%E5%BC%8F%E8%BD%AC%E6%8D%A2\"><span class=\"toc-text\">隐式转换</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E6%98%BE%E5%BC%8F%E8%BD%AC%E6%8D%A2%E5%92%8C%E5%BC%BA%E5%88%B6%E8%BD%AC%E6%8D%A2\"><span class=\"toc-text\">显式转换和强制转换</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E6%95%B0%E5%AD%97%E7%9A%84%E8%BD%AC%E6%8D%A2\"><span class=\"toc-text\">数字的转换</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E6%BA%A2%E5%87%BA%E6%A3%80%E6%B5%8B%E4%B8%8A%E4%B8%8B%E6%96%87\"><span class=\"toc-text\">溢出检测上下文</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E5%BC%95%E7%94%A8%E8%BD%AC%E6%8D%A2\"><span class=\"toc-text\">引用转换</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E9%9A%90%E5%BC%8F%E5%BC%95%E7%94%A8%E8%BD%AC%E6%8D%A2\"><span class=\"toc-text\">隐式引用转换</span></a></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E6%98%BE%E5%BC%8F%E5%BC%95%E7%94%A8%E8%BD%AC%E6%8D%A2\"><span class=\"toc-text\">显式引用转换</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E8%A3%85%E7%AE%B1%E8%BD%AC%E6%8D%A2\"><span class=\"toc-text\">装箱转换</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E6%8B%86%E7%AE%B1%E8%BD%AC%E6%8D%A2\"><span class=\"toc-text\">拆箱转换</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E7%94%A8%E6%88%B7%E8%87%AA%E5%AE%9A%E4%B9%89%E7%9A%84%E8%BD%AC%E6%8D%A2\"><span class=\"toc-text\">用户自定义的转换</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E7%94%A8%E6%88%B7%E8%87%AA%E5%AE%9A%E4%B9%89%E8%BD%AC%E6%8D%A2%E7%9A%84%E7%BA%A6%E6%9D%9F\"><span class=\"toc-text\">用户自定义转换的约束</span></a></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#is%E8%BF%90%E7%AE%97%E7%AC%A6\"><span class=\"toc-text\">is运算符</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#as%E8%BF%90%E7%AE%97%E7%AC%A6\"><span class=\"toc-text\">as运算符</span></a></li></ol></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#%E6%B3%9B%E5%9E%8B\"><span class=\"toc-text\">泛型</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E6%B3%9B%E5%9E%8B%E7%B1%BB\"><span class=\"toc-text\">泛型类</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E5%A3%B0%E6%98%8E%E6%B3%9B%E5%9E%8B%E7%B1%BB\"><span class=\"toc-text\">声明泛型类</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E5%88%9B%E5%BB%BA%E6%9E%84%E9%80%A0%E7%B1%BB%E5%9E%8B\"><span class=\"toc-text\">创建构造类型</span></a></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E7%B1%BB%E5%9E%8B%E5%8F%82%E6%95%B0%E7%9A%84%E7%BA%A6%E6%9D%9F\"><span class=\"toc-text\">类型参数的约束</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#Where%E5%AD%90%E5%8F%A5\"><span class=\"toc-text\">Where子句</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E7%BA%A6%E6%9D%9F%E7%B1%BB%E5%9E%8B%E5%92%8C%E6%AC%A1%E5%BA%8F\"><span class=\"toc-text\">约束类型和次序</span></a></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E6%B3%9B%E5%9E%8B%E6%96%B9%E6%B3%95\"><span class=\"toc-text\">泛型方法</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E5%A3%B0%E6%98%8E%E6%B3%9B%E5%9E%8B%E6%96%B9%E6%B3%95\"><span class=\"toc-text\">声明泛型方法</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E8%B0%83%E7%94%A8%E6%B3%9B%E5%9E%8B%E6%96%B9%E6%B3%95\"><span class=\"toc-text\">调用泛型方法</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E6%8B%93%E5%B1%95%E6%96%B9%E6%B3%95%E5%92%8C%E6%B3%9B%E5%9E%8B%E7%B1%BB\"><span class=\"toc-text\">拓展方法和泛型类</span></a></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E6%B3%9B%E5%9E%8B%E7%BB%93%E6%9E%84\"><span class=\"toc-text\">泛型结构</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E6%B3%9B%E5%9E%8B%E5%A7%94%E6%89%98\"><span class=\"toc-text\">泛型委托</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E6%B3%9B%E5%9E%8B%E6%8E%A5%E5%8F%A3\"><span class=\"toc-text\">泛型接口</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E5%8D%8F%E5%8F%98%E5%92%8C%E9%80%86%E5%8F%98\"><span class=\"toc-text\">协变和逆变</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E5%8D%8F%E5%8F%98\"><span class=\"toc-text\">协变</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E9%80%86%E5%8F%98\"><span class=\"toc-text\">逆变</span></a></li></ol></li></ol></li></ol>","author":{"name":"cBao","slug":"blog-author","avatar":"https://cbaoblog.oss-cn-shanghai.aliyuncs.com/HeadPortrait.jpg","link":"/","description":"但求日积月累，收获于细微。<br /><b>虚幻引擎开发</b>","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}},"mapped":true,"prev_post":{},"next_post":{"title":"UE中的网络同步RPC","uid":"321e20a64de3485e0958a3f7db00142f","slug":"UE中的网络同步RPC","date":"2022-08-15T07:32:03.000Z","updated":"2022-08-17T15:26:40.262Z","comments":true,"path":"api/articles/UE中的网络同步RPC.json","keywords":null,"cover":"https://cbaoblog.oss-cn-shanghai.aliyuncs.com/UE5LOGO.png","text":"UE网络中的服务器在哪！ 在UE中存在服务器和客户端重合，创建房间的客户端同时具备服务器特性 UE中服务器和客户端中对象的关系 在服务器端，所有的角色（Actor）都是Authority（权威的） 在客户端眼，除了自己控制的角色外，其他的所有角色都是Simulated proxy...","link":"","photos":[],"count_time":{"symbolsCount":"2k","symbolsTime":"2 mins."},"categories":[{"name":"UnrealEngine","slug":"UnrealEngine","count":4,"path":"api/categories/UnrealEngine.json"}],"tags":[{"name":"网络同步RPC","slug":"网络同步RPC","count":1,"path":"api/tags/网络同步RPC.json"}],"author":{"name":"cBao","slug":"blog-author","avatar":"https://cbaoblog.oss-cn-shanghai.aliyuncs.com/HeadPortrait.jpg","link":"/","description":"但求日积月累，收获于细微。<br /><b>虚幻引擎开发</b>","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}},"feature":true}}