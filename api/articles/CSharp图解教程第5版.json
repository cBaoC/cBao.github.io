{"title":"C#图解教程第5版","uid":"666eeba740dffa28e952c25ed8f5ff46","slug":"CSharp图解教程第5版","date":"2023-03-12T05:00:17.000Z","updated":"2023-03-22T15:52:57.245Z","comments":true,"path":"api/articles/CSharp图解教程第5版.json","keywords":null,"cover":"https://cbaoblog.oss-cn-shanghai.aliyuncs.com/CSharp.png","content":"<h1 id=\"C-中的命名约定\"><a href=\"#C-中的命名约定\" class=\"headerlink\" title=\"C#中的命名约定\"></a>C#中的命名约定</h1><table>\n<thead>\n<tr>\n<th align=\"center\">风格名称</th>\n<th align=\"center\">描述</th>\n<th align=\"center\">推荐使用</th>\n<th align=\"center\">示例</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"center\">Pascal大小写</td>\n<td align=\"center\">标识符每个单词首字母大写</td>\n<td align=\"center\">用于类型名称和类中对外可见成员的名称（类，方法，命名空间，属性和公有字段）</td>\n<td align=\"center\">CardDeck</td>\n</tr>\n<tr>\n<td align=\"center\">Camel大小写</td>\n<td align=\"center\">标识符每个单词首字母大写，第一个单词除外</td>\n<td align=\"center\">用于局部变量的名称和方法声明的形参名称</td>\n<td align=\"center\">cardDeck</td>\n</tr>\n<tr>\n<td align=\"center\">下划线和Camel大小写</td>\n<td align=\"center\">以下划线开头的Camel大小写的标识符</td>\n<td align=\"center\">用于私有和受保护的字段</td>\n<td align=\"center\">_cardDeck</td>\n</tr>\n</tbody></table>\n<div class=\"custom-quote warning\">\n<span class=\"custom-quote-svg\"><svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"\" xmlns=\"http://www.w3.org/2000/svg\" data-reactroot=\"\">\n<path fill=\"\" d=\"M20.86 14.13C20 14.7 19.56 15.74 19.77 16.76C20.13 18.55 18.55 20.13 16.76 19.77C15.74 19.57 14.7 20 14.13 20.86C13.12 22.38 10.89 22.38 9.88 20.86C9.3 20 8.26 19.56 7.24 19.77C5.45 20.13 3.87 18.55 4.23 16.76C4.43 15.74 4 14.7 3.14 14.13C1.62 13.12 1.62 10.89 3.14 9.88C4 9.3 4.44 8.26 4.23 7.24C3.87 5.45 5.45 3.87 7.24 4.23C8.26 4.44 9.3 4 9.87 3.14C10.88 1.62 13.11 1.62 14.12 3.14C14.7 4 15.74 4.44 16.76 4.23C18.55 3.87 20.13 5.45 19.77 7.24C19.56 8.26 20 9.3 20.86 9.87C22.38 10.88 22.38 13.12 20.86 14.13Z\" undefined=\"1\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M12 8V13\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M12 15.99V16.01\"></path>\n</svg>\n</span>\n<p class=\"custom-quote-title\">注意</p>\n<p><ul>\n<li><p>标识符命名可以使用字母，数字，下划线</p>\n</li>\n<li><p>标识符只能以字母和下划线开头，不能以数字开头</p>\n</li>\n<li><p>@字符只能放在标识符首位，不推荐使用</p>\n</li>\n<li><p>不能将关键字用于标识符</p>\n</li>\n<li><p>C#区分大小写</p>\n<p><img src=\"https://cbaoblog.oss-cn-shanghai.aliyuncs.com/img/image-20230312131623748.png\" alt=\"image-20230312131623748\"></p>\n</li>\n</ul>\n</p>\n</div>\n<h1 id=\"C-程序的起点：Main\"><a href=\"#C-程序的起点：Main\" class=\"headerlink\" title=\"C#程序的起点：Main\"></a>C#程序的起点：Main</h1><ul>\n<li><p>每个C#程序必须有一个类带有Main方法</p>\n</li>\n<li><p>每个C#程序的可执行点在Main的第一条指令</p>\n</li>\n<li><p>Main首字母必须大写</p>\n</li>\n<li><p>Main的最简单形式</p>\n<pre class=\"line-numbers language-c#\" data-language=\"c#\"><code class=\"language-c#\">static void Main()\n&#123;\n   &#x2F;&#x2F;更多语句\n&#125;<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span></span></code></pre></li>\n</ul>\n<h1 id=\"空白符\"><a href=\"#空白符\" class=\"headerlink\" title=\"空白符\"></a>空白符</h1><ul>\n<li>空格（Space）</li>\n<li>制表符（Tab）</li>\n<li>换行符</li>\n<li>回车符</li>\n</ul>\n<h1 id=\"块\"><a href=\"#块\" class=\"headerlink\" title=\"块\"></a>块</h1><ul>\n<li>语法上只需要一条语句，而你需要执行的动作无法用一条简单的语句表达的情况下，考虑使用块</li>\n<li>有些特定的程序结构只能使用块。在这些结构，不能用简单语句替代快</li>\n<li>块后面不跟分号</li>\n</ul>\n<h1 id=\"从程序中输出文本\"><a href=\"#从程序中输出文本\" class=\"headerlink\" title=\"从程序中输出文本\"></a>从程序中输出文本</h1><h2 id=\"Write\"><a href=\"#Write\" class=\"headerlink\" title=\"Write\"></a>Write</h2><ul>\n<li>Write是Console类的成员，将文本字符串发送到程序控制台窗口</li>\n<li>Write不会自动添加换行符</li>\n</ul>\n<pre class=\"line-numbers language-c#\" data-language=\"c#\"><code class=\"language-c#\">Console.Write(&quot;Hello&quot;);<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span></span></code></pre>\n\n<h2 id=\"WriteLine\"><a href=\"#WriteLine\" class=\"headerlink\" title=\"WriteLine\"></a>WriteLine</h2><ul>\n<li>WriteLine是Console类的成员，将文本字符串发送到程序控制台窗口</li>\n<li>WriteLine会自动在结尾添加一个换行符</li>\n</ul>\n<pre class=\"line-numbers language-c#\" data-language=\"c#\"><code class=\"language-c#\">Console.WriteLine(&quot;Hello,World&quot;);<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span></span></code></pre>\n\n<h2 id=\"格式字符串\"><a href=\"#格式字符串\" class=\"headerlink\" title=\"格式字符串\"></a>格式字符串</h2><ul>\n<li><p>Write和WriteLine语句的常规形式中可以有一个以上的参数，参数间用逗号分隔</p>\n</li>\n<li><p>第一个参数必须是字符串，称为格式字符串，包含替代标记</p>\n</li>\n<li><p>语法：Console.WriteLine(格式字符串(含替代标记),替换值0,替换值1,替换值2,……);</p>\n<pre class=\"line-numbers language-c#\" data-language=\"c#\"><code class=\"language-c#\">Console.WriteLine(&quot;Hell&#123;0&#125;,Wor&#123;1&#125;d&quot;, &#39;o&#39;, &#39;l&#39;);<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span></span></code></pre></li>\n</ul>\n<div class=\"custom-quote tip\">\n<span class=\"custom-quote-svg\"><svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"\" xmlns=\"http://www.w3.org/2000/svg\" data-reactroot=\"\">\n<path fill=\"\" d=\"M20.86 14.13C20 14.7 19.56 15.74 19.77 16.76C20.13 18.55 18.55 20.13 16.76 19.77C15.74 19.57 14.7 20 14.13 20.86C13.12 22.38 10.89 22.38 9.88 20.86C9.3 20 8.26 19.56 7.24 19.77C5.45 20.13 3.87 18.55 4.23 16.76C4.43 15.74 4 14.7 3.14 14.13C1.62 13.12 1.62 10.89 3.14 9.88C4 9.3 4.44 8.26 4.23 7.24C3.87 5.45 5.45 3.87 7.24 4.23C8.26 4.44 9.3 4 9.87 3.14C10.88 1.62 13.11 1.62 14.12 3.14C14.7 4 15.74 4.44 16.76 4.23C18.55 3.87 20.13 5.45 19.77 7.24C19.56 8.26 20 9.3 20.86 9.87C22.38 10.88 22.38 13.12 20.86 14.13Z\" undefined=\"1\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M12.01 15C12.01 14.5 12.01 14.5 12.01 14.5C12.04 13.75 13 13.46 14.04 12.2C14.41 11.74 14.69 11.41 14.86 10.85C15.15 9.95 14.92 9.18 14.86 9.02C14.8 8.79 14.52 8 13.72 7.46C13.06 7.02 12.42 7 12.14 7C11.9 7 11.36 7 10.78 7.3C10.28 7.56 9.98 7.9 9.83 8.1C9.24 8.82 9.06 9.63 9 10.06\"></path>\n<path stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M11.99 18H12.01\"></path>\n</svg></span>\n<p class=\"custom-quote-title\">提示</p>\n<p>​        C#6.0引入字符串插值，通过直接在替代标记内插入变量名实现，前提需要加上$符号    </p>\n<pre class=\"line-numbers language-c#\" data-language=\"c#\"><code class=\"language-c#\">int var1 &#x3D; 3;\nint var2 &#x3D; 4;\nConsole.WriteLine($&quot;&#123;var1&#125;+&#123;var2&#125;&#x3D;?&quot;);<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span></span></code></pre>\n\n\n</div>\n<h2 id=\"多重标记和值\"><a href=\"#多重标记和值\" class=\"headerlink\" title=\"多重标记和值\"></a>多重标记和值</h2><ul>\n<li>在C#中可以使用任意数量的替代标记和任意数量的值，值可以以任何顺序使用</li>\n<li>值可以在格式字符串中替换任意次</li>\n<li>标记不能试图引用超出替换值列表长度以外位置的值，若引用超过长度以外的值，不会产生编译错误，但会产生运行时错误（异常）</li>\n</ul>\n<pre class=\"line-numbers language-c#\" data-language=\"c#\"><code class=\"language-c#\">Console.WriteLine(&quot;He&#123;0&#125;&#123;0&#125;o,Worl&#123;1&#125;&quot;,&#39;l&#39;,&#39;d&#39;);&#x2F;&#x2F;正确用法<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span></span></code></pre>\n\n<p><img src=\"https://cbaoblog.oss-cn-shanghai.aliyuncs.com/img/image-20230312184805411.png\" alt=\"image-20230312184805411\"></p>\n<h2 id=\"格式化数字字符串\"><a href=\"#格式化数字字符串\" class=\"headerlink\" title=\"格式化数字字符串\"></a>格式化数字字符串</h2><ul>\n<li>把值作为货币或者某个小数位数的定点值来显示</li>\n</ul>\n<pre class=\"line-numbers language-c#\" data-language=\"c#\"><code class=\"language-c#\">Console.WriteLine(&quot;The value:&#123;0:C&#125;&quot;, 500);<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span></span></code></pre>\n\n<p><img src=\"https://cbaoblog.oss-cn-shanghai.aliyuncs.com/img/image-20230312185544009.png\" alt=\"image-20230312185544009\"></p>\n<p><img src=\"https://cbaoblog.oss-cn-shanghai.aliyuncs.com/img/image-20230312190445081.png\" alt=\"image-20230312190445081\"></p>\n<h1 id=\"注释\"><a href=\"#注释\" class=\"headerlink\" title=\"注释\"></a>注释</h1><table>\n<thead>\n<tr>\n<th align=\"center\">类型</th>\n<th align=\"center\">开始</th>\n<th align=\"center\">结束</th>\n<th align=\"center\">描述</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"center\">单行注释</td>\n<td align=\"center\">//</td>\n<td align=\"center\"></td>\n<td align=\"center\">从开始标记到该行行尾的文本被编译器忽略</td>\n</tr>\n<tr>\n<td align=\"center\">带分隔符的注释</td>\n<td align=\"center\">/*</td>\n<td align=\"center\">*/</td>\n<td align=\"center\">从开始标记到结束标记之间的文本被编译器忽略</td>\n</tr>\n<tr>\n<td align=\"center\">文档注释</td>\n<td align=\"center\">///</td>\n<td align=\"center\"></td>\n<td align=\"center\">这种类型的注释包含XML文本，可以使用工具生成程序文档</td>\n</tr>\n</tbody></table>\n<h1 id=\"预定义类型\"><a href=\"#预定义类型\" class=\"headerlink\" title=\"预定义类型\"></a>预定义类型</h1><ul>\n<li>C#提供16种预定义类型</li>\n</ul>\n<p><img src=\"https://cbaoblog.oss-cn-shanghai.aliyuncs.com/img/image-20230312200102564.png\" alt=\"image-20230312200102564\"></p>\n<p><img src=\"https://cbaoblog.oss-cn-shanghai.aliyuncs.com/img/image-20230312200217648.png\" alt=\"image-20230312200217648\"></p>\n<p><img src=\"https://cbaoblog.oss-cn-shanghai.aliyuncs.com/img/image-20230312200254264.png\" alt=\"image-20230312200254264\"></p>\n<h1 id=\"用户定义类型\"><a href=\"#用户定义类型\" class=\"headerlink\" title=\"用户定义类型\"></a>用户定义类型</h1><h2 id=\"6种类型可以由用户自己创建\"><a href=\"#6种类型可以由用户自己创建\" class=\"headerlink\" title=\"6种类型可以由用户自己创建\"></a>6种类型可以由用户自己创建</h2><ul>\n<li>类类型（class）</li>\n<li>结构类型（struct）</li>\n<li>数组类型（array）</li>\n<li>枚举类型（enum）</li>\n<li>委托类型（delegate）</li>\n<li>接口类型（interface）</li>\n</ul>\n<h1 id=\"栈和堆\"><a href=\"#栈和堆\" class=\"headerlink\" title=\"栈和堆\"></a>栈和堆</h1><h2 id=\"栈\"><a href=\"#栈\" class=\"headerlink\" title=\"栈\"></a>栈</h2><ul>\n<li><p>栈是一个内存数组，是一个LIFO(后进先出的数据结构)</p>\n</li>\n<li><p>栈存储几种类型的数据</p>\n<ul>\n<li>某些类型变量的值</li>\n<li>程序当前的执行环境</li>\n<li>传递给方法的参数</li>\n</ul>\n</li>\n<li><p>栈的特征</p>\n<ul>\n<li>数据只能从栈的顶端插入和删除</li>\n<li>将数据放到栈顶称为入栈（push）</li>\n<li>从栈顶删除数据称为出栈（pop）</li>\n</ul>\n<p><img src=\"https://cbaoblog.oss-cn-shanghai.aliyuncs.com/img/image-20230312201747146.png\" alt=\"image-20230312201747146\"></p>\n</li>\n</ul>\n<div class=\"custom-quote tip\">\n<span class=\"custom-quote-svg\"><svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"\" xmlns=\"http://www.w3.org/2000/svg\" data-reactroot=\"\">\n<path fill=\"\" d=\"M20.86 14.13C20 14.7 19.56 15.74 19.77 16.76C20.13 18.55 18.55 20.13 16.76 19.77C15.74 19.57 14.7 20 14.13 20.86C13.12 22.38 10.89 22.38 9.88 20.86C9.3 20 8.26 19.56 7.24 19.77C5.45 20.13 3.87 18.55 4.23 16.76C4.43 15.74 4 14.7 3.14 14.13C1.62 13.12 1.62 10.89 3.14 9.88C4 9.3 4.44 8.26 4.23 7.24C3.87 5.45 5.45 3.87 7.24 4.23C8.26 4.44 9.3 4 9.87 3.14C10.88 1.62 13.11 1.62 14.12 3.14C14.7 4 15.74 4.44 16.76 4.23C18.55 3.87 20.13 5.45 19.77 7.24C19.56 8.26 20 9.3 20.86 9.87C22.38 10.88 22.38 13.12 20.86 14.13Z\" undefined=\"1\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M12.01 15C12.01 14.5 12.01 14.5 12.01 14.5C12.04 13.75 13 13.46 14.04 12.2C14.41 11.74 14.69 11.41 14.86 10.85C15.15 9.95 14.92 9.18 14.86 9.02C14.8 8.79 14.52 8 13.72 7.46C13.06 7.02 12.42 7 12.14 7C11.9 7 11.36 7 10.78 7.3C10.28 7.56 9.98 7.9 9.83 8.1C9.24 8.82 9.06 9.63 9 10.06\"></path>\n<path stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M11.99 18H12.01\"></path>\n</svg></span>\n<p class=\"custom-quote-title\">提示</p>\n<p><p>​        系统管理所有栈操作</p>\n</p>\n</div>\n<h2 id=\"堆\"><a href=\"#堆\" class=\"headerlink\" title=\"堆\"></a>堆</h2><ul>\n<li>堆是一块内存区域，在堆里可以分配大块的内存用于存储某种类型的数据对象</li>\n<li>与栈不同，堆里的内存能够以任意顺序存入和移除</li>\n<li>在C#中GC会自动清除无主的堆对象（C++需要程序员自己释放内存）</li>\n<li>GC垃圾收集的过程</li>\n</ul>\n<p><img src=\"https://cbaoblog.oss-cn-shanghai.aliyuncs.com/img/image-20230312202244187.png\" alt=\"image-20230312202244187\"></p>\n<h1 id=\"值类型和引用类型\"><a href=\"#值类型和引用类型\" class=\"headerlink\" title=\"值类型和引用类型\"></a>值类型和引用类型</h1><p><img src=\"https://cbaoblog.oss-cn-shanghai.aliyuncs.com/img/image-20230312203527565.png\" alt=\"image-20230312203527565\"></p>\n<p><img src=\"https://cbaoblog.oss-cn-shanghai.aliyuncs.com/img/image-20230312203842553.png\" alt=\"image-20230312203842553\"></p>\n<p><img src=\"https://cbaoblog.oss-cn-shanghai.aliyuncs.com/img/image-20230312203928453.png\" alt=\"image-20230312203928453\"></p>\n<h1 id=\"类\"><a href=\"#类\" class=\"headerlink\" title=\"类\"></a>类</h1><h2 id=\"声明类\"><a href=\"#声明类\" class=\"headerlink\" title=\"声明类\"></a>声明类</h2><pre class=\"line-numbers language-c#\" data-language=\"c#\"><code class=\"language-c#\">class Player\n&#123;\n    &#x2F;&#x2F;...\n&#125;<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span></span></code></pre>\n\n<h2 id=\"类成员\"><a href=\"#类成员\" class=\"headerlink\" title=\"类成员\"></a>类成员</h2><ul>\n<li><p>字段和方法是最重要的类成员类型。字段是数据成员，方法是函数成员</p>\n<ul>\n<li><p>字段：隶属于类的变量</p>\n<div class=\"custom-quote warning\">\n<span class=\"custom-quote-svg\"><svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"\" xmlns=\"http://www.w3.org/2000/svg\" data-reactroot=\"\">\n<path fill=\"\" d=\"M20.86 14.13C20 14.7 19.56 15.74 19.77 16.76C20.13 18.55 18.55 20.13 16.76 19.77C15.74 19.57 14.7 20 14.13 20.86C13.12 22.38 10.89 22.38 9.88 20.86C9.3 20 8.26 19.56 7.24 19.77C5.45 20.13 3.87 18.55 4.23 16.76C4.43 15.74 4 14.7 3.14 14.13C1.62 13.12 1.62 10.89 3.14 9.88C4 9.3 4.44 8.26 4.23 7.24C3.87 5.45 5.45 3.87 7.24 4.23C8.26 4.44 9.3 4 9.87 3.14C10.88 1.62 13.11 1.62 14.12 3.14C14.7 4 15.74 4.44 16.76 4.23C18.55 3.87 20.13 5.45 19.77 7.24C19.56 8.26 20 9.3 20.86 9.87C22.38 10.88 22.38 13.12 20.86 14.13Z\" undefined=\"1\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M12 8V13\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M12 15.99V16.01\"></path>\n</svg>\n</span>\n<p class=\"custom-quote-title\">注意</p>\n<p>​        与C/C++不同，C#在类型外部不能声明全局变量（变量或字段）。所有字段都属于类型，必须在类型内部声明。</p>\n\n</div>\n</li>\n<li><p>方法：相当于C++中的成员函数</p>\n<div class=\"custom-quote warning\">\n<span class=\"custom-quote-svg\"><svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"\" xmlns=\"http://www.w3.org/2000/svg\" data-reactroot=\"\">\n<path fill=\"\" d=\"M20.86 14.13C20 14.7 19.56 15.74 19.77 16.76C20.13 18.55 18.55 20.13 16.76 19.77C15.74 19.57 14.7 20 14.13 20.86C13.12 22.38 10.89 22.38 9.88 20.86C9.3 20 8.26 19.56 7.24 19.77C5.45 20.13 3.87 18.55 4.23 16.76C4.43 15.74 4 14.7 3.14 14.13C1.62 13.12 1.62 10.89 3.14 9.88C4 9.3 4.44 8.26 4.23 7.24C3.87 5.45 5.45 3.87 7.24 4.23C8.26 4.44 9.3 4 9.87 3.14C10.88 1.62 13.11 1.62 14.12 3.14C14.7 4 15.74 4.44 16.76 4.23C18.55 3.87 20.13 5.45 19.77 7.24C19.56 8.26 20 9.3 20.86 9.87C22.38 10.88 22.38 13.12 20.86 14.13Z\" undefined=\"1\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M12 8V13\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M12 15.99V16.01\"></path>\n</svg>\n</span>\n<p class=\"custom-quote-title\">注意</p>\n<p><p>​        与C/C++不同，C#中没有全局函数<br>​        C#中的所有方法必须包含返回类型或void</p>\n</p>\n</div>\n</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"为数据分配内存\"><a href=\"#为数据分配内存\" class=\"headerlink\" title=\"为数据分配内存\"></a>为数据分配内存</h2><ul>\n<li><p>使用new运算符为实际数据分配内存</p>\n</li>\n<li><p>new运算符为任意指定类型的实例分配并初始化内存。依据类型的不同从栈或堆里分配</p>\n<pre class=\"line-numbers language-c#\" data-language=\"c#\"><code class=\"language-c#\">Player p1&#x3D;new Player();<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span></span></code></pre></li>\n</ul>\n<h2 id=\"访问修饰符\"><a href=\"#访问修饰符\" class=\"headerlink\" title=\"访问修饰符\"></a>访问修饰符</h2><ul>\n<li>语法<ul>\n<li>字段：访问修饰符 类型 标识符;</li>\n<li>方法：访问修饰符 返回类型 方法名() {…}</li>\n</ul>\n</li>\n<li>五种修饰符<ul>\n<li>私有的（private）<ul>\n<li>C#默认的访问级别是私有访问</li>\n<li>私有成员只能从声明它的类的内部访问，其它的类看不见且无法访问它们</li>\n</ul>\n</li>\n<li>公有的（public）</li>\n<li>受保护的（protected）</li>\n<li>内部的（internal）</li>\n<li>受保护内部的（protected internal）</li>\n</ul>\n</li>\n</ul>\n<h1 id=\"方法\"><a href=\"#方法\" class=\"headerlink\" title=\"方法\"></a>方法</h1><h2 id=\"方法的结构\"><a href=\"#方法的结构\" class=\"headerlink\" title=\"方法的结构\"></a>方法的结构</h2><h3 id=\"方法头\"><a href=\"#方法头\" class=\"headerlink\" title=\"方法头\"></a>方法头</h3><ul>\n<li>指示方法是否返回数据，如果返回，返回什么类型</li>\n<li>方法的名称</li>\n<li>接受的数据类型</li>\n</ul>\n<h3 id=\"方法体\"><a href=\"#方法体\" class=\"headerlink\" title=\"方法体\"></a>方法体</h3><ul>\n<li>包含可执行代码的语句序列，执行过程从方法体的第一条语句开始，一直到整个方法结束</li>\n</ul>\n<p><img src=\"https://cbaoblog.oss-cn-shanghai.aliyuncs.com/img/QQ%E6%88%AA%E5%9B%BE20230314195842.png\" alt=\"QQ截图20230314195842\"></p>\n<h2 id=\"方法体内部的代码执行\"><a href=\"#方法体内部的代码执行\" class=\"headerlink\" title=\"方法体内部的代码执行\"></a>方法体内部的代码执行</h2><ul>\n<li>局部变量</li>\n<li>控制流结构</li>\n<li>方法调用</li>\n<li>内嵌的块</li>\n<li>其它方法（局部函数，C#7.0开始）</li>\n</ul>\n<h2 id=\"局部变量\"><a href=\"#局部变量\" class=\"headerlink\" title=\"局部变量\"></a>局部变量</h2><ul>\n<li>局部变量的生命周期仅限于创建它的块及其内嵌的块<ul>\n<li>声明时开始存在</li>\n<li>在块完成时结束存在</li>\n</ul>\n</li>\n<li>可以在方法体内任意位置声明局部变量，但必须在使用它们前声明</li>\n<li>不会隐式初始化，使用之前未赋值，编译器会产生错误消息</li>\n<li>类型推断和var关键字<ul>\n<li>var关键字只能用于局部变量，不能用于字段（属于类的变量为字段）</li>\n<li>只能在局部变量声明中包含初始化时使用</li>\n<li>一旦编译器推断出变量的类型，它就是固定且不能更改的</li>\n<li>var关键字不改变C#的强类型性质</li>\n</ul>\n</li>\n<li>在C#中不管嵌套级别如何，都不能在第一个名称的有效范围内声明另一个同名的局部变量</li>\n</ul>\n<h2 id=\"控制流\"><a href=\"#控制流\" class=\"headerlink\" title=\"控制流\"></a>控制流</h2><h3 id=\"选择语句\"><a href=\"#选择语句\" class=\"headerlink\" title=\"选择语句\"></a>选择语句</h3><ul>\n<li>if</li>\n<li>if…else</li>\n<li>switch</li>\n</ul>\n<h3 id=\"迭代语句\"><a href=\"#迭代语句\" class=\"headerlink\" title=\"迭代语句\"></a>迭代语句</h3><ul>\n<li>for循环</li>\n<li>while循环</li>\n<li>do循环</li>\n<li>foreach（为一组中每个成员执行一次）</li>\n</ul>\n<h3 id=\"跳转语句\"><a href=\"#跳转语句\" class=\"headerlink\" title=\"跳转语句\"></a>跳转语句</h3><ul>\n<li>break：跳出当前循环</li>\n<li>continue：到当前循环的底部</li>\n<li>goto：到一个标签</li>\n<li>return：返回到调用方法继续执行</li>\n</ul>\n<h2 id=\"返回值\"><a href=\"#返回值\" class=\"headerlink\" title=\"返回值\"></a>返回值</h2><ul>\n<li>如果要返回值，方法必须在方法名前面声明一个返回类型</li>\n<li>如果方法不返回值，必须声明为void返回类型</li>\n</ul>\n<h2 id=\"参数\"><a href=\"#参数\" class=\"headerlink\" title=\"参数\"></a>参数</h2><h3 id=\"形参\"><a href=\"#形参\" class=\"headerlink\" title=\"形参\"></a>形参</h3><ul>\n<li>形参是局部变量，声明在方法的参数列表中</li>\n</ul>\n<h3 id=\"实参\"><a href=\"#实参\" class=\"headerlink\" title=\"实参\"></a>实参</h3><ul>\n<li>用于初始化形参的表达式或变量称作实参</li>\n</ul>\n<h2 id=\"值参数\"><a href=\"#值参数\" class=\"headerlink\" title=\"值参数\"></a>值参数</h2><ul>\n<li>在栈中为形参分配空间</li>\n<li>将实参的值复制给形参</li>\n<li>改变形参不会影响实参</li>\n</ul>\n<h2 id=\"引用参数\"><a href=\"#引用参数\" class=\"headerlink\" title=\"引用参数\"></a>引用参数</h2><ul>\n<li>使用引用参数时，必须在方法的声明和调用中都是用ref修饰符</li>\n<li>实参必须是变量，且必须被赋值</li>\n<li>形参会改变实参</li>\n</ul>\n<h2 id=\"引用类型作为值参数和引用参数\"><a href=\"#引用类型作为值参数和引用参数\" class=\"headerlink\" title=\"引用类型作为值参数和引用参数\"></a>引用类型作为值参数和引用参数</h2><ul>\n<li>将引用类型对象作为值参数传递：如果在方法内创建一个新对象并赋值给形参，将切断形参与实参之间的关联，并且再调用方法后，新对象也不复存在。</li>\n<li>将引用类型对象作为引用参数传递：如果在方法内创建一个新对象并赋值给形参，在方法结束后该对象依然存在，并且是实参所引用的值。</li>\n</ul>\n<h2 id=\"输出参数\"><a href=\"#输出参数\" class=\"headerlink\" title=\"输出参数\"></a>输出参数</h2><ul>\n<li><p>必须在声明和调用中都使用修饰符。输出参数的修饰符是out不是ref</p>\n</li>\n<li><p>和引用参数相似，实参必须是变量，不能是其它类型的表达式</p>\n</li>\n<li><p>out修饰的形参，不用再外部初始化，但必须要在内部赋值，再使用</p>\n</li>\n<li><p>在C#7.0之后，</p>\n<pre class=\"line-numbers language-c#\" data-language=\"c#\"><code class=\"language-c#\">using System;\n\nnamespace Simple\n&#123;\n\n    class Program\n    &#123;\n        int Sum(out int val1, out int val2)\n        &#123;\n            val1 &#x3D; 20;\n            val2 &#x3D; 30;\n            return val1 + val2;\n        &#125;\n        static void Main()\n        &#123;\n            Program p1 &#x3D; new Program();\n            int sum &#x3D; p1.Sum(out int val1, out int val2);&#x2F;&#x2F;不在需要预先声明一个变量用作out参数\n            Console.WriteLine(&quot;val1:&#123;0&#125;,val2:&#123;1&#125;&quot;, val1, val2);\n        &#125;\n    &#125;\n&#125;<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li>\n</ul>\n<h2 id=\"参数数组\"><a href=\"#参数数组\" class=\"headerlink\" title=\"参数数组\"></a>参数数组</h2><ul>\n<li><p>在一个参数列表中只能有一个参数数组</p>\n</li>\n<li><p>如果有，必须是列表中的最后一个</p>\n</li>\n<li><p>由参数数组表示的所有参数必须是同一类型</p>\n</li>\n<li><p>在数据类型前使用params修饰符</p>\n</li>\n<li><p>在数据类型后放置一组空的方括号</p>\n<pre class=\"line-numbers language-c#\" data-language=\"c#\"><code class=\"language-c#\">void Test(params int[] vals);<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span></span></code></pre></li>\n<li><p>如果数组参数是值类型，那么值被复制，实参在方法内部不受影响</p>\n</li>\n<li><p>如果数组参数是引用类型，那么引用被赋值，实参引用的对象在方法内部会受到影响</p>\n</li>\n</ul>\n<h2 id=\"参数类型总结\"><a href=\"#参数类型总结\" class=\"headerlink\" title=\"参数类型总结\"></a>参数类型总结</h2><p><img src=\"https://cbaoblog.oss-cn-shanghai.aliyuncs.com/img/QQ%E6%88%AA%E5%9B%BE20230319152908.png\" alt=\"QQ截图20230319152908\"></p>\n<h2 id=\"ref局部变量和ref返回\"><a href=\"#ref局部变量和ref返回\" class=\"headerlink\" title=\"ref局部变量和ref返回\"></a>ref局部变量和ref返回</h2><h3 id=\"ref局部变量\"><a href=\"#ref局部变量\" class=\"headerlink\" title=\"ref局部变量\"></a>ref局部变量</h3><ul>\n<li><p>创建一个对象的别名，即使引用的对象是值类型</p>\n</li>\n<li><p>对任意一个变量的赋值都会反映到另一个变量上（类似C++中的引用），即使是值类型</p>\n</li>\n<li><p>语法</p>\n<pre class=\"line-numbers language-c#\" data-language=\"c#\"><code class=\"language-c#\">ref int y &#x3D; ref x;&#x2F;&#x2F;y是x的别名<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span></span></code></pre></li>\n</ul>\n<h3 id=\"ref返回\"><a href=\"#ref返回\" class=\"headerlink\" title=\"ref返回\"></a>ref返回</h3><ul>\n<li><p>使方法返回变量的引用而不是变量值</p>\n</li>\n<li><p>语法</p>\n<pre class=\"line-numbers language-c#\" data-language=\"c#\"><code class=\"language-c#\">public ref int RefToVal()\n&#123;\n    return ref Score;\n&#125;<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span></span></code></pre></li>\n</ul>\n<h2 id=\"方法重载\"><a href=\"#方法重载\" class=\"headerlink\" title=\"方法重载\"></a>方法重载</h2><p>一个类中可以有多个同名方法，叫做方法重载，使用相同名称的每个方法必须有一个和其它方法不同的签名</p>\n<ul>\n<li>方法签名组成<ul>\n<li>方法名称</li>\n<li>参数的数目</li>\n<li>参数的类型和顺序</li>\n<li>参数修饰符</li>\n</ul>\n</li>\n<li>返回类型不是签名的一部分</li>\n<li>形参的名称也不是签名的一部分</li>\n</ul>\n<h2 id=\"递归\"><a href=\"#递归\" class=\"headerlink\" title=\"递归\"></a>递归</h2><p>方法调用自身，叫做递归</p>\n<h1 id=\"深入理解类\"><a href=\"#深入理解类\" class=\"headerlink\" title=\"深入理解类\"></a>深入理解类</h1><h2 id=\"成员修饰符的顺序\"><a href=\"#成员修饰符的顺序\" class=\"headerlink\" title=\"成员修饰符的顺序\"></a>成员修饰符的顺序</h2><ul>\n<li>修饰符<ul>\n<li>如果有修饰符，必须放在核心声明之前</li>\n<li>如果有多个修饰符，可以任意顺序排列</li>\n</ul>\n</li>\n<li>特性<ul>\n<li>如果有特性，必须放在核心声明之前</li>\n<li>如果有多个特性，可以任意顺序排列</li>\n</ul>\n</li>\n</ul>\n<p><img src=\"https://cbaoblog.oss-cn-shanghai.aliyuncs.com/img/QQ%E6%88%AA%E5%9B%BE20230319200352.png\" alt=\"QQ截图20230319200352\"></p>\n<h2 id=\"静态字段\"><a href=\"#静态字段\" class=\"headerlink\" title=\"静态字段\"></a>静态字段</h2><ul>\n<li><p>静态字段被类的所有实例共享，所有实例都访问同一内存位置</p>\n</li>\n<li><p>用static修饰符将字段声明成静态</p>\n<pre class=\"line-numbers language-c#\" data-language=\"c#\"><code class=\"language-c#\">static int test &#x3D; 100;<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span></span></code></pre></li>\n<li><p>使用类名和’.’运算符访问静态字段</p>\n</li>\n<li><p>即使不存在类实例，静态成员也存在</p>\n</li>\n</ul>\n<h2 id=\"静态函数成员\"><a href=\"#静态函数成员\" class=\"headerlink\" title=\"静态函数成员\"></a>静态函数成员</h2><ul>\n<li>静态函数成员独立于任何类实例，即使没有类实例，仍然可以调用静态方法</li>\n<li>静态函数成员不能访问实例成员，但能访问静态成员</li>\n</ul>\n<h2 id=\"成员常量\"><a href=\"#成员常量\" class=\"headerlink\" title=\"成员常量\"></a>成员常量</h2><ul>\n<li>类似于静态字段，没有实例也可以使用</li>\n<li>与真正的静态量不同，常量没有自己的存储位置，类似于C/C++中的#define值</li>\n<li>不能声明成static</li>\n</ul>\n<h2 id=\"属性\"><a href=\"#属性\" class=\"headerlink\" title=\"属性\"></a>属性</h2><p>属性是代表类实例或类中数据项的成员</p>\n<ul>\n<li><p>属性的特征</p>\n<ul>\n<li>是命名的类成员</li>\n<li>有类型</li>\n<li>可以被赋值和读取</li>\n<li>属性是一个函数成员</li>\n<li>不一定为数据存储分配内存</li>\n<li>执行代码</li>\n</ul>\n</li>\n<li><p>属性是一组被称为访问器的方法</p>\n<ul>\n<li>set访问器为属性赋值<ul>\n<li>拥有一个单独的，隐式的值参，名称为value，与属性的类型相同</li>\n<li>拥有一个返回类型void</li>\n</ul>\n</li>\n<li>get访问器从属性获取值<ul>\n<li>没有参数</li>\n<li>拥有一个与属性类型相同的返回类型</li>\n<li>get访问器的所有执行路径必须包含一条return语句，返回一个属性类型的值</li>\n</ul>\n</li>\n<li>访问器set和get可以以任何顺序声明，且除了这两个访问器外，属性上不允许有其它方法</li>\n</ul>\n</li>\n<li><p>不能显示的调用访问器，会产生编译错误</p>\n</li>\n<li><p>属性和关联字段</p>\n<ul>\n<li><p>将字段声明成private，声明一个public属性来控制从类的外部对该字段的访问</p>\n<pre class=\"line-numbers language-c#\" data-language=\"c#\"><code class=\"language-c#\">class Test\n&#123;\n    private int val;\n    public int Value\n    &#123;\n        set &#123; val &#x3D; value; &#125;\n        get &#123; return val; &#125;\n        \n    &#125;  \n&#125;<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li>\n<li><p>属性和它们对应的后备字段的命名约定</p>\n<ul>\n<li><p>字段使用Camel大小写，属性使用Pascal大小写</p>\n<pre class=\"line-numbers language-c#\" data-language=\"c#\"><code class=\"language-c#\">class Test\n&#123;\n    private int val;&#x2F;&#x2F;字段使用Camel大小写\n    public int Value&#x2F;&#x2F;属性使用Pascal大小写\n    &#123;\n        set &#123; val &#x3D; value; &#125;\n        get &#123; return val; &#125;\n        \n    &#125;  \n&#125;<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li>\n<li><p>字段使用Camel大小写，并以下划线_开头，属性使用Pascal大小写（按照C#命名约定，推荐使用这种方式）</p>\n<pre class=\"line-numbers language-c#\" data-language=\"c#\"><code class=\"language-c#\">class Test\n&#123;\n    private int _val;&#x2F;&#x2F;字段使用Camel大小写，并以下划线_开头\n    public int Value&#x2F;&#x2F;属性使用Pascal大小写\n    &#123;\n        set &#123; val &#x3D; value; &#125;\n        get &#123; return val; &#125;\n        \n    &#125;  \n&#125;<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li>\n</ul>\n</li>\n</ul>\n</li>\n<li><p>属性和lambda表达式</p>\n<ul>\n<li><p>C#7.0引入的新语法</p>\n</li>\n<li><p>只能在访问函数体由一个表达式组成时才能使用</p>\n<pre class=\"line-numbers language-c#\" data-language=\"c#\"><code class=\"language-c#\">private int val;\npublic int Value\n&#123;\n    set&#x3D;&gt; val &#x3D; value &gt; 100 ? 100 : value;\n    get &#x3D;&gt; val;\n&#125;<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li>\n</ul>\n</li>\n</ul>\n<h3 id=\"只读和只写属性\"><a href=\"#只读和只写属性\" class=\"headerlink\" title=\"只读和只写属性\"></a>只读和只写属性</h3><p>属性的访问器可以单独声明</p>\n<ul>\n<li>只有get访问器的属性称为只读属性。只读属性能够安全的将一个数据项从类或类的实例中传出</li>\n<li>只有set访问器的属性称为只写属性</li>\n<li>两个访问器中至少有一个必须定义，否则编译器会报错</li>\n</ul>\n<h3 id=\"属性与公有字段\"><a href=\"#属性与公有字段\" class=\"headerlink\" title=\"属性与公有字段\"></a>属性与公有字段</h3><p>按照推荐的编码实践，属性比公有字段更好</p>\n<ul>\n<li>属性是函数成员而不是数据成员，允许处理输入和输出，而公有字段不行</li>\n<li>属性可以只读或只写，而字段不行</li>\n<li>编译后的变量和编译后的属性语义不同</li>\n</ul>\n<h3 id=\"自动实现属性\"><a href=\"#自动实现属性\" class=\"headerlink\" title=\"自动实现属性\"></a>自动实现属性</h3><p>因为属性经常被关联到后备字段，所以C#提供了自动实现属性（自动属性）</p>\n<ul>\n<li><p>允许只声明属性而不声明后备字段，编译器会创建后备字段，自动挂接到get和set访问器上</p>\n</li>\n<li><p>自动实现属性的要点如下</p>\n<ul>\n<li>不声明后备字段，编译器根据属性的类型分配存储</li>\n<li>不能提供访问器的方法体，必须被简单的声明为分号</li>\n</ul>\n<pre class=\"line-numbers language-c#\" data-language=\"c#\"><code class=\"language-c#\">class Test\n&#123;\n    public int Value&#123; get; set; &#125;\n&#125;<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span></span></code></pre></li>\n</ul>\n<h3 id=\"静态属性\"><a href=\"#静态属性\" class=\"headerlink\" title=\"静态属性\"></a>静态属性</h3><p>属性也可以声明为static。静态属性的访问器和所有静态成员一样，具有以下特点：</p>\n<ul>\n<li>不能访问类的实例成员，但能被实例成员访问</li>\n<li>不管类是否有实例，都存在</li>\n<li>在类的内部，可以仅使用名称来引用静态属性</li>\n<li>在类的外部，可以使用类名或者使用using static结构来引用静态属性</li>\n</ul>\n<h2 id=\"实例构造函数\"><a href=\"#实例构造函数\" class=\"headerlink\" title=\"实例构造函数\"></a>实例构造函数</h2><p>实例构造函数是一个特殊的方法，它在创建每个新实例时执行</p>\n<ul>\n<li>构造函数用于初始化类实例的状态</li>\n<li>如果希望能从类的外部创建类的实例，需要将构造函数声明为public</li>\n<li>构造函数的名称和类名相同</li>\n<li>构造函数不能有返回值</li>\n<li>构造函数可以带参数</li>\n<li>构造函数可以被重载</li>\n<li>如果在类的声明中没有显示的提供实例构造函数，编译器会提供一个隐式的默认构造函数（没有参数，构造体为空）</li>\n<li>如果为类显示定义了构造函数，编译器不会为该类定义默认构造函数</li>\n<li>将构造函数的访问修饰符设置成private，这样在类外部就不能实例该类型对象</li>\n</ul>\n<h2 id=\"静态构造函数\"><a href=\"#静态构造函数\" class=\"headerlink\" title=\"静态构造函数\"></a>静态构造函数</h2><p>构造函数可以声明为static，实例构造函数初始化每个新实例，static构造函数初始化类级别的项，通常静态构造函数初始化类的静态字段</p>\n<ul>\n<li>在引用任何静态成员之前</li>\n<li>在创建类的任何实例之前</li>\n<li>静态构造函数的名称必须和类名相同</li>\n<li>构造函数不能有返回值</li>\n<li>静态构造函数声明中使用static关键字</li>\n<li>类只能有一个静态构造函数，且不能带参数</li>\n<li>静态构造函数不能有访问修饰符</li>\n</ul>\n<div class=\"custom-quote warning\">\n<span class=\"custom-quote-svg\"><svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"\" xmlns=\"http://www.w3.org/2000/svg\" data-reactroot=\"\">\n<path fill=\"\" d=\"M20.86 14.13C20 14.7 19.56 15.74 19.77 16.76C20.13 18.55 18.55 20.13 16.76 19.77C15.74 19.57 14.7 20 14.13 20.86C13.12 22.38 10.89 22.38 9.88 20.86C9.3 20 8.26 19.56 7.24 19.77C5.45 20.13 3.87 18.55 4.23 16.76C4.43 15.74 4 14.7 3.14 14.13C1.62 13.12 1.62 10.89 3.14 9.88C4 9.3 4.44 8.26 4.23 7.24C3.87 5.45 5.45 3.87 7.24 4.23C8.26 4.44 9.3 4 9.87 3.14C10.88 1.62 13.11 1.62 14.12 3.14C14.7 4 15.74 4.44 16.76 4.23C18.55 3.87 20.13 5.45 19.77 7.24C19.56 8.26 20 9.3 20.86 9.87C22.38 10.88 22.38 13.12 20.86 14.13Z\" undefined=\"1\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M12 8V13\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M12 15.99V16.01\"></path>\n</svg>\n</span>\n<p class=\"custom-quote-title\">注意</p>\n<ul>\n<li>类既可以有静态构造函数也可以有实例构造函数</li>\n<li>如同静态方法，静态构造函数不能访问所在类的实例成员，因此不能使用this访问器</li>\n<li>不能从程序中显示的调用静态构造函数，系统自动调用</li>\n</ul>\n\n</div>\n<h2 id=\"对象初始化语句\"><a href=\"#对象初始化语句\" class=\"headerlink\" title=\"对象初始化语句\"></a>对象初始化语句</h2><ul>\n<li><p>创建对象的代码必须能够访问要初始化的字段和属性（公有的）</p>\n</li>\n<li><p>初始化语句发生在构造方法执行之后</p>\n</li>\n<li><p>语法示例</p>\n<pre class=\"line-numbers language-c#\" data-language=\"c#\"><code class=\"language-c#\">Test t2 &#x3D; new Test &#123; X &#x3D; 10, Y &#x3D; 20&#125;;&#x2F;&#x2F;使用了初始化语句<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span></span></code></pre></li>\n</ul>\n<h2 id=\"析构函数\"><a href=\"#析构函数\" class=\"headerlink\" title=\"析构函数\"></a>析构函数</h2><p>析构函数执行在类的实例被销毁之前需要的清理或释放非托管资源的行为</p>\n<h2 id=\"readonly修饰符\"><a href=\"#readonly修饰符\" class=\"headerlink\" title=\"readonly修饰符\"></a>readonly修饰符</h2><p>字段可以用readonly修饰符声明，作用类似于const，一旦值被设定就不能改变</p>\n<ul>\n<li><p>const字段只能在字段的声明语句中初始化，而readonly字段可以在下列任意位置设置它的值</p>\n<ul>\n<li>字段声明语句，类似const</li>\n<li>类的任何构造函数，如果是static字段，初始化必须在静态构造函数中完成</li>\n</ul>\n</li>\n<li><p>const字段的值必须在编译时决定，而readonly字段的值可以在运行时决定</p>\n</li>\n<li><p>语法示例</p>\n<pre class=\"line-numbers language-c++\" data-language=\"c++\"><code class=\"language-c++\">class Test\n&#123;\n    public Test()\n    &#123;\n        val &#x3D; 20;&#x2F;&#x2F;在构造函数中为只读字段赋值\n    &#125;\n    public readonly int val;&#x2F;&#x2F;只读字段\n&#125;<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li>\n</ul>\n<h2 id=\"this关键字\"><a href=\"#this关键字\" class=\"headerlink\" title=\"this关键字\"></a>this关键字</h2><p>this关键字在类中使用，是对当前实例的引用，它只能被用在下列类成员的代码块中</p>\n<ul>\n<li>实例构造函数</li>\n<li>实例方法</li>\n<li>属性和索引器的实例访问器</li>\n<li>用于区分类的成员和局部变量或参数</li>\n<li>作为调用方法的实参</li>\n</ul>\n<div class=\"custom-quote warning\">\n<span class=\"custom-quote-svg\"><svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"\" xmlns=\"http://www.w3.org/2000/svg\" data-reactroot=\"\">\n<path fill=\"\" d=\"M20.86 14.13C20 14.7 19.56 15.74 19.77 16.76C20.13 18.55 18.55 20.13 16.76 19.77C15.74 19.57 14.7 20 14.13 20.86C13.12 22.38 10.89 22.38 9.88 20.86C9.3 20 8.26 19.56 7.24 19.77C5.45 20.13 3.87 18.55 4.23 16.76C4.43 15.74 4 14.7 3.14 14.13C1.62 13.12 1.62 10.89 3.14 9.88C4 9.3 4.44 8.26 4.23 7.24C3.87 5.45 5.45 3.87 7.24 4.23C8.26 4.44 9.3 4 9.87 3.14C10.88 1.62 13.11 1.62 14.12 3.14C14.7 4 15.74 4.44 16.76 4.23C18.55 3.87 20.13 5.45 19.77 7.24C19.56 8.26 20 9.3 20.86 9.87C22.38 10.88 22.38 13.12 20.86 14.13Z\" undefined=\"1\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M12 8V13\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M12 15.99V16.01\"></path>\n</svg>\n</span>\n<p class=\"custom-quote-title\">注意</p>\n<p><p>​    因为静态成员不是实例的一部分，所以不能在任何静态函数成员的代码中使用this关键字</p>\n</p>\n</div>\n<h2 id=\"索引器\"><a href=\"#索引器\" class=\"headerlink\" title=\"索引器\"></a>索引器</h2><p>索引器是一组get和set的访问器，与属性类似</p>\n<ul>\n<li>和属性一样，索引器不用分配内存来存储</li>\n<li>索引器和属性都主要被用来访问其它数据成员，它们与这些成员关联，并为它们提供获取和设置访问<ul>\n<li>属性通常表示单个数据成员</li>\n<li>索引器通常表示多个数据成员</li>\n</ul>\n</li>\n<li>和属性一样，索引器可以只有一个访问器，也可以两个都有</li>\n<li>索引器总是实例成员，所以不能被声明成static</li>\n<li>和属性一样，实现get和set的访问器的代码不一定要关联到某个字段或属性</li>\n<li>不能显示调用get和set访问器</li>\n</ul>\n<h3 id=\"声明索引器\"><a href=\"#声明索引器\" class=\"headerlink\" title=\"声明索引器\"></a>声明索引器</h3><ul>\n<li>索引器没有名称。在名称的位置是关键字this</li>\n<li>参数列表在方括号中间</li>\n<li>参数列表中必须至少声明一个参数</li>\n</ul>\n<pre class=\"line-numbers language-c#\" data-language=\"c#\"><code class=\"language-c#\">string this[int index]\n&#123;\n    get &#123; return this[index]; &#125;\n    set &#123; this[index] &#x3D; value; &#125;\n&#125;<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<h3 id=\"索引器的set访问器\"><a href=\"#索引器的set访问器\" class=\"headerlink\" title=\"索引器的set访问器\"></a>索引器的set访问器</h3><p>当索引器被用于赋值时，set访问器被调用，并接受两项数据</p>\n<ul>\n<li>一个名为value的隐式参数，其中持有要保存的数据</li>\n<li>一个或更多索引参数，表示数据应该保存到哪里</li>\n</ul>\n<h3 id=\"索引器示例\"><a href=\"#索引器示例\" class=\"headerlink\" title=\"索引器示例\"></a>索引器示例</h3><pre class=\"line-numbers language-c#\" data-language=\"c#\"><code class=\"language-c#\">class Test\n&#123;\n    private int val1;\n    private int val2;\n    private int val3;\n\n    public int this[int index]\n    &#123;\n        get\n        &#123;\n            switch (index)\n            &#123;\n                case 0: return val1;\n                case 1: return val2;\n                case 2: return val3;\n                default:  throw new IndexOutOfRangeException();\n            &#125;\n        &#125;\n        set\n        &#123;\n            switch (index)\n            &#123;\n                case 0:val1&#x3D; value; break;\n                case 1:val2&#x3D; value; break;\n                case 2:val3&#x3D; value; break;\n                default:throw new IndexOutOfRangeException();\n            &#125;\n        &#125;\n    &#125;\n&#125;<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<h3 id=\"索引器重载\"><a href=\"#索引器重载\" class=\"headerlink\" title=\"索引器重载\"></a>索引器重载</h3><p>只要索引器的参数列表不同，类就可以有任意多个索引器。索引器类型不同是不够的</p>\n<div class=\"custom-quote warning\">\n<span class=\"custom-quote-svg\"><svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"\" xmlns=\"http://www.w3.org/2000/svg\" data-reactroot=\"\">\n<path fill=\"\" d=\"M20.86 14.13C20 14.7 19.56 15.74 19.77 16.76C20.13 18.55 18.55 20.13 16.76 19.77C15.74 19.57 14.7 20 14.13 20.86C13.12 22.38 10.89 22.38 9.88 20.86C9.3 20 8.26 19.56 7.24 19.77C5.45 20.13 3.87 18.55 4.23 16.76C4.43 15.74 4 14.7 3.14 14.13C1.62 13.12 1.62 10.89 3.14 9.88C4 9.3 4.44 8.26 4.23 7.24C3.87 5.45 5.45 3.87 7.24 4.23C8.26 4.44 9.3 4 9.87 3.14C10.88 1.62 13.11 1.62 14.12 3.14C14.7 4 15.74 4.44 16.76 4.23C18.55 3.87 20.13 5.45 19.77 7.24C19.56 8.26 20 9.3 20.86 9.87C22.38 10.88 22.38 13.12 20.86 14.13Z\" undefined=\"1\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M12 8V13\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M12 15.99V16.01\"></path>\n</svg>\n</span>\n<p class=\"custom-quote-title\">注意</p>\n<p>​        类中重载的索引器必须有不同的参数列表</p>\n\n</div>\n<h3 id=\"访问器的访问修饰符\"><a href=\"#访问器的访问修饰符\" class=\"headerlink\" title=\"访问器的访问修饰符\"></a>访问器的访问修饰符</h3><ul>\n<li>仅当成员（属性或索引器）既有get访问器也有set访问器时，其访问器才能有访问修饰符</li>\n<li>虽然两个访问器都必须出现，但其中只能有一个访问修饰符</li>\n<li>访问器的访问修饰符的限制必须比成员的访问级别更严格</li>\n</ul>\n<p><img src=\"https://cbaoblog.oss-cn-shanghai.aliyuncs.com/img/QQ%E6%88%AA%E5%9B%BE20230320210726.png\" alt=\"QQ截图20230320210726\"></p>\n<h3 id=\"分部类和分部类型\"><a href=\"#分部类和分部类型\" class=\"headerlink\" title=\"分部类和分部类型\"></a>分部类和分部类型</h3><p>类的声明可以分割成几个分部类的声明</p>\n<ul>\n<li><p>每个分部类的声明都含有一些类成员的声明</p>\n</li>\n<li><p>类的分部类声明可以在同一个文件中也可以在不同文件中</p>\n</li>\n<li><p>每个分部类声明必须标注为partial class，而不是单独的关键字class</p>\n</li>\n<li><p>分部类声明和普通类声明相同，只是增加了类型修饰符partial</p>\n</li>\n<li><p>分部类示例</p>\n<pre class=\"line-numbers language-c#\" data-language=\"c#\"><code class=\"language-c#\">partial class Test\n&#123;\n    public int val1;\n&#125;\n\npartial class Test\n&#123;\n    public Test()\n    &#123;\n        val1 &#x3D; 1;\n    &#125;\n    public int val2;\n&#125;<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li>\n</ul>\n<h3 id=\"分部方法\"><a href=\"#分部方法\" class=\"headerlink\" title=\"分部方法\"></a>分部方法</h3><p>分部方法是声明在分部类中不同部分的方法，分部方法的不同部分可以声明在分部类的不同部分中，也可以声明在同一个部分中</p>\n<h4 id=\"分部方法的两个部分\"><a href=\"#分部方法的两个部分\" class=\"headerlink\" title=\"分部方法的两个部分\"></a>分部方法的两个部分</h4><ul>\n<li>定义分部方法声明<ul>\n<li>给出签名和返回类型</li>\n<li>声明的实现部分只是一个分号</li>\n</ul>\n</li>\n<li>实现分部方法声明<ul>\n<li>给出签名和返回类型</li>\n<li>以普通的语句块形式实现</li>\n</ul>\n</li>\n</ul>\n<h1 id=\"类和继承\"><a href=\"#类和继承\" class=\"headerlink\" title=\"类和继承\"></a>类和继承</h1><h2 id=\"类继承\"><a href=\"#类继承\" class=\"headerlink\" title=\"类继承\"></a>类继承</h2><p>通过继承可以定义一个新类，新类为一个已经声明的类进行拓展</p>\n<ul>\n<li><p>可以使用一个已经存在的类作为新类的基础。已经存在的类称为基类，新类称为派生类</p>\n</li>\n<li><p>派生类组成如下</p>\n<ul>\n<li>本身声明中的成员</li>\n<li>基类的成员</li>\n</ul>\n</li>\n<li><p>要声明一个派生类，需要在类名后加入基类规格说明</p>\n<pre class=\"line-numbers language-c#\" data-language=\"c#\"><code class=\"language-c#\">class Base\n&#123;\n    \n&#125;\n\n&#x2F;&#x2F;使用基类规格说明,Base是Sub的基类\nclass Sub : Base\n&#123;\n    \n&#125;<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li>\n<li><p>派生类拓展它的基类，因为它包含基类的成员，还有它本身声明中新增功能</p>\n</li>\n<li><p>派生类不能删除它所继承的任何成员</p>\n</li>\n</ul>\n<h2 id=\"访问继承的成员\"><a href=\"#访问继承的成员\" class=\"headerlink\" title=\"访问继承的成员\"></a>访问继承的成员</h2><p>继承的成员可以被访问，就像它们是派生类自己声明的一样</p>\n<h2 id=\"所有类都派生自object\"><a href=\"#所有类都派生自object\" class=\"headerlink\" title=\"所有类都派生自object\"></a>所有类都派生自object</h2><p>除了特殊的类object，所有类都是派生类，即使没有基类规格说明，类object是唯一的非派生类，因为它是继承层次结构的基础</p>\n<ul>\n<li>没有基类规格说明的类隐式地直接派生自类object</li>\n<li>一个类声明的基类规格说明中只能有一个单独的类。称为单继承</li>\n<li>虽然类只能直接继承一个基类，但派生的层次没有限制</li>\n</ul>\n<h2 id=\"屏蔽基类成员\"><a href=\"#屏蔽基类成员\" class=\"headerlink\" title=\"屏蔽基类成员\"></a>屏蔽基类成员</h2><p>虽然派生类不能删除它继承的任何成员，但可以用与基类成员名称相同的成员来屏蔽基类成员。</p>\n<ul>\n<li><p>要屏蔽一个继承的数据成员，需要声明一个新的相同类型的成员，并使用相同的名称</p>\n</li>\n<li><p>通过在派生类中声明新的带有相同签名的函数成员，可以屏蔽继承的函数成员，签名由名称和参数列表组成，不包括返回类型</p>\n</li>\n<li><p>要让编译器知道故意屏蔽继承的成员，可使用new修饰符，否则编译器会警告你隐藏了一个继承的成员</p>\n<pre class=\"line-numbers language-c#\" data-language=\"c#\"><code class=\"language-c#\">class Base\n&#123;\n    public int val;\n&#125;\n\nclass Sub : Base\n&#123;\n    &#x2F;&#x2F;使用new 关键字 显示的告诉编译器屏蔽继承的成员\n    new public int val;\n&#125;<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li>\n<li><p>也可以屏蔽静态成员</p>\n</li>\n</ul>\n<h2 id=\"基类访问\"><a href=\"#基类访问\" class=\"headerlink\" title=\"基类访问\"></a>基类访问</h2><p>如果派生类必须访问被隐藏的继承成员，可以使用基类访问表达式，基类访问表达式由关键字base后面跟着一个点和成员名称组成</p>\n<pre class=\"line-numbers language-c#\" data-language=\"c#\"><code class=\"language-c#\">class Base\n&#123;\n    public int val&#x3D;20;\n&#125;\n\n&#x2F;&#x2F;使用基类规格说明,Base是Sub的基类\nclass Sub : Base\n&#123;\n    &#x2F;&#x2F;使用new 关键字 显示的告诉编译器屏蔽继承的成员\n    new public int val;\n    public void PrintfFun()\n    &#123;\n        &#x2F;&#x2F;使用base关键字访问被隐藏的基类成员\n        Console.WriteLine(base.val);\n    &#125;\n&#125;<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<h2 id=\"使用基类的引用\"><a href=\"#使用基类的引用\" class=\"headerlink\" title=\"使用基类的引用\"></a>使用基类的引用</h2><p>派生类的实例由基类的实例和派生类新增的成员组成。派生类的引用指向整个类对象，包括基类部分</p>\n<p>如果有一个派生类对象的引用，就可以获取该对象基类部分的引用（使用类型转换运算符把该引用转换为基类类型）</p>\n<pre class=\"line-numbers language-c#\" data-language=\"c#\"><code class=\"language-c#\">class Base\n&#123;\n    public void Printf()\n    &#123;\n        Console.WriteLine(&quot;My Base Class&quot;);\n    &#125;\n&#125;\n\n&#x2F;&#x2F;使用基类规格说明,Base是Sub的基类\nclass Sub : Base\n&#123;\n    &#x2F;&#x2F;隐藏基类的Printf函数\n    new public void Printf()\n    &#123;\n        Console.WriteLine(&quot;My Sub Class&quot;);\n    &#125;\n&#125;\n\nclass Program\n&#123;\n    static void Main()\n    &#123;\n        Sub s1&#x3D;new Sub();\n        Base b1 &#x3D; (Base)s1;&#x2F;&#x2F;强转成基类类型\n        b1.Printf();&#x2F;&#x2F;调用的是基类的Printf\n    &#125;  \n&#125;<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<h2 id=\"虚方法和覆写方法\"><a href=\"#虚方法和覆写方法\" class=\"headerlink\" title=\"虚方法和覆写方法\"></a>虚方法和覆写方法</h2><p>当使用基类的引用访问派生类对象时，得到的是基类的成员，虚方法可以使基类的引用访问“升至”派生类内</p>\n<h3 id=\"使用基类引用调用派生类方法\"><a href=\"#使用基类引用调用派生类方法\" class=\"headerlink\" title=\"使用基类引用调用派生类方法\"></a>使用基类引用调用派生类方法</h3><ul>\n<li>派生类的方法和基类的方法有相同的签名和返回类型</li>\n<li>基类的方法使用virtual标注</li>\n<li>派生类的方法使用override标注</li>\n</ul>\n<pre class=\"line-numbers language-c#\" data-language=\"c#\"><code class=\"language-c#\">class Base\n&#123;\n    &#x2F;&#x2F;virtual标记表示该方法可被覆写\n    virtual public void Printf()\n    &#123;\n        Console.WriteLine(&quot;My Base Class&quot;);\n    &#125;\n&#125;\n\n&#x2F;&#x2F;使用基类规格说明,Base是Sub的基类\nclass Sub : Base\n&#123;\n    &#x2F;&#x2F;override标记覆写基类方法\n    override public void Printf()\n    &#123;\n        Console.WriteLine(&quot;My Sub Class&quot;);\n    &#125;\n&#125;\n\n\nclass Program\n&#123;\n    static void Main()\n    &#123;\n        Sub s1&#x3D;new Sub();\n        Base b1 &#x3D; (Base)s1;&#x2F;&#x2F;强转成基类类型\n        b1.Printf();&#x2F;&#x2F;因为派生类覆写了基类方法，所以调用派生类方法\n    &#125;    \n&#125;<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<div class=\"custom-quote warning\">\n<span class=\"custom-quote-svg\"><svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"\" xmlns=\"http://www.w3.org/2000/svg\" data-reactroot=\"\">\n<path fill=\"\" d=\"M20.86 14.13C20 14.7 19.56 15.74 19.77 16.76C20.13 18.55 18.55 20.13 16.76 19.77C15.74 19.57 14.7 20 14.13 20.86C13.12 22.38 10.89 22.38 9.88 20.86C9.3 20 8.26 19.56 7.24 19.77C5.45 20.13 3.87 18.55 4.23 16.76C4.43 15.74 4 14.7 3.14 14.13C1.62 13.12 1.62 10.89 3.14 9.88C4 9.3 4.44 8.26 4.23 7.24C3.87 5.45 5.45 3.87 7.24 4.23C8.26 4.44 9.3 4 9.87 3.14C10.88 1.62 13.11 1.62 14.12 3.14C14.7 4 15.74 4.44 16.76 4.23C18.55 3.87 20.13 5.45 19.77 7.24C19.56 8.26 20 9.3 20.86 9.87C22.38 10.88 22.38 13.12 20.86 14.13Z\" undefined=\"1\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M12 8V13\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M12 15.99V16.01\"></path>\n</svg>\n</span>\n<p class=\"custom-quote-title\">注意</p>\n<p><ul>\n<li>覆写和被覆写的方法必须有相同的可访问性</li>\n<li>不能覆写static方法或非虚方法</li>\n<li>方法，属性和索引器，事件都可以被声明成virtual和override</li>\n</ul>\n</p>\n</div>\n<h2 id=\"覆写标记为override的方法\"><a href=\"#覆写标记为override的方法\" class=\"headerlink\" title=\"覆写标记为override的方法\"></a>覆写标记为override的方法</h2><ul>\n<li>当使用对象基类部分的引用调用一个被覆写的方法时，方法的调用被沿派生层次上溯执行，一直到标记为override的方法的最高派生版本</li>\n<li>如果在更高的派生级别有该方法的其它声明，但没有被override标记，那么不会被调用</li>\n</ul>\n<h2 id=\"构造函数执行\"><a href=\"#构造函数执行\" class=\"headerlink\" title=\"构造函数执行\"></a>构造函数执行</h2><ul>\n<li>要创建对象的基类部分，需要隐式调用基类的某个构造函数</li>\n<li>继承层次链中的每个类在执行它自己的构造函数体之前执行它基类的构造函数</li>\n</ul>\n<p><img src=\"https://cbaoblog.oss-cn-shanghai.aliyuncs.com/img/QQ%E6%88%AA%E5%9B%BE20230321215406.png\" alt=\"QQ截图20230321215406\"></p>\n<div class=\"custom-quote warning\">\n<span class=\"custom-quote-svg\"><svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"\" xmlns=\"http://www.w3.org/2000/svg\" data-reactroot=\"\">\n<path fill=\"\" d=\"M20.86 14.13C20 14.7 19.56 15.74 19.77 16.76C20.13 18.55 18.55 20.13 16.76 19.77C15.74 19.57 14.7 20 14.13 20.86C13.12 22.38 10.89 22.38 9.88 20.86C9.3 20 8.26 19.56 7.24 19.77C5.45 20.13 3.87 18.55 4.23 16.76C4.43 15.74 4 14.7 3.14 14.13C1.62 13.12 1.62 10.89 3.14 9.88C4 9.3 4.44 8.26 4.23 7.24C3.87 5.45 5.45 3.87 7.24 4.23C8.26 4.44 9.3 4 9.87 3.14C10.88 1.62 13.11 1.62 14.12 3.14C14.7 4 15.74 4.44 16.76 4.23C18.55 3.87 20.13 5.45 19.77 7.24C19.56 8.26 20 9.3 20.86 9.87C22.38 10.88 22.38 13.12 20.86 14.13Z\" undefined=\"1\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M12 8V13\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M12 15.99V16.01\"></path>\n</svg>\n</span>\n<p class=\"custom-quote-title\">注意</p>\n<p>​    强烈反对在构造函数中调用虚方法，在执行基类的构造函数时，基类的虚方法会调用派生类的覆写方法，但这是在执行派生类的构造函数方法之前。</p>\n<p>​    因此，调用会在派生类完全初始化之前传递到派生类。</p>\n\n</div>\n<h2 id=\"构造函数初始化语句\"><a href=\"#构造函数初始化语句\" class=\"headerlink\" title=\"构造函数初始化语句\"></a>构造函数初始化语句</h2><p>默认情况下，在构造对象时，将调用基类的无参构造函数。</p>\n<p>如果希望派生类使用指定的基类构造函数，必须在构造函数初始化语句中指定它</p>\n<ul>\n<li><p>第一种形式使用关键字base指明使用哪一个基类构造函数</p>\n<pre class=\"line-numbers language-c#\" data-language=\"c#\"><code class=\"language-c#\">class Base\n&#123;\n    public Base(int val1,int val2)\n    &#123;\n        Val1 &#x3D; val1;\n        Val2 &#x3D; val2;\n    &#125;\n\n    public int Val1;\n    public int Val2;\n&#125;\n\nclass SubClass : Base\n&#123;\n    &#x2F;&#x2F;base指明使用哪一个基类构造函数\n    public SubClass(int val1, int val2) : base(val1, val2)\n    &#123;\n\n    &#125;\n&#125;<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li>\n<li><p>第二种形式使用关键字this并指明应该使用当前类的哪一个构造函数</p>\n<pre class=\"line-numbers language-c#\" data-language=\"c#\"><code class=\"language-c#\">class Base\n&#123;\n    &#x2F;&#x2F;使用this指定调用当前类的无参构造函数\n    public Base(int val1):this()\n    &#123;\n        Val1 &#x3D; val1;\n    &#125;\n\n    public Base()\n    &#123;\n        Val2 &#x3D; 20;\n    &#125;\n\n    public int Val1;\n    public int Val2;\n\n    public void Printf()\n    &#123;\n        Console.WriteLine($&quot;Val1:&#123;Val1&#125;\\nVal2:&#123;Val2&#125;&quot;);\n    &#125;\n&#125;<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li>\n</ul>\n<h2 id=\"类访问修饰符\"><a href=\"#类访问修饰符\" class=\"headerlink\" title=\"类访问修饰符\"></a>类访问修饰符</h2><p>类的可访问性有两个级别</p>\n<ul>\n<li><p>标记为public的类可以被系统内任何程序集中的代码访问，要是一个类对其它程序集可见，使用public访问修饰符</p>\n<pre class=\"line-numbers language-c#\" data-language=\"c#\"><code class=\"language-c#\">public class Base\n&#123;\n    \n&#125;<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span></span></code></pre></li>\n<li><p>标记为internal的类只能被它自己所在的程序集内的类看到</p>\n<ul>\n<li>这是C#默认的可访问级别</li>\n<li>可以使用internal访问修饰符显示的声明一个类为内部的</li>\n</ul>\n<pre class=\"line-numbers language-c#\" data-language=\"c#\"><code class=\"language-c#\">internal class Base\n&#123;\n    \n&#125;<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span></span></code></pre></li>\n</ul>\n<h2 id=\"程序集之间的继承\"><a href=\"#程序集之间的继承\" class=\"headerlink\" title=\"程序集之间的继承\"></a>程序集之间的继承</h2><p>要从不同程序集中定义的基类派生类，必须具备两个条件</p>\n<ul>\n<li>基类必须被声明成public，这样才能从它所在的程序集外部访问它</li>\n<li>必须在VS工程中的References节点中添加对包含该基类的程序集的引用</li>\n</ul>\n<h2 id=\"成员访问修饰符\"><a href=\"#成员访问修饰符\" class=\"headerlink\" title=\"成员访问修饰符\"></a>成员访问修饰符</h2><ul>\n<li>所有显示声明在类声明中的成员都是相互可见的，无论访问性如何</li>\n<li>继承的成员不在类的声明中显式声明，所以继承的成员对派生类的成员可能是可见的，也可能是不可见的</li>\n<li>五个成员访问级别<ul>\n<li>public<ul>\n<li>访问级别是限制最少的。所有的类，包括程序集内部的类和外部的类都可以自由的访问成员</li>\n</ul>\n</li>\n<li>private<ul>\n<li>修饰的类成员只能被它自己的类的成员访问，不能被其它的类访问，包括继承它的类</li>\n<li>private成员能被嵌套在它的类中的类成员访问</li>\n</ul>\n</li>\n<li>protected<ul>\n<li>访问级别类似private访问级别，但它允许派生自该类的类访问该成员</li>\n</ul>\n</li>\n<li>internal<ul>\n<li>标记为internal的成员对程序集内部的所有类可见，但对程序集外部的类不可见</li>\n</ul>\n</li>\n<li>protected internal</li>\n<li>标记为protected internal的成员对所有继承该类的类以及程序集内部的所有类可见</li>\n</ul>\n</li>\n</ul>\n<p><img src=\"https://cbaoblog.oss-cn-shanghai.aliyuncs.com/img/QQ%E6%88%AA%E5%9B%BE20230322204728.png\" alt=\"QQ截图20230322204728\"></p>\n<p><img src=\"https://cbaoblog.oss-cn-shanghai.aliyuncs.com/img/QQ%E6%88%AA%E5%9B%BE20230322204939.png\" alt=\"QQ截图20230322204939\"></p>\n<h2 id=\"抽象成员\"><a href=\"#抽象成员\" class=\"headerlink\" title=\"抽象成员\"></a>抽象成员</h2><ul>\n<li>必须是一个函数成员，字段和常量不能为抽象成员</li>\n<li>必须用abstract修饰符标记</li>\n<li>不能有实现代码块，抽象成员的代码用分号表示</li>\n<li>抽象成员只能在抽象类中声明</li>\n<li>一共有四种类型的成员可以声明为抽象的<ul>\n<li>方法</li>\n<li>属性</li>\n<li>事件</li>\n<li>索引器</li>\n</ul>\n</li>\n</ul>\n<div class=\"custom-quote warning\">\n<span class=\"custom-quote-svg\"><svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"\" xmlns=\"http://www.w3.org/2000/svg\" data-reactroot=\"\">\n<path fill=\"\" d=\"M20.86 14.13C20 14.7 19.56 15.74 19.77 16.76C20.13 18.55 18.55 20.13 16.76 19.77C15.74 19.57 14.7 20 14.13 20.86C13.12 22.38 10.89 22.38 9.88 20.86C9.3 20 8.26 19.56 7.24 19.77C5.45 20.13 3.87 18.55 4.23 16.76C4.43 15.74 4 14.7 3.14 14.13C1.62 13.12 1.62 10.89 3.14 9.88C4 9.3 4.44 8.26 4.23 7.24C3.87 5.45 5.45 3.87 7.24 4.23C8.26 4.44 9.3 4 9.87 3.14C10.88 1.62 13.11 1.62 14.12 3.14C14.7 4 15.74 4.44 16.76 4.23C18.55 3.87 20.13 5.45 19.77 7.24C19.56 8.26 20 9.3 20.86 9.87C22.38 10.88 22.38 13.12 20.86 14.13Z\" undefined=\"1\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M12 8V13\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M12 15.99V16.01\"></path>\n</svg>\n</span>\n<p class=\"custom-quote-title\">注意</p>\n<p><ul>\n<li>尽管抽象成员必须在派生类中用相应的成员覆写，但不能把virtual修饰符附加到abstract修饰符</li>\n<li>类似于虚成员，派生类中抽象成员的实现必须指定override修饰符</li>\n</ul>\n</p>\n</div>\n<p><img src=\"https://cbaoblog.oss-cn-shanghai.aliyuncs.com/img/QQ%E6%88%AA%E5%9B%BE20230322210944.png\" alt=\"QQ截图20230322210944\"></p>\n<h2 id=\"抽象类\"><a href=\"#抽象类\" class=\"headerlink\" title=\"抽象类\"></a>抽象类</h2><p>抽象类是指设计为被继承的类。抽象类只能被用作其它类的基类</p>\n<ul>\n<li><p>不能创建抽象类实例</p>\n</li>\n<li><p>抽象类使用abstract修饰符声明</p>\n<pre class=\"line-numbers language-c#\" data-language=\"c#\"><code class=\"language-c#\">abstract class Test\n&#123;\n\n&#125;<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span></span></code></pre></li>\n<li><p>抽象类可以包含抽象成员或普通的非抽象成员，抽象类的成员可以是抽象成员和普通带实现的成员的任意组合</p>\n</li>\n<li><p>抽象类自己可以派生自另一个抽象类。</p>\n</li>\n<li><p>任何派生自抽象类的类必须使用override关键字实现该类所有的抽象成员，除非派生类自己也是抽象类</p>\n</li>\n</ul>\n<h2 id=\"密封类\"><a href=\"#密封类\" class=\"headerlink\" title=\"密封类\"></a>密封类</h2><ul>\n<li>密封类只能被用作独立的类，不能被用作基类（与抽象类相反，抽象类只能用作基类）</li>\n<li>密封类使用sealed修饰符标注</li>\n</ul>\n<pre class=\"line-numbers language-c#\" data-language=\"c#\"><code class=\"language-c#\">&#x2F;&#x2F;密封类\nsealed class Test\n&#123;\n    \n&#125;<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<h2 id=\"静态类\"><a href=\"#静态类\" class=\"headerlink\" title=\"静态类\"></a>静态类</h2><ul>\n<li>静态中所有成员都是静态的</li>\n<li>静态类用于存放不受实例数据影响的数据和函数</li>\n<li>类本身必须标记为static</li>\n<li>类的所有成员必须是静态的</li>\n<li>类可以有一个静态构造函数，但不能有实例构造函数，因为不能创建该类的实例</li>\n<li>静态类是隐式密封的，不能够继承静态类</li>\n<li>可以使用类名和成员名，像访问其它静态成员那样访问静态类成员</li>\n</ul>\n<pre class=\"line-numbers language-c#\" data-language=\"c#\"><code class=\"language-c#\">&#x2F;&#x2F;静态类\nstatic class Test\n&#123;\n    static Test()\n    &#123;\n        val &#x3D; 10;\n    &#125;\n    public static int val;\n    public static void PrintfMe()\n    &#123;\n        Console.WriteLine(&quot;My is static class&quot;);\n    &#125;\n&#125;<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<h2 id=\"拓展方法\"><a href=\"#拓展方法\" class=\"headerlink\" title=\"拓展方法\"></a>拓展方法</h2><h3 id=\"为一个类添加方法的几种方式\"><a href=\"#为一个类添加方法的几种方式\" class=\"headerlink\" title=\"为一个类添加方法的几种方式\"></a>为一个类添加方法的几种方式</h3><ul>\n<li><p>如果有源代码并可以修改这个类，只需要为这个类增加一个新方法</p>\n</li>\n<li><p>如果不能修改这个类，但是这个类不是密封的，可以将这个类作为基类在派生类中添加一个新方法</p>\n</li>\n<li><p>如果这个类是密封类</p>\n<ul>\n<li><p>用一个静态类，在静态类中写一个新方法给这个类使用（不推荐）</p>\n</li>\n<li><p>使用拓展方法（推荐使用）</p>\n<pre class=\"line-numbers language-c#\" data-language=\"c#\"><code class=\"language-c#\">class Test\n&#123;\n    public Test(int val1, int val2)\n    &#123;\n        Val1 &#x3D; val1;\n        Val2 &#x3D; val2;\n    &#125;\n    public int Val1 &#123; get; set; &#125;\n    public int Val2 &#123; get; set; &#125;\n    \n    public int Sum() &#123; return Val1 + Val2; &#125;\n    \n&#125;\n    \nstatic class ExtendTest\n&#123;\n    &#x2F;&#x2F;为Test类添加一个拓展方法\n    public static double Average(this Test t1)\n    &#123;\n        return t1.Sum() &#x2F; 2.0f;\n    &#125;\n&#125;\n    \nclass Program\n&#123;\n    static void Main()\n    &#123;\n        Test t1 &#x3D; new Test(10, 20);\n        &#x2F;&#x2F;直接用该类调用该拓展方法\n        Console.WriteLine(t1.Average());\n    &#125;\n    \n&#125;<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li>\n</ul>\n</li>\n<li><p>拓展方法的要求</p>\n<ul>\n<li>声明拓展方法的类必须声明为static</li>\n<li>拓展方法本身必须声明为static</li>\n<li>拓展方法必须包含关键字this作为它的第一个参数类型，并在后面跟着它的拓展的类的名称<img src=\"https://cbaoblog.oss-cn-shanghai.aliyuncs.com/img/QQ%E6%88%AA%E5%9B%BE20230322215107.png\" alt=\"QQ截图20230322215107\"></li>\n</ul>\n</li>\n</ul>\n<h2 id=\"命名约定\"><a href=\"#命名约定\" class=\"headerlink\" title=\"命名约定\"></a>命名约定<img src=\"https://cbaoblog.oss-cn-shanghai.aliyuncs.com/img/QQ%E6%88%AA%E5%9B%BE20230322215428.png\" alt=\"QQ截图20230322215428\"></h2><h1 id=\"表达式和运算符\"><a href=\"#表达式和运算符\" class=\"headerlink\" title=\"表达式和运算符\"></a>表达式和运算符</h1><h2 id=\"运算符\"><a href=\"#运算符\" class=\"headerlink\" title=\"运算符\"></a>运算符</h2><p>运算符是一个符号</p>\n<ul>\n<li>将操作数作为输入（操作数是指作为运算符输入的数据元素）</li>\n<li>执行某个操作</li>\n<li>基于该操作返回一个值</li>\n</ul>\n<h2 id=\"字面量\"><a href=\"#字面量\" class=\"headerlink\" title=\"字面量\"></a>字面量</h2><p>字面量时源代码中键入的数字或字符串，表示一个指定类型的明确的，固定的值</p>\n<ul>\n<li><p>float字面量结尾要加上一个f</p>\n<pre class=\"line-numbers language-c#\" data-language=\"c#\"><code class=\"language-c#\">float f1&#x3D;12.5f;<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span></span></code></pre></li>\n<li><p>bool有两个字面量：true和false</p>\n</li>\n<li><p>对于引用类型变量，字面量null表示变量没有指向内存中的数据</p>\n</li>\n</ul>\n<h3 id=\"整数字面量\"><a href=\"#整数字面量\" class=\"headerlink\" title=\"整数字面量\"></a>整数字面量</h3><p>整数字面量是最常用的字面量，它们被书写为十进制数字序列</p>\n<ul>\n<li><p>没有小数点</p>\n</li>\n<li><p>带有可选的后缀，指明整数的类型</p>\n<pre class=\"line-numbers language-c#\" data-language=\"c#\"><code class=\"language-c#\">234&#x2F;&#x2F;整型\n236L&#x2F;&#x2F;长整型\n236U&#x2F;&#x2F;无符号整型\n236UL&#x2F;&#x2F;无符号长整形<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span></span></code></pre></li>\n<li><p>整数类型字面量还可以写成十六进制（hex）形式，数字必须是十六进制数（0到F），且字符串必须以0x或0X开始</p>\n</li>\n<li><p>整数类型字面量的第三种格式是二进制计法，所有数字必须是0或1，且以0b或者0B开始</p>\n</li>\n</ul>\n<p><img src=\"https://cbaoblog.oss-cn-shanghai.aliyuncs.com/img/QQ%E6%88%AA%E5%9B%BE20230322235111.png\" alt=\"QQ截图20230322235111\"></p>\n","feature":true,"text":"C#中的命名约定 风格名称 描述 推荐使用 示例 Pascal大小写 标识符每个单词首字母大写 用于类型名称和类中对外可见成员的名称（类，方法，命名空间，属性和公有字段） CardDeck Camel大小写 标识符每个单词首字母大写，第一个单词除外 用于局部变量的名称和方法声明的...","link":"","photos":[],"count_time":{"symbolsCount":"17k","symbolsTime":"15 mins."},"categories":[{"name":"C#","slug":"C","count":1,"path":"api/categories/C.json"}],"tags":[{"name":"C#","slug":"C","count":1,"path":"api/tags/C.json"}],"toc":"<ol class=\"toc\"><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#C-%E4%B8%AD%E7%9A%84%E5%91%BD%E5%90%8D%E7%BA%A6%E5%AE%9A\"><span class=\"toc-text\">C#中的命名约定</span></a></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#C-%E7%A8%8B%E5%BA%8F%E7%9A%84%E8%B5%B7%E7%82%B9%EF%BC%9AMain\"><span class=\"toc-text\">C#程序的起点：Main</span></a></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#%E7%A9%BA%E7%99%BD%E7%AC%A6\"><span class=\"toc-text\">空白符</span></a></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#%E5%9D%97\"><span class=\"toc-text\">块</span></a></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#%E4%BB%8E%E7%A8%8B%E5%BA%8F%E4%B8%AD%E8%BE%93%E5%87%BA%E6%96%87%E6%9C%AC\"><span class=\"toc-text\">从程序中输出文本</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#Write\"><span class=\"toc-text\">Write</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#WriteLine\"><span class=\"toc-text\">WriteLine</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E6%A0%BC%E5%BC%8F%E5%AD%97%E7%AC%A6%E4%B8%B2\"><span class=\"toc-text\">格式字符串</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E5%A4%9A%E9%87%8D%E6%A0%87%E8%AE%B0%E5%92%8C%E5%80%BC\"><span class=\"toc-text\">多重标记和值</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E6%A0%BC%E5%BC%8F%E5%8C%96%E6%95%B0%E5%AD%97%E5%AD%97%E7%AC%A6%E4%B8%B2\"><span class=\"toc-text\">格式化数字字符串</span></a></li></ol></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#%E6%B3%A8%E9%87%8A\"><span class=\"toc-text\">注释</span></a></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#%E9%A2%84%E5%AE%9A%E4%B9%89%E7%B1%BB%E5%9E%8B\"><span class=\"toc-text\">预定义类型</span></a></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#%E7%94%A8%E6%88%B7%E5%AE%9A%E4%B9%89%E7%B1%BB%E5%9E%8B\"><span class=\"toc-text\">用户定义类型</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#6%E7%A7%8D%E7%B1%BB%E5%9E%8B%E5%8F%AF%E4%BB%A5%E7%94%B1%E7%94%A8%E6%88%B7%E8%87%AA%E5%B7%B1%E5%88%9B%E5%BB%BA\"><span class=\"toc-text\">6种类型可以由用户自己创建</span></a></li></ol></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#%E6%A0%88%E5%92%8C%E5%A0%86\"><span class=\"toc-text\">栈和堆</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E6%A0%88\"><span class=\"toc-text\">栈</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E5%A0%86\"><span class=\"toc-text\">堆</span></a></li></ol></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#%E5%80%BC%E7%B1%BB%E5%9E%8B%E5%92%8C%E5%BC%95%E7%94%A8%E7%B1%BB%E5%9E%8B\"><span class=\"toc-text\">值类型和引用类型</span></a></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#%E7%B1%BB\"><span class=\"toc-text\">类</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E5%A3%B0%E6%98%8E%E7%B1%BB\"><span class=\"toc-text\">声明类</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E7%B1%BB%E6%88%90%E5%91%98\"><span class=\"toc-text\">类成员</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E4%B8%BA%E6%95%B0%E6%8D%AE%E5%88%86%E9%85%8D%E5%86%85%E5%AD%98\"><span class=\"toc-text\">为数据分配内存</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E8%AE%BF%E9%97%AE%E4%BF%AE%E9%A5%B0%E7%AC%A6\"><span class=\"toc-text\">访问修饰符</span></a></li></ol></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#%E6%96%B9%E6%B3%95\"><span class=\"toc-text\">方法</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E6%96%B9%E6%B3%95%E7%9A%84%E7%BB%93%E6%9E%84\"><span class=\"toc-text\">方法的结构</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E6%96%B9%E6%B3%95%E5%A4%B4\"><span class=\"toc-text\">方法头</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E6%96%B9%E6%B3%95%E4%BD%93\"><span class=\"toc-text\">方法体</span></a></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E6%96%B9%E6%B3%95%E4%BD%93%E5%86%85%E9%83%A8%E7%9A%84%E4%BB%A3%E7%A0%81%E6%89%A7%E8%A1%8C\"><span class=\"toc-text\">方法体内部的代码执行</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E5%B1%80%E9%83%A8%E5%8F%98%E9%87%8F\"><span class=\"toc-text\">局部变量</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E6%8E%A7%E5%88%B6%E6%B5%81\"><span class=\"toc-text\">控制流</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E9%80%89%E6%8B%A9%E8%AF%AD%E5%8F%A5\"><span class=\"toc-text\">选择语句</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E8%BF%AD%E4%BB%A3%E8%AF%AD%E5%8F%A5\"><span class=\"toc-text\">迭代语句</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E8%B7%B3%E8%BD%AC%E8%AF%AD%E5%8F%A5\"><span class=\"toc-text\">跳转语句</span></a></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E8%BF%94%E5%9B%9E%E5%80%BC\"><span class=\"toc-text\">返回值</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E5%8F%82%E6%95%B0\"><span class=\"toc-text\">参数</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E5%BD%A2%E5%8F%82\"><span class=\"toc-text\">形参</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E5%AE%9E%E5%8F%82\"><span class=\"toc-text\">实参</span></a></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E5%80%BC%E5%8F%82%E6%95%B0\"><span class=\"toc-text\">值参数</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E5%BC%95%E7%94%A8%E5%8F%82%E6%95%B0\"><span class=\"toc-text\">引用参数</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E5%BC%95%E7%94%A8%E7%B1%BB%E5%9E%8B%E4%BD%9C%E4%B8%BA%E5%80%BC%E5%8F%82%E6%95%B0%E5%92%8C%E5%BC%95%E7%94%A8%E5%8F%82%E6%95%B0\"><span class=\"toc-text\">引用类型作为值参数和引用参数</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E8%BE%93%E5%87%BA%E5%8F%82%E6%95%B0\"><span class=\"toc-text\">输出参数</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E5%8F%82%E6%95%B0%E6%95%B0%E7%BB%84\"><span class=\"toc-text\">参数数组</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E5%8F%82%E6%95%B0%E7%B1%BB%E5%9E%8B%E6%80%BB%E7%BB%93\"><span class=\"toc-text\">参数类型总结</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#ref%E5%B1%80%E9%83%A8%E5%8F%98%E9%87%8F%E5%92%8Cref%E8%BF%94%E5%9B%9E\"><span class=\"toc-text\">ref局部变量和ref返回</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#ref%E5%B1%80%E9%83%A8%E5%8F%98%E9%87%8F\"><span class=\"toc-text\">ref局部变量</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#ref%E8%BF%94%E5%9B%9E\"><span class=\"toc-text\">ref返回</span></a></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E6%96%B9%E6%B3%95%E9%87%8D%E8%BD%BD\"><span class=\"toc-text\">方法重载</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E9%80%92%E5%BD%92\"><span class=\"toc-text\">递归</span></a></li></ol></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E7%B1%BB\"><span class=\"toc-text\">深入理解类</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E6%88%90%E5%91%98%E4%BF%AE%E9%A5%B0%E7%AC%A6%E7%9A%84%E9%A1%BA%E5%BA%8F\"><span class=\"toc-text\">成员修饰符的顺序</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E9%9D%99%E6%80%81%E5%AD%97%E6%AE%B5\"><span class=\"toc-text\">静态字段</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E9%9D%99%E6%80%81%E5%87%BD%E6%95%B0%E6%88%90%E5%91%98\"><span class=\"toc-text\">静态函数成员</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E6%88%90%E5%91%98%E5%B8%B8%E9%87%8F\"><span class=\"toc-text\">成员常量</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E5%B1%9E%E6%80%A7\"><span class=\"toc-text\">属性</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E5%8F%AA%E8%AF%BB%E5%92%8C%E5%8F%AA%E5%86%99%E5%B1%9E%E6%80%A7\"><span class=\"toc-text\">只读和只写属性</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E5%B1%9E%E6%80%A7%E4%B8%8E%E5%85%AC%E6%9C%89%E5%AD%97%E6%AE%B5\"><span class=\"toc-text\">属性与公有字段</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E8%87%AA%E5%8A%A8%E5%AE%9E%E7%8E%B0%E5%B1%9E%E6%80%A7\"><span class=\"toc-text\">自动实现属性</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E9%9D%99%E6%80%81%E5%B1%9E%E6%80%A7\"><span class=\"toc-text\">静态属性</span></a></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E5%AE%9E%E4%BE%8B%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0\"><span class=\"toc-text\">实例构造函数</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E9%9D%99%E6%80%81%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0\"><span class=\"toc-text\">静态构造函数</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E5%AF%B9%E8%B1%A1%E5%88%9D%E5%A7%8B%E5%8C%96%E8%AF%AD%E5%8F%A5\"><span class=\"toc-text\">对象初始化语句</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E6%9E%90%E6%9E%84%E5%87%BD%E6%95%B0\"><span class=\"toc-text\">析构函数</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#readonly%E4%BF%AE%E9%A5%B0%E7%AC%A6\"><span class=\"toc-text\">readonly修饰符</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#this%E5%85%B3%E9%94%AE%E5%AD%97\"><span class=\"toc-text\">this关键字</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E7%B4%A2%E5%BC%95%E5%99%A8\"><span class=\"toc-text\">索引器</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E5%A3%B0%E6%98%8E%E7%B4%A2%E5%BC%95%E5%99%A8\"><span class=\"toc-text\">声明索引器</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E7%B4%A2%E5%BC%95%E5%99%A8%E7%9A%84set%E8%AE%BF%E9%97%AE%E5%99%A8\"><span class=\"toc-text\">索引器的set访问器</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E7%B4%A2%E5%BC%95%E5%99%A8%E7%A4%BA%E4%BE%8B\"><span class=\"toc-text\">索引器示例</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E7%B4%A2%E5%BC%95%E5%99%A8%E9%87%8D%E8%BD%BD\"><span class=\"toc-text\">索引器重载</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E8%AE%BF%E9%97%AE%E5%99%A8%E7%9A%84%E8%AE%BF%E9%97%AE%E4%BF%AE%E9%A5%B0%E7%AC%A6\"><span class=\"toc-text\">访问器的访问修饰符</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E5%88%86%E9%83%A8%E7%B1%BB%E5%92%8C%E5%88%86%E9%83%A8%E7%B1%BB%E5%9E%8B\"><span class=\"toc-text\">分部类和分部类型</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E5%88%86%E9%83%A8%E6%96%B9%E6%B3%95\"><span class=\"toc-text\">分部方法</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E5%88%86%E9%83%A8%E6%96%B9%E6%B3%95%E7%9A%84%E4%B8%A4%E4%B8%AA%E9%83%A8%E5%88%86\"><span class=\"toc-text\">分部方法的两个部分</span></a></li></ol></li></ol></li></ol></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#%E7%B1%BB%E5%92%8C%E7%BB%A7%E6%89%BF\"><span class=\"toc-text\">类和继承</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E7%B1%BB%E7%BB%A7%E6%89%BF\"><span class=\"toc-text\">类继承</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E8%AE%BF%E9%97%AE%E7%BB%A7%E6%89%BF%E7%9A%84%E6%88%90%E5%91%98\"><span class=\"toc-text\">访问继承的成员</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E6%89%80%E6%9C%89%E7%B1%BB%E9%83%BD%E6%B4%BE%E7%94%9F%E8%87%AAobject\"><span class=\"toc-text\">所有类都派生自object</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E5%B1%8F%E8%94%BD%E5%9F%BA%E7%B1%BB%E6%88%90%E5%91%98\"><span class=\"toc-text\">屏蔽基类成员</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E5%9F%BA%E7%B1%BB%E8%AE%BF%E9%97%AE\"><span class=\"toc-text\">基类访问</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E4%BD%BF%E7%94%A8%E5%9F%BA%E7%B1%BB%E7%9A%84%E5%BC%95%E7%94%A8\"><span class=\"toc-text\">使用基类的引用</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E8%99%9A%E6%96%B9%E6%B3%95%E5%92%8C%E8%A6%86%E5%86%99%E6%96%B9%E6%B3%95\"><span class=\"toc-text\">虚方法和覆写方法</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E4%BD%BF%E7%94%A8%E5%9F%BA%E7%B1%BB%E5%BC%95%E7%94%A8%E8%B0%83%E7%94%A8%E6%B4%BE%E7%94%9F%E7%B1%BB%E6%96%B9%E6%B3%95\"><span class=\"toc-text\">使用基类引用调用派生类方法</span></a></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E8%A6%86%E5%86%99%E6%A0%87%E8%AE%B0%E4%B8%BAoverride%E7%9A%84%E6%96%B9%E6%B3%95\"><span class=\"toc-text\">覆写标记为override的方法</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%E6%89%A7%E8%A1%8C\"><span class=\"toc-text\">构造函数执行</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%E5%88%9D%E5%A7%8B%E5%8C%96%E8%AF%AD%E5%8F%A5\"><span class=\"toc-text\">构造函数初始化语句</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E7%B1%BB%E8%AE%BF%E9%97%AE%E4%BF%AE%E9%A5%B0%E7%AC%A6\"><span class=\"toc-text\">类访问修饰符</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E7%A8%8B%E5%BA%8F%E9%9B%86%E4%B9%8B%E9%97%B4%E7%9A%84%E7%BB%A7%E6%89%BF\"><span class=\"toc-text\">程序集之间的继承</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E6%88%90%E5%91%98%E8%AE%BF%E9%97%AE%E4%BF%AE%E9%A5%B0%E7%AC%A6\"><span class=\"toc-text\">成员访问修饰符</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E6%8A%BD%E8%B1%A1%E6%88%90%E5%91%98\"><span class=\"toc-text\">抽象成员</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E6%8A%BD%E8%B1%A1%E7%B1%BB\"><span class=\"toc-text\">抽象类</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E5%AF%86%E5%B0%81%E7%B1%BB\"><span class=\"toc-text\">密封类</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E9%9D%99%E6%80%81%E7%B1%BB\"><span class=\"toc-text\">静态类</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E6%8B%93%E5%B1%95%E6%96%B9%E6%B3%95\"><span class=\"toc-text\">拓展方法</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E4%B8%BA%E4%B8%80%E4%B8%AA%E7%B1%BB%E6%B7%BB%E5%8A%A0%E6%96%B9%E6%B3%95%E7%9A%84%E5%87%A0%E7%A7%8D%E6%96%B9%E5%BC%8F\"><span class=\"toc-text\">为一个类添加方法的几种方式</span></a></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E5%91%BD%E5%90%8D%E7%BA%A6%E5%AE%9A\"><span class=\"toc-text\">命名约定</span></a></li></ol></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#%E8%A1%A8%E8%BE%BE%E5%BC%8F%E5%92%8C%E8%BF%90%E7%AE%97%E7%AC%A6\"><span class=\"toc-text\">表达式和运算符</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E8%BF%90%E7%AE%97%E7%AC%A6\"><span class=\"toc-text\">运算符</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E5%AD%97%E9%9D%A2%E9%87%8F\"><span class=\"toc-text\">字面量</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E6%95%B4%E6%95%B0%E5%AD%97%E9%9D%A2%E9%87%8F\"><span class=\"toc-text\">整数字面量</span></a></li></ol></li></ol></li></ol>","author":{"name":"cBao","slug":"blog-author","avatar":"https://cbaoblog.oss-cn-shanghai.aliyuncs.com/HeadPortrait.jpg","link":"/","description":"但求日积月累，收获于细微。<br /><b>虚幻引擎开发</b>","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}},"mapped":true,"prev_post":{},"next_post":{"title":"C语言字符输入/输出","uid":"297e7259160304ea1919564f5d876933","slug":"C语言字符输入输出","date":"2023-03-04T08:23:17.000Z","updated":"2023-03-04T15:12:52.060Z","comments":true,"path":"api/articles/C语言字符输入输出.json","keywords":null,"cover":"https://cbaoblog.oss-cn-shanghai.aliyuncs.com/c.png","text":"单字符I/Ogetchar()和putchar() getchar()和putchar()每次只处理一个字符 #include &lt;iostream> int main() &#123; char c; while((c=getchar())!='#')//当遇到'#'时结束...","link":"","photos":[],"count_time":{"symbolsCount":922,"symbolsTime":"1 mins."},"categories":[{"name":"C","slug":"C","count":1,"path":"api/categories/C.json"}],"tags":[{"name":"C","slug":"C","count":1,"path":"api/tags/C.json"}],"author":{"name":"cBao","slug":"blog-author","avatar":"https://cbaoblog.oss-cn-shanghai.aliyuncs.com/HeadPortrait.jpg","link":"/","description":"但求日积月累，收获于细微。<br /><b>虚幻引擎开发</b>","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}},"feature":true}}